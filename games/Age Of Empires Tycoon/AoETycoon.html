
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Age of Empire Tycoon - Definitive Edition</title>
    <style>
        :root {
            --primary-color: #2c3e50; --secondary-color: #34495e; --accent-color: #f1c40f;
            --background-color: #1c2833; --text-color: #ecf0f1; --border-color: #273746;
            --button-color: #2980b9; --button-hover: #3498db; --button-active: #2471a3;
            --button-disabled-bg: #566573; --button-disabled-text: #95a5a6;
            --error-color: #e74c3c; --success-color: #2ecc71; --info-color: #3498db;
            --font-primary: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            --font-monospace: 'Courier New', Courier, monospace;
            --map-tile-color: #4a6b8a; --map-tile-border: #2c4a6a;
            --map-grid-line-color: rgba(236, 240, 241, 0.05);
            --building-placeholder-valid: rgba(46, 204, 113, 0.5);
            --building-placeholder-invalid: rgba(231, 76, 60, 0.5);
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background-color: var(--background-color); color: var(--text-color); font-family: var(--font-primary);
            overflow: hidden; height: 100vh; display: flex; flex-direction: column;
        }
        #game-container { display: flex; height: 100vh; width: 100vw; }
        #game-canvas-container { flex: 3; position: relative; overflow: hidden; background-color: #000; cursor: grab; }
        #game-canvas-container.grabbing { cursor: grabbing; }
        #game-canvas { width: 100%; height: 100%; display: block; }
        #projectile-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 25; }
        #minimap-container {
            position: absolute; bottom: 15px; right: 15px;
            width: 200px; height: 150px; border: 2px solid var(--accent-color);
            background-color: rgba(0,0,0,0.6); z-index: 30; box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }
        #minimap-canvas { width: 100%; height: 100%; }
        #back-to-base-button {
            position: absolute; top: 70px; left: 15px; z-index: 30;
            background-color: var(--accent-color); color: var(--primary-color);
            padding: 8px 12px; border-radius: 5px; display:none; cursor: pointer;
            font-weight: bold; box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }
        #back-to-base-button:hover { background-color: #f39c12; }

        #sidebar {
            flex: 1; min-width: 380px; max-width: 500px; background-color: var(--primary-color);
            border-left: 2px solid var(--border-color); overflow-y: auto; padding: 15px;
            display: flex; flex-direction: column; gap: 15px;
        }
        .sidebar-section { padding: 15px; background-color: var(--secondary-color); border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.2); }
        .section-title { color: var(--accent-color); border-bottom: 2px solid var(--accent-color); padding-bottom: 8px; margin-bottom: 12px; font-size: 1.1em; font-weight: 600; }
        .resource-display { display: flex; justify-content: space-between; margin-bottom: 8px; font-size: 0.95em; }
        .resource-name { font-weight: 500; }
        .resource-value { font-family: var(--font-monospace); color: var(--accent-color); font-weight: bold; }
        .game-button {
            background-color: var(--button-color); border: none; color: var(--text-color); padding: 10px 15px; text-align: left;
            text-decoration: none; font-size: 0.9em; border-radius: 5px; margin: 5px 0; cursor: pointer;
            transition: background-color 0.2s ease-in-out, transform 0.1s ease, box-shadow 0.2s;
            display: flex; justify-content: space-between; align-items: center; width: 100%;
        }
        .game-button span:first-child { flex-grow: 1; }
        .game-button span:last-child { margin-left: 10px; font-weight: bold; }
        .game-button:hover:not(:disabled) { background-color: var(--button-hover); transform: translateY(-1px); box-shadow: 0 2px 5px rgba(0,0,0,0.2); }
        .game-button:active:not(:disabled) { background-color: var(--button-active); transform: translateY(0px); }
        .game-button:disabled { background-color: var(--button-disabled-bg); color: var(--button-disabled-text); cursor: not-allowed; }
        .game-button.pulse:not(:disabled) { animation: pulse-animation 1.5s infinite; }
        @keyframes pulse-animation { 0% { box-shadow: 0 0 0 0 rgba(241, 196, 15, 0.7); } 70% { box-shadow: 0 0 0 10px rgba(241, 196, 15, 0); } 100% { box-shadow: 0 0 0 0 rgba(241, 196, 15, 0); } }
        .game-button.raid-alert-button { background-color: var(--error-color); animation: pulse-danger-animation 1s infinite alternate; }
        @keyframes pulse-danger-animation { 0% { box-shadow: 0 0 0 0 rgba(231, 76, 60, 0.7); transform: scale(1); } 100% { box-shadow: 0 0 0 8px rgba(231, 76, 60, 0); transform: scale(1.02); } }
        .game-button.age-power-button { background-color: var(--info-color); }
        .game-button.age-power-button:hover:not(:disabled) { background-color: var(--button-hover); }
        .game-button.building-cancel-button { background-color: var(--error-color); margin-left: 10px; flex-grow: 0; padding: 5px 10px; min-width: 30px; max-width: 30px; }
        .unit-info, .training-queue-item-info, .construction-queue-item-info, .deployed-army-info { display: flex; justify-content: space-between; font-size: 0.85em; color: #bdc3c7; padding: 3px 5px; background-color: rgba(0,0,0,0.1); border-radius: 3px; margin-bottom: 3px; }
        .training-queue-item-info .progress-bar-small, .construction-queue-item-info .progress-bar-small, .deployed-army-info .progress-bar-small { height: 5px; background-color: var(--accent-color); border-radius: 2px; margin-top: 2px; width:0%; transition: width 0.3s linear; }
        #messages-container { position: absolute; bottom: 15px; left: 15px; width: clamp(300px, 50%, 600px); max-height: 150px; overflow-y: auto; background-color: rgba(0, 0, 0, 0.75); border-radius: 8px; padding: 12px; z-index: 10; font-size: 0.9em; box-shadow: 0 2px 5px rgba(0,0,0,0.3); }
        .message { margin-bottom: 6px; opacity: 0; animation: fadeIn 0.5s forwards; } .message:last-child { margin-bottom: 0; } @keyframes fadeIn { to { opacity: 1; } }
        #notification { position: absolute; top: 20px; left: 50%; transform: translateX(-50%); color: var(--text-color); padding: 12px 25px; border-radius: 8px; font-size: 1em; font-weight: 500; z-index: 100; display: none; box-shadow: 0 3px 8px rgba(0,0,0,0.3); opacity: 0; transition: opacity 0.3s ease-in-out; }
        #notification.show { display: block; opacity: 1; } #notification.error { background-color: var(--error-color); } #notification.success { background-color: var(--success-color); } #notification.info { background-color: var(--button-color); }
        .progress-container { width: 100%; background-color: var(--border-color); height: 12px; border-radius: 6px; margin-top: 5px; overflow: hidden; }
        .progress-bar { height: 100%; border-radius: 6px; background-color: var(--accent-color); width: 0%; transition: width 0.3s ease-in-out; }
        .item-slot { width: 100%; margin-bottom: 10px; background-color: rgba(0, 0, 0, 0.15); border-radius: 6px; display: flex; align-items: center; cursor: pointer; padding: 8px; transition: background-color 0.2s, box-shadow 0.2s; border: 1px solid transparent; }
        .item-slot:hover:not(.disabled):not(.placing-active) { background-color: rgba(0, 0, 0, 0.25); box-shadow: 0 0 8px rgba(var(--accent-color), 0.5); border-color: var(--accent-color); }
        .item-slot.disabled { opacity: 0.6; cursor: not-allowed; background-color: rgba(0,0,0,0.1); }
        .item-slot.placing-active { background-color: var(--accent-color) !important; color: var(--background-color) !important; border-color: var(--background-color) !important; }
        .item-slot.placing-active .item-cost, .item-slot.placing-active .item-description { color: var(--primary-color) !important; }
        .item-icon { width: 45px; height: 45px; background-color: var(--border-color); border-radius: 5px; display: flex; justify-content: center; align-items: center; font-size: 1.8em; margin-right: 12px; flex-shrink: 0; }
        .item-details { flex: 1; overflow: hidden; } .item-name { font-weight: 600; font-size: 1em; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .item-description { font-size: 0.8em; color: #bdc3c7; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .item-cost { font-weight: bold; font-family: var(--font-monospace); font-size: 0.95em; margin-left: 10px; color: var(--accent-color); min-width: 50px; text-align: right; }
        .tab-navigation { display: flex; margin-bottom: -1px; }
        .tab-button { flex: 1; padding: 12px; text-align: center; background-color: var(--secondary-color); cursor: pointer; transition: background-color 0.2s, color 0.2s; border: 1px solid var(--border-color); border-bottom: none; border-top-left-radius: 5px; border-top-right-radius: 5px; font-weight: 500; }
        .tab-button.active { background-color: var(--primary-color); color: var(--accent-color); border-bottom: 1px solid var(--primary-color); }
        .tab-button:not(.active):hover { background-color: var(--button-hover); }
        .tab-content { display: none; border: 1px solid var(--border-color); border-top: none; border-bottom-left-radius: 5px; border-bottom-right-radius: 5px; background-color: var(--primary-color); }
        .tab-content.active { display: block; }
        .log-container { background-color: rgba(0, 0, 0, 0.2); padding: 10px; border-radius: 5px; height: 120px; overflow-y: auto; font-size: 0.85em; border: 1px solid var(--border-color); }
        .log-container div { margin-bottom: 4px; }
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.85); display: flex; justify-content: center; align-items: center; z-index: 1000; opacity: 0; visibility: hidden; transition: opacity 0.3s ease, visibility 0s linear 0.3s; }
        .modal-overlay.visible { opacity: 1; visibility: visible; transition: opacity 0.3s ease, visibility 0s linear 0s; }
        .modal-content { background-color: var(--primary-color); border-radius: 10px; padding: 25px; max-width: 90vw; width: 600px; text-align: left; box-shadow: 0 5px 15px rgba(0,0,0,0.5); position: relative; max-height: 80vh; overflow-y: auto; }
        .modal-content h2 { color: var(--accent-color); margin-bottom: 15px; text-align: center; font-size: 1.5em; }
        .modal-content p { margin-bottom: 12px; line-height: 1.6; font-size: 0.95em; }
        .modal-navigation { display: flex; justify-content: space-between; margin-top: 25px; }
        .modal-close-button { position: absolute; top: 15px; right: 15px; background: none; border: none; color: var(--text-color); font-size: 1.8em; cursor: pointer; line-height: 1; }
        .era-label { position: absolute; top: 15px; left: 15px; background-color: rgba(0, 0, 0, 0.75); color: var(--accent-color); padding: 8px 12px; border-radius: 5px; font-size: 0.9em; font-weight: bold; z-index: 5; }
        #achievement-notification-popup { position: fixed; bottom: 20px; right: 20px; background-color: var(--accent-color); color: var(--background-color); padding: 15px 25px; border-radius: 8px; font-size: 1em; z-index: 101; display: none; text-align: center; box-shadow: 0 3px 10px rgba(0,0,0,0.3); opacity: 0; transform: translateY(20px); transition: opacity 0.3s ease, transform 0.3s ease; }
        #achievement-notification-popup.show { display: block; opacity: 1; transform: translateY(0); }
        #achievement-notification-popup strong { display: block; margin-bottom: 5px; font-size: 1.1em;}
        .tooltip { position: absolute; background-color: rgba(10, 10, 20, 0.95); color: var(--text-color); padding: 10px 15px; border-radius: 6px; font-size: 0.85em; z-index: 2000; pointer-events: none; opacity: 0; transition: opacity 0.2s ease-in-out; max-width: 300px; border: 1px solid var(--accent-color); box-shadow: 0 2px 8px rgba(0,0,0,0.4); line-height: 1.5; }
        .tooltip.visible { opacity: 1; } .tooltip strong { color: var(--accent-color); }
        .enemy-icon { background-color: var(--error-color); }
        #buildings-container, #units-container, #tech-container, #upgrades-container, #enemy-selection-list, #achievements-list, #training-queue-list, #active-raids-list, #battle-age-powers-container, #construction-queue-list, #deployed-armies-list { display: flex; flex-direction: column; gap: 8px; }
        #current-units-display .section-title { margin-bottom: 5px; } #current-units-display .unit-info { padding: 2px 5px; background-color: rgba(0,0,0,0.1); border-radius: 3px; margin-bottom: 3px;}

        #battle-modal-overlay .modal-content { width: 95vw; max-width: 1400px; height: 90vh; max-height: 850px; display: flex; flex-direction: column; }
        #battle-area {
            display: flex; justify-content: space-between; align-items: flex-start; flex-grow: 1;
            padding: 20px 10px; border-radius: 8px; margin-bottom: 15px; position: relative; gap: 15px;
            background-size: cover; background-position: center; transition: background-image 0.5s ease-in-out;
            border: 2px solid var(--border-color); background-color: rgba(0,0,0,0.1);
        }
        .battle-party {
             display: flex; flex-wrap: wrap; align-content: flex-start; justify-content: center;
             gap: 12px; width: 50%; max-height: 600px; overflow-y: auto;
             padding: 15px; background-color: rgba(0,0,0,0.25); border-radius: 8px;
             align-items: flex-start;
        }
        .battle-unit-stack {
            background-color: var(--primary-color); padding: 10px 12px; border-radius: 6px; text-align: center;
            border: 3px solid transparent; cursor: pointer; transition: all 0.2s ease-out;
            min-width: 170px; max-width: 200px; flex-basis: 180px; flex-grow: 1;
            margin-bottom: 8px; position: relative; box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        .battle-unit-stack.player-stack.selectable:not(.has-acted):not(.selected-actor):hover { border-color: var(--button-hover); transform: scale(1.03); box-shadow: 0 0 10px var(--button-hover);}
        .battle-unit-stack.player-stack.selected-actor { border-color: var(--accent-color); box-shadow: 0 0 15px var(--accent-color); transform: scale(1.06); z-index: 5; }
        .battle-unit-stack.player-stack.has-acted { opacity: 0.7; cursor: default; background-color: var(--secondary-color); border-color: #555;}
        .battle-unit-stack.enemy-stack.targetable:hover:not(.selected-target) { border-color: var(--button-hover); transform: scale(1.03); box-shadow: 0 0 10px var(--button-hover);}
        .battle-unit-stack.enemy-stack.selected-target { border-color: var(--error-color); box-shadow: 0 0 15px var(--error-color); transform: scale(1.06); z-index: 5; }
        .battle-unit-stack.defeated-stack { opacity: 0.4; background-color: #333; cursor: default; border-color: #111; }
        .battle-unit-icon { font-size: 2.8em; margin-bottom: 5px; display: block; }
        .battle-unit-name { font-weight: bold; font-size: 1em; margin-bottom: 3px;}
        .battle-unit-count { font-size: 0.95em; color: var(--accent-color); margin-bottom: 5px;}
        .battle-unit-hp-bar { width: 100%; height: 12px; background-color: var(--error-color); border-radius: 6px; margin-top: 5px; overflow: hidden; border: 1px solid var(--border-color); }
        .battle-unit-hp { height: 100%; background-color: var(--success-color); width: 100%; transition: width 0.3s ease-out; }
        .battle-unit-stats-line { font-size: 0.85em; color: #bdc3c7; margin-top: 3px;}
        .battle-unit-stack.anim-melee-attack { animation: melee-attack-anim 0.7s ease-in-out; }
        @keyframes melee-attack-anim {
            0% { transform: translateX(0) scale(1.06); }
            25% { transform: translateX(30px) scale(1.1); }
            50% { transform: translateX(60px) scale(1.15); z-index: 10; }
            75% { transform: translateX(30px) scale(1.1); }
            100% { transform: translateX(0) scale(1.06); z-index: 5; }
        }
        .battle-unit-stack.anim-melee-attack-enemy { animation: melee-attack-anim-enemy 0.7s ease-in-out; }
        @keyframes melee-attack-anim-enemy {
            0% { transform: translateX(0) scale(1); }
            25% { transform: translateX(-30px) scale(1.05); }
            50% { transform: translateX(-60px) scale(1.1); z-index: 10; }
            75% { transform: translateX(-30px) scale(1.05); }
            100% { transform: translateX(0) scale(1); z-index: auto; }
        }
        .projectile {
            position: absolute; font-size: 1.8em; z-index: 20; pointer-events: none; color: var(--accent-color);
            transition: transform 0.4s cubic-bezier(0.5, -0.3, 0.8, 1.2), opacity 0.4s linear;
            text-shadow: 0 0 6px black; opacity: 1;
        }
        .projectile.hit { opacity: 0; }

        #battle-controls-area { display: flex; justify-content: space-between; align-items: flex-start; gap: 20px;}
        #battle-actions { display: flex; flex-direction: column; gap: 10px; margin-bottom: 10px; width: 25%; }
        #battle-age-powers-container { width: 45%; display: flex; flex-wrap: wrap; gap: 10px; justify-content: flex-start; }
        #battle-age-powers-container .game-button { padding: 10px 14px; font-size: 0.9em; flex-grow: 0; min-width: 140px; }
        #battle-turn-controls { width: 25%; display:flex; flex-direction: column; align-items: flex-end; gap: 10px;}
        #battle-turn-controls .game-button {width: auto; min-width: 150px; background-color: var(--success-color); }
        #battle-turn-controls .game-button:hover:not(:disabled) { background-color: #27ae60; }

        #battle-log-container-modal { height: 150px; overflow-y: auto; background-color: rgba(0,0,0,0.35); padding: 12px; border-radius: 6px; font-size: 0.9em; margin-top:15px; border: 1px solid var(--border-color);}
        .battle-log-entry { animation: fadeIn 0.3s; }
        .damage-popup, .heal-popup, .effect-popup {
            position: absolute; font-size: 1.9em; font-weight: bold; animation: floatUpAndFade 1.3s forwards;
            pointer-events: none; text-shadow: 2px 2px 3px black; z-index: 30;
        }
        .damage-popup { color: var(--error-color); } .heal-popup { color: var(--success-color); }
        .effect-popup { color: var(--info-color); }
        @keyframes floatUpAndFade { 0% { opacity: 1; transform: translateY(0) scale(0.9); } 20% { transform: translateY(-15px) scale(1.15); } 100% { opacity: 0; transform: translateY(-70px) scale(0.7); } }
    
        #city-management-section { margin-top: 15px; }
        .map-controls { display:flex; gap:10px; margin-bottom: 10px; }
        .map-controls .game-button { flex-grow: 1;}
        #world-map-outpost-interaction-modal .modal-content {width: 450px;}
        #deployed-armies-section .section-title {margin-bottom: 5px;}
    </style>
</head>
<body>
    <div id="game-container">
        <div id="game-canvas-container">
            <canvas id="game-canvas"></canvas>
            <div id="projectile-container"></div>
            <div id="messages-container"></div>
            <div id="notification"><span id="notification-message"></span></div>
            <div class="era-label" id="era-label-display">Prehistoric Age</div>
            <button id="back-to-base-button">Return to Base</button>
            <div id="minimap-container"><canvas id="minimap-canvas"></canvas></div>
            <div id="achievement-notification-popup"><strong>Achievement!</strong> <div id="achievement-name-popup"></div></div>
        </div>
        <div id="sidebar">
            <div class="sidebar-section"><div class="section-title">Resources</div><div id="resource-displays"></div></div>
            <div id="raid-alert-section" class="sidebar-section" style="display:none;"><div class="section-title" style="color: var(--error-color);">‚ö†Ô∏è Active Raids!</div><div id="active-raids-list"></div></div>
            
            <div class="tab-navigation">
                <button class="tab-button active" data-tab="buildings">City & Buildings</button>
                <button class="tab-button" data-tab="units">Units & Battle</button>
                <button class="tab-button" data-tab="research">Research</button>
            </div>

            <div class="tab-content active" id="buildings-tab-content">
                <div class="sidebar-section">
                    <div class="section-title">Construct Buildings</div>
                    <div id="buildings-container"></div>
                     <div id="construction-queue-display" style="margin-top:15px;"><div class="section-title">Construction Queue (<span id="construction-queue-count">0</span>)</div><div id="construction-queue-list"></div></div>
                </div>
                <div class="sidebar-section" id="city-management-section">
                    <div class="section-title">City Management</div>
                    <div class="map-controls">
                        <button class="game-button" id="expand-land-north-button">Expand North (<span id="expand-cost-north">0</span> G)</button>
                        <button class="game-button" id="expand-land-south-button">Expand South (<span id="expand-cost-south">0</span> G)</button>
                    </div>
                     <div class="map-controls">
                        <button class="game-button" id="expand-land-west-button">Expand West (<span id="expand-cost-west">0</span> G)</button>
                        <button class="game-button" id="expand-land-east-button">Expand East (<span id="expand-cost-east">0</span> G)</button>
                    </div>
                    <button class="game-button" id="cancel-placement-button" style="display:none; background-color: var(--error-color);">Cancel Placement Mode</button>
                </div>
            </div>

            <div class="tab-content" id="units-tab-content">
                <div class="sidebar-section"><div class="section-title">Train Units</div><div id="units-container"></div>
                    <div id="training-queue-display" style="margin-top:15px;"><div class="section-title">Training Queue (<span id="training-queue-count">0</span>)</div><div id="training-queue-list"></div></div>
                    <div id="current-units-display" style="margin-top:15px;"><div class="section-title">Current Army Stacks</div><div id="current-units-list"></div></div>
                    <div id="deployed-armies-section" style="margin-top:15px;"><div class="section-title">Deployed Armies (<span id="deployed-armies-count">0</span>)</div><div id="deployed-armies-list"></div></div>
                    <div class="resource-display" style="margin-top:10px;"><span class="resource-name">Total Army Strength:</span><span class="resource-value" id="army-strength-display">0</span></div>
                </div>
                <div class="sidebar-section"><div class="section-title">Engage in Battle</div><button class="game-button" id="battle-button">Find Random Enemy Outpost</button><div id="enemy-selection-container" style="display: none; margin-top: 10px;"><div id="enemy-selection-list"></div></div></div>
            </div>
            <div class="tab-content" id="research-tab-content">
                <div class="sidebar-section"><div class="section-title">Current Research</div><div id="current-research-display">None</div><div class="progress-container"><div class="progress-bar" id="research-progress-bar"></div></div></div>
                <div class="sidebar-section"><div class="section-title">Available Technologies</div><div id="tech-container"></div></div>
                <div class="sidebar-section"><div class="section-title">Age Advancement</div><button class="game-button" id="advance-age-button" disabled><span>Advance to Next Age</span><span id="advance-age-cost-display">1000</span></button><div class="progress-container"><div class="progress-bar" id="age-progress-bar"></div></div><div id="researched-techs-display" style="margin-top:15px;"><div class="section-title">Researched Techs</div><div id="researched-techs-list" style="font-size: 0.85em; max-height: 100px; overflow-y: auto;"></div></div></div>
            </div>
            <div class="sidebar-section" style="margin-top: auto;"><div class="section-title">Game Controls</div><button class="game-button" id="save-button">Save</button><button class="game-button" id="load-button">Load</button><button class="game-button" id="tutorial-button">Tutorial</button><button class="game-button" id="achievements-button">Achievements</button></div>
        </div>
    </div>

    <div class="modal-overlay" id="tutorial-overlay"><div class="modal-content"><button class="modal-close-button" id="tutorial-force-close-button">&times;</button><h2 id="tutorial-title">Welcome!</h2><div id="tutorial-body-content"></div><div class="modal-navigation"><button class="game-button" id="tutorial-prev-button" disabled>Previous</button><button class="game-button" id="tutorial-next-button">Next</button><button class="game-button" id="tutorial-close-button" style="display: none;">Start Game</button></div></div></div>
    <div class="modal-overlay" id="upgrade-panel-overlay"><div class="modal-content"><button class="modal-close-button" id="upgrade-panel-close-button">&times;</button><h2>Upgrade Building</h2><div id="upgrades-container"></div></div></div>
    <div class="modal-overlay" id="generic-overlay"><div class="modal-content" id="generic-overlay-content"><button class="modal-close-button" id="generic-overlay-close-button">&times;</button></div></div>

    <div class="modal-overlay" id="battle-modal-overlay">
        <div class="modal-content">
            <button class="modal-close-button" id="battle-modal-close-button" style="display:none;">&times;</button>
            <h2 id="battle-title-text">Battle!</h2>
            <div id="battle-area">
                <div id="player-battle-party" class="battle-party"></div>
                <div id="enemy-battle-party" class="battle-party"></div>
            </div>
            <div id="battle-controls-area">
                <div id="battle-actions">
                    <button class="game-button" id="battle-action-attack" disabled style="display: none;">Attack</button>
                    <button class="game-button" id="battle-action-defend" disabled>Defend</button>
                </div>
                <div id="battle-age-powers-container">
                </div>
                 <div id="battle-turn-controls">
                    <button class="game-button" id="battle-end-turn-button" disabled>End Turn</button>
                    <button class="game-button" id="battle-leave-button" style="display:none; margin-top: 15px; background-color: var(--error-color);">Concede Battle</button>
                 </div>
            </div>
            <div class="section-title" style="margin-top:10px;">Battle Log</div>
            <div id="battle-log-container-modal" class="log-container"></div>
        </div>
    </div>

    <div class="modal-overlay" id="world-map-outpost-interaction-modal">
        <div class="modal-content">
            <button class="modal-close-button" id="world-map-outpost-modal-close-button">&times;</button>
            <h2 id="world-map-outpost-modal-title">Outpost Interaction</h2>
            <div id="world-map-outpost-modal-body"></div>
            <div id="world-map-outpost-modal-actions" style="margin-top: 20px; display: flex; gap: 10px;"></div>
        </div>
    </div>

    <div class="tooltip" id="tooltip-element"></div>

    <script>
    'use strict';
    const AGES = [
        {name: "Prehistoric Age", techCost: 0, enemyStrengthModifier: 1.0, raidChanceBase: 0.01, raidStrengthMod: 0.8, battleBg: "linear-gradient(to bottom, #78A451, #4F7731)", specialPower: null},
        {name: "Ancient Age", techCost: 200, enemyStrengthModifier: 1.2, raidChanceBase: 0.015, raidStrengthMod: 1.0, battleBg: "linear-gradient(to bottom, #D4AC6E, #A07D4E)", specialPower: {id:"hail_of_arrows", name:"Hail of Arrows", icon:"üéØ", description:"Lightly damages all enemy stacks.", costType:"gold", cost:50, cooldownTurns:3, effect:"aoeDamage", damageBase:15, aoeDamagePercent:1.0, targetType:"all_enemies"}},
        {name: "Medieval Age", techCost: 1000, enemyStrengthModifier: 1.5, raidChanceBase: 0.02, raidStrengthMod: 1.3, battleBg: "linear-gradient(to bottom, #6A8A65, #4C6A48)", specialPower: {id:"rally_troops", name:"Rally Troops", icon:"üö©", description:"Temporarily boosts attack of one player stack.", costType:"tech", cost:25, cooldownTurns:4, effect:"buff_attack_once", buffAmount: 1.2, buffDuration: 1, targetType:"player_stack_select"}},
        {name: "Renaissance Age", techCost: 5000, enemyStrengthModifier: 2.0, raidChanceBase: 0.025, raidStrengthMod: 1.8, battleBg: "linear-gradient(to bottom, #B0A090, #8C7C6C)", specialPower: {id:"cannon_barrage", name:"Cannon Barrage", icon:"üí£", description:"Deals moderate damage to one enemy stack and splashes to others.", costType:"gold", cost:200, cooldownTurns:5, effect:"directDamageSplash", damageBase:100, aoeDamagePercent:0.3, targetType:"enemy_stack_select"}},
        {name: "Industrial Age", techCost: 20000, enemyStrengthModifier: 3.0, raidChanceBase: 0.03, raidStrengthMod: 2.5, battleBg: "linear-gradient(to bottom, #777C80, #54585C)", specialPower: {id:"trench_warfare", name:"Entrench", icon:"‚õèÔ∏è", description:"Greatly boosts defense of all player stacks for 1 turn.", costType:"tech", cost:100, cooldownTurns:5, effect:"buff_defense_all", buffAmount:1.5, buffDuration:1, targetType:"all_player"}},
        {name: "Modern Age", techCost: 100000, enemyStrengthModifier: 5.0, raidChanceBase: 0.035, raidStrengthMod: 4.0, battleBg: "linear-gradient(to bottom, #9DB0BF, #748DA0)", specialPower: {id:"airstrike", name:"Airstrike", icon:"‚úàÔ∏è", description:"Deals heavy damage to all enemy stacks.", costType:"gold", cost:1000, cooldownTurns:8, effect:"aoeDamage", damageBase:200, aoeDamagePercent:1.0, targetType:"all_enemies"}},
        {name: "Future Age", techCost: 500000, enemyStrengthModifier: 8.0, raidChanceBase: 0.04, raidStrengthMod: 6.0, battleBg: "linear-gradient(to bottom, #4A6B8A, #2C4A6A, #0D2A49)", specialPower: {id:"orbital_laser", name:"Orbital Laser", icon:"üõ∞Ô∏è", description:"Massive damage to a single enemy stack.", costType:"tech", cost:500, cooldownTurns:10, effect:"directDamage", damageBase:1000, targetType:"enemy_stack_select"}}
    ];
    const BUILDINGS = {
        hut: { id: "hut", name: "Hut", description: "Pop. capacity.", baseCost: 20, costMultiplier: 1.18, effects: [{ target: "maxPopulation", value: 2, operation: "add" }], minAge: 0, maxAge: 1, icon: "üè†", upgradesTo: "house", sizeX:1, sizeY:1, buildTime: 5, color:"#8b4513" },
        house: { id: "house", name: "House", description: "More pop. capacity.", baseCost: 100, costMultiplier: 1.25, effects: [{ target: "maxPopulation", value: 5, operation: "add" }], minAge: 1, maxAge: 3, icon: "üèòÔ∏è", upgradesTo: "apartment", sizeX:2, sizeY:1, buildTime: 10, color:"#a0522d" },
        apartment: { id: "apartment", name: "Apartment", description: "Large pop. capacity.", baseCost: 500, costMultiplier: 1.3, effects: [{ target: "maxPopulation", value: 15, operation: "add" }], minAge: 3, maxAge: 5, icon: "üè¢", upgradesTo: "arcology", sizeX:2, sizeY:2, buildTime: 20, color:"#696969" },
        arcology: { id: "arcology", name: "Arcology", description: "Massive pop. capacity.", baseCost: 5000, costMultiplier: 1.4, effects: [{ target: "maxPopulation", value: 50, operation: "add" }], minAge: 5, maxAge: 7, icon: "üèôÔ∏è", upgradesTo: null, sizeX:3, sizeY:3, buildTime: 40, color:"#2f4f4f" },
        foodGathering: { id: "foodGathering", name: "Foraging Post", description: "Basic income.", baseCost: 15, costMultiplier: 1.18, effects: [{ target: "baseIncome", value: 1.2, operation: "add" }], minAge: 0, maxAge: 1, icon: "üçá", upgradesTo: "farm", sizeX:1, sizeY:1, buildTime: 4, color:"#228b22" },
        farm: { id: "farm", name: "Farm", description: "Good income.", baseCost: 60, costMultiplier: 1.25, effects: [{ target: "baseIncome", value: 3.8, operation: "add" }], minAge: 1, maxAge: 3, icon: "üåæ", upgradesTo: "factory", sizeX:2, sizeY:2, buildTime: 12, color:"#556b2f" },
        factory: { id: "factory", name: "Factory", description: "Strong income.", baseCost: 350, costMultiplier: 1.3, effects: [{ target: "baseIncome", value: 11, operation: "add" }], minAge: 3, maxAge: 5, icon: "üè≠", upgradesTo: "robotFactory", sizeX:3, sizeY:2, buildTime: 25, color:"#808080" },
        robotFactory: { id: "robotFactory", name: "Automated Facility", description: "Excellent income.", baseCost: 2500, costMultiplier: 1.4, effects: [{ target: "baseIncome", value: 33, operation: "add" }], minAge: 5, maxAge: 7, icon: "ü§ñüè≠", upgradesTo: null, sizeX:3, sizeY:3, buildTime: 50, color:"#778899" },
        studyCircle: { id: "studyCircle", name: "Study Circle", description: "Basic research.", baseCost: 30, costMultiplier: 1.2, effects: [{ target: "baseTechRate", value: 0.25, operation: "add" }], minAge: 0, maxAge: 2, icon: "üìö", upgradesTo: "library", sizeX:1, sizeY:1, buildTime: 6, color:"#4169e1" },
        library: { id: "library", name: "Library", description: "Collect knowledge.", baseCost: 150, costMultiplier: 1.28, effects: [{ target: "baseTechRate", value: 0.7, operation: "add" }], minAge: 2, maxAge: 4, icon: "üìñ", upgradesTo: "university", sizeX:2, sizeY:1, buildTime: 15, color:"#4682b4" },
        university: { id: "university", name: "University", description: "Advanced research.", baseCost: 800, costMultiplier: 1.35, effects: [{ target: "baseTechRate", value: 2.0, operation: "add" }], minAge: 4, maxAge: 6, icon: "üéì", upgradesTo: "researchLab", sizeX:3, sizeY:2, buildTime: 30, color:"#000080" },
        researchLab: { id: "researchLab", name: "Research Lab", description: "Cutting-edge science.", baseCost: 4000, costMultiplier: 1.4, effects: [{ target: "baseTechRate", value: 5.5, operation: "add" }], minAge: 6, maxAge: 7, icon: "üß™", upgradesTo: null, sizeX:2, sizeY:2, buildTime: 60, color:"#191970" },
        woodenWall: { id: "woodenWall", name: "Wooden Palisade", description: "Basic defense.", baseCost: 25, costMultiplier: 1.3, effects: [{ target: "baseDefense", value: 10, operation: "add" }], minAge: 0, maxAge: 2, icon: "ü™µ", upgradesTo: "stoneWall", sizeX:1, sizeY:1, buildTime: 3, color:"#d2b48c" },
        stoneWall: { id: "stoneWall", name: "Stone Wall", description: "Improved defense.", baseCost: 100, costMultiplier: 1.4, effects: [{ target: "baseDefense", value: 25, operation: "add" }], minAge: 2, maxAge: 4, icon: "üß±", upgradesTo: "concrete", sizeX:1, sizeY:1, buildTime: 8, color:"#708090" },
        concrete: { id: "concrete", name: "Concrete Bunker", description: "Modern defense.", baseCost: 500, costMultiplier: 1.5, effects: [{ target: "baseDefense", value: 60, operation: "add" }], minAge: 4, maxAge: 6, icon: "üèõÔ∏è", upgradesTo: "shieldGen", sizeX:2, sizeY:2, buildTime: 18, color:"#a9a9a9" },
        shieldGen: { id: "shieldGen", name: "Shield Generator", description: "Energy shield.", baseCost: 2500, costMultiplier: 1.6, effects: [{ target: "baseDefense", value: 150, operation: "add" }], minAge: 6, maxAge: 7, icon: "üõ°Ô∏è‚ú®", upgradesTo: null, sizeX:2, sizeY:2, buildTime: 35, color:"#00ced1" }
    };
    const UNITS = {
        clubber: { id: "clubber", name: "Clubber", description: "Basic melee", cost: 10, upkeep: 0.3, maxHp: 30, baseAttack: 6, baseDefense: 2, baseSpeed: 3, population: 1, minAge: 0, maxAge: 1, icon: "ü™®", trainTime: 4, isRanged: false },
        spearman: { id: "spearman", name: "Spearman", description: "Decent melee", cost: 25, upkeep: 0.6, maxHp: 45, baseAttack: 9, baseDefense: 4, baseSpeed: 3, population: 1, minAge: 1, maxAge: 2, icon: "üî±", trainTime: 7, isRanged: false },
        archer: { id: "archer", name: "Archer", description: "Ranged support", cost: 35, upkeep: 0.8, maxHp: 35, baseAttack: 12, baseDefense: 2, baseSpeed: 4, population: 1, minAge: 1, maxAge: 3, icon: "üèπ", trainTime: 9, isRanged: true },
        knight: { id: "knight", name: "Knight", description: "Heavy cavalry", cost: 90, upkeep: 2.5, maxHp: 120, baseAttack: 18, baseDefense: 12, baseSpeed: 5, population: 2, minAge: 2, maxAge: 4, icon: "üêé", trainTime: 18, isRanged: false },
        catapult: { id: "catapult", name: "Catapult", description: "Siege AoE", cost: 130, upkeep: 4.0, maxHp: 70, baseAttack: 25, baseDefense: 5, baseSpeed: 1, population: 3, minAge: 2, maxAge: 4, icon: "‚ö™", trainTime: 28, aoeType: "splash_all_others", aoeDamagePercent: 0.25, isRanged: true },
        musketeer: { id: "musketeer", name: "Musketeer", description: "Gunpowder unit", cost: 180, upkeep: 5.0, maxHp: 80, baseAttack: 35, baseDefense: 18, baseSpeed: 3, population: 2, minAge: 3, maxAge: 5, icon: "üî´", trainTime: 22, isRanged: true },
        cannon: { id: "cannon", name: "Cannon", description: "Heavy AoE", cost: 280, upkeep: 7.5, maxHp: 110, baseAttack: 40, baseDefense: 12, baseSpeed: 1, population: 4, minAge: 3, maxAge: 5, icon: "üí£", trainTime: 35, aoeType: "splash_all_others", aoeDamagePercent: 0.33, isRanged: true },
        rifleman: { id: "rifleman", name: "Rifleman", description: "Modern infantry", cost: 350, upkeep: 10.0, maxHp: 140, baseAttack: 60, baseDefense: 30, baseSpeed: 4, population: 2, minAge: 4, maxAge: 6, icon: "üî™", trainTime: 30, isRanged: true },
        tank: { id: "tank", name: "Tank", description: "Armored AoE", cost: 700, upkeep: 20.0, maxHp: 350, baseAttack: 75, baseDefense: 70, baseSpeed: 3, population: 5, minAge: 4, maxAge: 6, icon: "üöú", trainTime: 50, aoeType: "splash_all_others", aoeDamagePercent: 0.3, isRanged: true },
        commando: { id: "commando", name: "Commando", description: "Elite forces", cost: 900, upkeep: 25.0, maxHp: 200, baseAttack: 110, baseDefense: 60, baseSpeed: 6, population: 3, minAge: 5, maxAge: 7, icon: "ü™ñ", trainTime: 45, isRanged: true },
        helicopter: { id: "helicopter", name: "Attack Heli", description: "Air assault AoE", cost: 1800, upkeep: 50.0, maxHp: 280, baseAttack: 140, baseDefense: 90, baseSpeed: 7, population: 6, minAge: 5, maxAge: 7, icon: "üöÅ", trainTime: 70, aoeType: "splash_all_others", aoeDamagePercent: 0.2, isRanged: true },
        mech: { id: "mech", name: "Battle Mech", description: "War machine AoE", cost: 4500, upkeep: 120.0, maxHp: 550, baseAttack: 250, baseDefense: 170, baseSpeed: 3, population: 8, minAge: 6, maxAge: 7, icon: "ü§ñüí•", trainTime: 100, aoeType: "splash_all_others", aoeDamagePercent: 0.35, isRanged: true },
        drone: { id: "drone", name: "Combat Drone", description: "Autonomous unit", cost: 2700, upkeep: 75.0, maxHp: 220, baseAttack: 200, baseDefense: 110, baseSpeed: 8, population: 4, minAge: 6, maxAge: 7, icon: "üõ∏", trainTime: 80, isRanged: true }
    };
    const TECHNOLOGIES = {
        fire: { id: "fire", name: "Fire", description: "Control fire.", cost: 25, effects: [{ target: "incomeMultiplier", value: 1.1, operation: "multiply" }], researchTime: 30, minAge: 0, icon: "üî•", prereqs: [] },
        stoneTools: { id: "stoneTools", name: "Stone Tools", description: "Basic tools.", cost: 40, effects: [{ target: "globalAttackBoost", value: 1, operation: "add" }], researchTime: 45, minAge: 0, icon: "ü™ì", prereqs: [] },
        writing: { id: "writing", name: "Writing", description: "Record knowledge.", cost: 100, effects: [{ target: "techRateMultiplier", value: 1.3, operation: "multiply" }], researchTime: 60, minAge: 1, icon: "üìù", prereqs: [] },
        agriculture: { id: "agriculture", name: "Agriculture", description: "Cultivate crops.", cost: 120, effects: [{ target: "incomeMultiplier", value: 1.2, operation: "multiply" }], researchTime: 90, minAge: 1, icon: "üå±", prereqs: [] },
        metalWorking: { id: "metalWorking", name: "Metal Working", description: "Forge metals.", cost: 150, effects: [{ target: "globalDefenseBoost", value: 2, operation: "add" }, { target: "defenseMultiplier", value: 1.05, operation: "multiply" }], researchTime: 120, minAge: 1, icon: "‚öíÔ∏è", prereqs: ["stoneTools"] },
        mathematics: { id: "mathematics", name: "Mathematics", description: "Develop math.", cost: 300, effects: [{ target: "techRateMultiplier", value: 1.3, operation: "multiply" }], researchTime: 150, minAge: 2, icon: "‚ûó", prereqs: ["writing"] },
        feudalism: { id: "feudalism", name: "Feudalism", description: "Organize society.", cost: 350, effects: [{ target: "maxPopulation", value: 10, operation: "add" }], researchTime: 180, minAge: 2, icon: "üëë", prereqs: [] },
        steelMaking: { id: "steelMaking", name: "Steel Making", description: "Stronger metal.", cost: 400, effects: [{ target: "globalDefenseBoost", value: 3, operation: "add" }, { target: "defenseMultiplier", value: 1.1, operation: "multiply" }], researchTime: 210, minAge: 2, icon: "üó°Ô∏è", prereqs: ["metalWorking"] },
        printing: { id: "printing", name: "Printing Press", description: "Spread knowledge.", cost: 600, effects: [{ target: "techRateMultiplier", value: 1.5, operation: "multiply" }], researchTime: 240, minAge: 3, icon: "üì∞", prereqs: ["writing"] },
        gunpowder: { id: "gunpowder", name: "Gunpowder", description: "Explosive powder.", cost: 700, effects: [{ target: "globalAttackBoost", value: 5, operation: "add" }], researchTime: 270, minAge: 3, icon: "üí•", prereqs: [] },
        banking: { id: "banking", name: "Banking", description: "Financial systems.", cost: 800, effects: [{ target: "incomeMultiplier", value: 1.25, operation: "multiply" }], researchTime: 300, minAge: 3, icon: "üí∞", prereqs: ["mathematics"] },
        steamPower: { id: "steamPower", name: "Steam Power", description: "Harness steam.", cost: 1500, effects: [{ target: "incomeMultiplier", value: 1.3, operation: "multiply" }], researchTime: 360, minAge: 4, icon: "‚öôÔ∏è", prereqs: [] },
        massProduction: { id: "massProduction", name: "Mass Production", description: "Assembly lines.", cost: 2000, effects: [{ target: "unitCostMultiplier", value: 0.95, operation: "multiply" }, {target: "unitTrainTimeMultiplier", value: 0.85, operation: "multiply"}], researchTime: 420, minAge: 4, icon: "üè≠", prereqs: ["steamPower"] },
        medicine: { id: "medicine", name: "Medicine", description: "Healthcare.", cost: 2500, effects: [{ target: "maxPopulation", value: 20, operation: "add" }], researchTime: 480, minAge: 4, icon: "üíä", prereqs: [] },
        electronics: { id: "electronics", name: "Electronics", description: "Electronic devices.", cost: 5000, effects: [{ target: "techRateMultiplier", value: 1.7, operation: "multiply" }], researchTime: 600, minAge: 5, icon: "üí°", prereqs: [] },
        nuclearPower: { id: "nuclearPower", name: "Nuclear Power", description: "Atomic energy.", cost: 8000, effects: [{ target: "incomeMultiplier", value: 1.5, operation: "multiply" }], researchTime: 720, minAge: 5, icon: "‚ò¢Ô∏è", prereqs: [] },
        advancedMaterials: { id: "advancedMaterials", name: "Advanced Materials", description: "New materials.", cost: 10000, effects: [{ target: "defenseMultiplier", value: 1.2, operation: "multiply" }, { target: "globalDefenseBoost", value: 8, operation: "add" }], researchTime: 840, minAge: 5, icon: "üî¨", prereqs: ["electronics"] },
        artificialIntelligence: { id: "artificialIntelligence", name: "AI", description: "Thinking machines.", cost: 20000, effects: [{ target: "techRateMultiplier", value: 2.0, operation: "multiply" }, {target: "unitTrainTimeMultiplier", value: 0.75, operation: "multiply"}], researchTime: 1000, minAge: 6, icon: "üß†", prereqs: ["electronics"] },
        quantumComputing: { id: "quantumComputing", name: "Quantum Computing", description: "Quantum computers.", cost: 30000, effects: [{ target: "techRateMultiplier", value: 2.2, operation: "multiply" }], researchTime: 1200, minAge: 6, icon: "‚öõÔ∏è", prereqs: ["artificialIntelligence"] },
        fusion: { id: "fusion", name: "Fusion Power", description: "Power of stars.", cost: 50000, effects: [{ target: "incomeMultiplier", value: 2.0, operation: "multiply" }], researchTime: 1500, minAge: 6, icon: "‚ú®", prereqs: ["nuclearPower"] },
        nanotech: { id: "nanotech", name: "Nanotechnology", description: "Atomic scale tech.", cost: 40000, effects: [{ target: "defenseMultiplier", value: 1.3, operation: "multiply" }, {target: "globalAttackBoost", value: 15, operation: "add"}], researchTime: 1300, minAge: 6, icon: "üß¨", prereqs: ["advancedMaterials"] }
    };
    const ACHIEVEMENTS_DATA = [
        { id: "firstBuilding", name: "Foundation", description: "Build your first building", condition: (gs) => gs.stats.buildingsConstructed >= 1 },
        { id: "firstUnit", name: "Recruitment", description: "Train your first unit", condition: (gs) => gs.units.length >= 1 || gs.trainingQueue.length > 0 },
        { id: "firstTech", name: "Innovation", description: "Research your first technology", condition: (gs) => gs.stats.techsResearched >= 1 },
        { id: "firstBattle", name: "Baptism by Fire", description: "Win your first battle", condition: (gs) => gs.stats.battlesWon >= 1 },
        { id: "firstRaidDefense", name: "Shields Up!", description: "Successfully defend against a raid", condition: (gs) => gs.stats.raidsDefended >= 1 },
        { id: "ageAncient", name: "Ancient Times", description: "Advance to the Ancient Age", condition: (gs) => gs.age >= 1 },
        { id: "ageMedieval", name: "Medieval Times", description: "Advance to the Medieval Age", condition: (gs) => gs.age >= 2 },
        { id: "ageRenaissance", name: "Renaissance Era", description: "Advance to the Renaissance Age", condition: (gs) => gs.age >= 3 },
        { id: "ageIndustrial", name: "Industrial Power", description: "Advance to the Industrial Age", condition: (gs) => gs.age >= 4 },
        { id: "ageModern", name: "Modern Marvels", description: "Advance to the Modern Age", condition: (gs) => gs.age >= 5 },
        { id: "ageFuture", name: "Into The Future", description: "Advance to the Future Age", condition: (gs) => gs.age >= 6 },
        { id: "richEmpire", name: "Economic Powerhouse", description: "Reach 25,000 gold", condition: (gs) => gs.resources.gold >= 25000 },
        { id: "massiveArmy", name: "Military Might", description: "Have an army strength of 1000", condition: (gs) => calculateArmyStrength() >= 1000 },
        { id: "techGiant", name: "Technological Supremacy", description: "Research 15 technologies", condition: (gs) => gs.stats.techsResearched >= 15 },
        { id: "cityBuilder", name: "Metropolis", description: "Construct 20 buildings", condition: (gs) => gs.buildings.reduce((acc,b) => acc + (b.isConstructed?1:0),0) >= 20 },
        { id: "warMonger", name: "Conqueror", description: "Win 25 battles (outposts or raids)", condition: (gs) => gs.stats.battlesWon >= 25 },
        { id: "landBaron", name: "Land Baron", description: "Expand your territory 5 times", condition: (gs) => gs.stats.mapExpansions >= 5 }
    ];
    const TUTORIAL_STEPS = [
        { title: "Welcome, Ruler!", content: "Your journey to build a timeless empire begins! Place buildings on the map for resources and population. Train units to form armies. Research technologies to unlock new eras and powers. Defend against raiders and conquer rival outposts!" },
        { title: "The City Map", content: "The main view shows your city. Initially, your territory is small. Select buildings from the 'City & Buildings' tab on the right. Then click on an available tile on the map to place it. Buildings take time to construct! Drag the map with your mouse to explore." },
        { title: "Expanding Your Domain", content: "Need more space? In the 'City & Buildings' tab, under 'City Management', you can purchase more land to expand your buildable area. Each expansion costs more gold. Your 'owned' area is visible on the main map and minimap (bottom-right)." },
        { title: "World & Outposts", content: "Beyond your city, the world map holds enemy outposts. As you expand or your armies travel, you might discover them. Closer outposts may reveal their strength, while distant ones are unknown. Click discovered outposts on the map to interact." },
        { title: "Deploying Armies", content: "To attack world map outposts, you must deploy your units. This takes time based on distance. Deployed units are unavailable for city defense or random battles until they return. Manage deployed armies in the 'Units & Battle' tab." },
        { title: "Resources & Upkeep", content: "Gold is key. Income is generated per second, but units have an Upkeep cost, reducing your net income. Manage your Population - you can't train units if you don't have space! Tech Points unlock progress." },
        { title: "Your Army: Units & Training", content: "Units are trained in stacks. Each unit type has stats: HP, Attack, Defense, Speed, and requires Population. Training takes time and Gold, and units are added to a queue. View your army stacks and train new ones in the 'Units & Battle' tab." },
        { title: "Combat: Turn-Based Strategy", content: "Engage enemy outposts (world map or random encounters) or defend against raids in turn-based battles.\n\nYour Turn: Select one of your available unit stacks (that hasn't acted yet this turn). Then, either click an enemy stack to ATTACK it, or press the DEFEND button. After the action, that stack cannot act again this turn. When finished, press 'End Turn'.\n\nSpecial Powers: As you advance through Ages, you unlock powerful abilities usable in battle!" },
        { title: "Advancement: Research & Ages", content: "Use Tech Points to research technologies in the 'Research' tab. These provide powerful bonuses. Accumulate enough Tech Points to advance to the Next Age, unlocking new buildings, units, techs, stronger foes, and potentially a unique Age Power usable in battle! Buildings may upgrade automatically when you age up (if space permits)!" },
        { title: "Danger: Enemy Raids!", content: "Beware! Raiders will periodically attempt to pillage your settlement. A warning will appear on your sidebar, and you'll see raiders appear on your city map! Click the raid alert to intercept and fight them off. If ignored or if you lose, they will damage or destroy your buildings!" },
        { title: "Lost? Go Home!", content: "If you pan too far from your city center on the map, a 'Return to Base' button will appear on the top-left of the map view. Click it to recenter your view." },
        { title: "Forge Your Destiny!", content: "The path is clear. Expand, research, conquer, and defend. May your empire stand the test of time! Good luck." }
    ];
    const DOMElements = {
        gameCanvas: document.getElementById('game-canvas'), gameCanvasContainer: document.getElementById('game-canvas-container'),
        minimapCanvas: document.getElementById('minimap-canvas'), minimapContainer: document.getElementById('minimap-container'),
        backToBaseButton: document.getElementById('back-to-base-button'),
        messagesContainer: document.getElementById('messages-container'),
        notification: document.getElementById('notification'), notificationMessage: document.getElementById('notification-message'),
        eraLabelDisplay: document.getElementById('era-label-display'),
        achievementNotificationPopup: document.getElementById('achievement-notification-popup'),
        achievementNamePopup: document.getElementById('achievement-name-popup'),
        resourceDisplaysContainer: document.getElementById('resource-displays'), armyStrengthDisplay: document.getElementById('army-strength-display'),
        tabButtons: document.querySelectorAll('.tab-button'), tabContents: document.querySelectorAll('.tab-content'),
        buildingsContainer: document.getElementById('buildings-container'), unitsContainer: document.getElementById('units-container'),
        constructionQueueDisplay: document.getElementById('construction-queue-display'), constructionQueueList: document.getElementById('construction-queue-list'), constructionQueueCount: document.getElementById('construction-queue-count'),
        techContainer: document.getElementById('tech-container'), currentUnitsDisplay: document.getElementById('current-units-display'),
        currentUnitsList: document.getElementById('current-units-list'), 
        deployedArmiesSection: document.getElementById('deployed-armies-section'), deployedArmiesList: document.getElementById('deployed-armies-list'), deployedArmiesCount: document.getElementById('deployed-armies-count'),
        trainingQueueDisplay: document.getElementById('training-queue-display'),
        trainingQueueList: document.getElementById('training-queue-list'), trainingQueueCount: document.getElementById('training-queue-count'),
        currentResearchDisplay: document.getElementById('current-research-display'), researchProgressBar: document.getElementById('research-progress-bar'),
        researchedTechsList: document.getElementById('researched-techs-list'),
        advanceAgeButton: document.getElementById('advance-age-button'), advanceAgeCostDisplay: document.getElementById('advance-age-cost-display'),
        ageProgressBar: document.getElementById('age-progress-bar'),
        battleButton: document.getElementById('battle-button'), enemySelectionContainer: document.getElementById('enemy-selection-container'),
        enemySelectionList: document.getElementById('enemy-selection-list'),
        battleModalOverlay: document.getElementById('battle-modal-overlay'), battleModalCloseButton: document.getElementById('battle-modal-close-button'),
        battleTitleText: document.getElementById('battle-title-text'),
        battleArea: document.getElementById('battle-area'), playerBattlePartyContainer: document.getElementById('player-battle-party'),
        enemyBattlePartyContainer: document.getElementById('enemy-battle-party'),
        battleActionAttack: document.getElementById('battle-action-attack'), battleActionDefend: document.getElementById('battle-action-defend'),
        battleEndTurnButton: document.getElementById('battle-end-turn-button'),
        battleAgePowersContainer: document.getElementById('battle-age-powers-container'),
        battleLogContainerModal: document.getElementById('battle-log-container-modal'),
        battleLeaveButton: document.getElementById('battle-leave-button'),
        saveButton: document.getElementById('save-button'), loadButton: document.getElementById('load-button'),
        tutorialButton: document.getElementById('tutorial-button'), achievementsButton: document.getElementById('achievements-button'),
        tutorialOverlay: document.getElementById('tutorial-overlay'), tutorialTitle: document.getElementById('tutorial-title'),
        tutorialBodyContent: document.getElementById('tutorial-body-content'), tutorialPrevButton: document.getElementById('tutorial-prev-button'),
        tutorialNextButton: document.getElementById('tutorial-next-button'), tutorialCloseButton: document.getElementById('tutorial-close-button'),
        tutorialForceCloseButton: document.getElementById('tutorial-force-close-button'),
        upgradePanelOverlay: document.getElementById('upgrade-panel-overlay'), upgradesContainer: document.getElementById('upgrades-container'),
        upgradePanelCloseButton: document.getElementById('upgrade-panel-close-button'),
        genericOverlay: document.getElementById('generic-overlay'), genericOverlayContent: document.getElementById('generic-overlay-content'),
        genericOverlayCloseButton: document.getElementById('generic-overlay-close-button'),
        tooltipElement: document.getElementById('tooltip-element'),
        raidAlertSection: document.getElementById('raid-alert-section'), activeRaidsList: document.getElementById('active-raids-list'),
        projectileContainer: document.getElementById('projectile-container'),
        cancelPlacementButton: document.getElementById('cancel-placement-button'),
        expandLandNorthButton: document.getElementById('expand-land-north-button'), expandLandSouthButton: document.getElementById('expand-land-south-button'),
        expandLandWestButton: document.getElementById('expand-land-west-button'), expandLandEastButton: document.getElementById('expand-land-east-button'),
        expandCostNorth: document.getElementById('expand-cost-north'), expandCostSouth: document.getElementById('expand-cost-south'),
        expandCostWest: document.getElementById('expand-cost-west'), expandCostEast: document.getElementById('expand-cost-east'),
        worldMapOutpostInteractionModal: document.getElementById('world-map-outpost-interaction-modal'),
        worldMapOutpostModalCloseButton: document.getElementById('world-map-outpost-modal-close-button'),
        worldMapOutpostModalTitle: document.getElementById('world-map-outpost-modal-title'),
        worldMapOutpostModalBody: document.getElementById('world-map-outpost-modal-body'),
        worldMapOutpostModalActions: document.getElementById('world-map-outpost-modal-actions'),
    };

    let ctx; let minimapCtx; let gameState = {}; let nextRaidCheckTime = 0; let gameLoopIntervalId; let achievementCheckIntervalId;
    const RAID_CHECK_INTERVAL = 15000; const RAID_BASE_DURATION_BEFORE_DESTRUCTION = 120;
    const SAVE_GAME_KEY = 'ageOfEmpireTycoonDefinitiveSave_V6_Map_Fix3'; 
    
    const TILE_SIZE = 40;
    const TILE_WIDTH_ISO = TILE_SIZE * 1.732; 
    const TILE_HEIGHT_ISO = TILE_SIZE; 
    const MAX_MAP_GRID_DIM = 50; 

    let camera = { x: 0, y: 0, zoom: 1 };
    let mouseGridPos = { x: -1, y: -1 };
    let currentPlacingBuildingId = null;
    let isPanning = false;
    let panStartX, panStartY;
    let lastClickedWorldOutpost = null;

    const BASE_LOCATION_GRID = {x:0, y:0};
    const MINIMAP_PIXEL_PER_TILE = 2; 
    const BACK_TO_BASE_THRESHOLD = TILE_WIDTH_ISO * 10; 

    function getDefaultGameState() {
        return {
            resources: { gold: 100, population: 0, maxPopulation: 10, technologyPoints: 10, },
            modifiers: { baseIncome: 1.5, incomeMultiplier: 1, baseTechRate: 0.15, techRateMultiplier: 1, baseDefense: 5, defenseMultiplier: 1, globalAttackBoost: 0, globalDefenseBoost: 0, unitCostMultiplier: 1, unitTrainTimeMultiplier: 1,},
            age: 0, 
            buildings: [], 
            constructionQueue: [],
            units: [], trainingQueue: [], technologies: [],
            currentResearch: { id: null, progress: 0, timeToComplete: 0 },
            map: {
                ownedTilesX: [-5, 5], 
                ownedTilesY: [-5, 5], 
                nextExpansionCost: 100,
                discoveredTiles: {} 
            },
            worldMap: {
                outposts: [],
                deployedArmies: []
            },
            placement: {
                isPlacing: false,
                buildingId: null,
                validPlacement: false,
            },
            mapEntities: {
                raiders: [] 
            },
            battle: {
                isActive: false, playerParty: [], enemyParty: [], turnOrder: [], currentTurn: 'player',
                actedStackIdsThisTurn: [], selectedPlayerStackId: null, selectedAction: null,
                selectedTargetStackBattleId: null, log: [], rewards: null, battleType: null, agePowerCooldowns: {},
                isAwaitingTargetSelection: false, targetingSource: null,
                playerBuffs: {}, enemyBuffs: {}, currentDeployedArmyId: null,
             },
            stats: { timePlayed: 0, battlesWon: 0, battlesLost: 0, enemiesDefeated: 0, unitsTrained: 0, buildingsConstructed: 0, techsResearched: 0, raidsSpawned: 0, raidsDefended: 0, buildingsLostToRaids: 0, mapExpansions: 0,},
            activeRaids: [], achievements: [], tutorial: { step: 0, complete: false },
            gameVersion: "6.0.3"
        };
    }
    
    function isTileOwned(gridX, gridY) {
        return gridX >= gameState.map.ownedTilesX[0] && gridX <= gameState.map.ownedTilesX[1] &&
               gridY >= gameState.map.ownedTilesY[0] && gridY <= gameState.map.ownedTilesY[1];
    }
    function markTileDiscovered(gridX, gridY) {
        gameState.map.discoveredTiles[`${gridX},${gridY}`] = true;
    }
    function isTileDiscovered(gridX, gridY) {
        return !!gameState.map.discoveredTiles[`${gridX},${gridY}`];
    }

    function discoverArea(centerX, centerY, radius) {
        for (let dy = -radius; dy <= radius; dy++) {
            for (let dx = -radius; dx <= radius; dx++) {
                if (dx*dx + dy*dy <= radius*radius) {
                    markTileDiscovered(centerX + dx, centerY + dy);
                }
            }
        }
    }


    function canPlaceBuilding(buildingDef, startGridX, startGridY) {
        if (!buildingDef) return false;
        for (let y = 0; y < buildingDef.sizeY; y++) {
            for (let x = 0; x < buildingDef.sizeX; x++) {
                const checkX = startGridX + x;
                const checkY = startGridY + y;
                if (!isTileOwned(checkX, checkY)) return false; 
                if (getBuildingAtGrid(checkX, checkY) !== null) return false; 
            }
        }
        return true;
    }

    function getBuildingAtGrid(gridX, gridY) {
        for (const building of gameState.buildings) {
             if (building.isConstructed || building.isPlaceholder) {
                if (gridX >= building.gridX && gridX < building.gridX + building.sizeX &&
                    gridY >= building.gridY && gridY < building.gridY + building.sizeY) {
                    return building;
                }
            }
        }
        return null;
    }
    
    function expandMap(direction) {
        const cost = gameState.map.nextExpansionCost;
        if (gameState.resources.gold < cost) {
            showNotification("Not enough gold to expand territory!", "error");
            return;
        }
    
        const expansionAmount = 2; 
    
        let expanded = false;
        let newMinX = gameState.map.ownedTilesX[0], newMaxX = gameState.map.ownedTilesX[1];
        let newMinY = gameState.map.ownedTilesY[0], newMaxY = gameState.map.ownedTilesY[1];

        switch (direction) {
            case 'N':
                if (gameState.map.ownedTilesY[0] > -MAX_MAP_GRID_DIM) {
                    newMinY = Math.max(-MAX_MAP_GRID_DIM, gameState.map.ownedTilesY[0] - expansionAmount);
                    expanded = true;
                }
                break;
            case 'S':
                if (gameState.map.ownedTilesY[1] < MAX_MAP_GRID_DIM) {
                    newMaxY = Math.min(MAX_MAP_GRID_DIM, gameState.map.ownedTilesY[1] + expansionAmount);
                    expanded = true;
                }
                break;
            case 'W':
                 if (gameState.map.ownedTilesX[0] > -MAX_MAP_GRID_DIM) {
                    newMinX = Math.max(-MAX_MAP_GRID_DIM, gameState.map.ownedTilesX[0] - expansionAmount);
                    expanded = true;
                }
                break;
            case 'E':
                if (gameState.map.ownedTilesX[1] < MAX_MAP_GRID_DIM) {
                    newMaxX = Math.min(MAX_MAP_GRID_DIM, gameState.map.ownedTilesX[1] + expansionAmount);
                    expanded = true;
                }
                break;
        }
    
        if (expanded) {
            gameState.resources.gold -= cost;
            gameState.map.nextExpansionCost = Math.floor(cost * 1.5);
            gameState.stats.mapExpansions++;

            gameState.map.ownedTilesX = [newMinX, newMaxX];
            gameState.map.ownedTilesY = [newMinY, newMaxY];

            for(let gx = newMinX; gx <= newMaxX; gx++) {
                for(let gy = newMinY; gy <= newMaxY; gy++) {
                    markTileDiscovered(gx, gy);
                }
            }

            showNotification(`Territory expanded ${direction}!`, "success");
            addMessage(`Territory expanded ${direction}. New cost: ${formatNumber(gameState.map.nextExpansionCost)}G`);
            updateExpandLandButtonCosts();
            generateWorldOutpostsIfNeeded();
            renderGameView();
            updateAllUIDisplays();
        } else {
            showNotification("Cannot expand further in that direction.", "info");
        }
    }

    function updateExpandLandButtonCosts() {
        const cost = formatNumber(gameState.map.nextExpansionCost);
        DOMElements.expandCostNorth.textContent = cost;
        DOMElements.expandCostSouth.textContent = cost;
        DOMElements.expandCostWest.textContent = cost;
        DOMElements.expandCostEast.textContent = cost;
        DOMElements.expandLandNorthButton.disabled = gameState.map.ownedTilesY[0] <= -MAX_MAP_GRID_DIM || gameState.resources.gold < gameState.map.nextExpansionCost;
        DOMElements.expandLandSouthButton.disabled = gameState.map.ownedTilesY[1] >= MAX_MAP_GRID_DIM || gameState.resources.gold < gameState.map.nextExpansionCost;
        DOMElements.expandLandWestButton.disabled = gameState.map.ownedTilesX[0] <= -MAX_MAP_GRID_DIM || gameState.resources.gold < gameState.map.nextExpansionCost;
        DOMElements.expandLandEastButton.disabled = gameState.map.ownedTilesX[1] >= MAX_MAP_GRID_DIM || gameState.resources.gold < gameState.map.nextExpansionCost;
    }


    function uniqueId(prefix = '') { return prefix + Date.now().toString(36) + Math.random().toString(36).substring(2, 7); }
    function formatNumber(num, decimals = 0) { if (num === undefined || num === null) return '0'; return Number(num).toFixed(decimals).replace(/\B(?=(\d{3})+(?!\d))/g, ","); }
    function showNotification(message, type = 'info', duration = 3000) { DOMElements.notificationMessage.textContent = message; DOMElements.notification.className = ''; DOMElements.notification.classList.add(type, 'show'); setTimeout(() => { DOMElements.notification.classList.remove('show'); }, duration); }
    function addMessage(text, isImportant = false) { const el = document.createElement('div'); el.classList.add('message'); if (isImportant) el.style.fontWeight = 'bold'; el.textContent = text; DOMElements.messagesContainer.appendChild(el); DOMElements.messagesContainer.scrollTop = DOMElements.messagesContainer.scrollHeight; while (DOMElements.messagesContainer.children.length > 20) DOMElements.messagesContainer.firstChild.remove(); }
    function showModal(modalElement) { modalElement.classList.add('visible'); }
    function hideModal(modalElement) { modalElement.classList.remove('visible'); }
    let tooltipTimeout; function displayTooltip(event) { const target = event.target.closest('[data-tooltip]'); if (!target) return; const tooltipText = target.dataset.tooltip; if (!tooltipText) return; clearTimeout(tooltipTimeout); DOMElements.tooltipElement.innerHTML = tooltipText; DOMElements.tooltipElement.classList.add('visible'); const updatePosition = (e) => { let x = e.clientX + 15; let y = e.clientY + 15; const rect = DOMElements.tooltipElement.getBoundingClientRect(); const vpW = window.innerWidth; const vpH = window.innerHeight; if (x + rect.width > vpW) x = e.clientX - rect.width - 15; if (y + rect.height > vpH) y = e.clientY - rect.height - 15; DOMElements.tooltipElement.style.left = `${x}px`; DOMElements.tooltipElement.style.top = `${y}px`; }; updatePosition(event); document.addEventListener('mousemove', updatePositionTooltipHandler); target.addEventListener('mouseout', hideTooltip, { once: true }); }
    function updatePositionTooltipHandler(e) { if (DOMElements.tooltipElement.classList.contains('visible')) { let x = e.clientX + 15; let y = e.clientY + 15; const rect = DOMElements.tooltipElement.getBoundingClientRect(); const vpW = window.innerWidth; const vpH = window.innerHeight; if (x + rect.width > vpW) x = e.clientX - rect.width - 15; if (y + rect.height > vpH) y = e.clientY - rect.height - 15; DOMElements.tooltipElement.style.left = `${x}px`; DOMElements.tooltipElement.style.top = `${y}px`; } }
    function hideTooltip() { tooltipTimeout = setTimeout(() => { DOMElements.tooltipElement.classList.remove('visible'); document.removeEventListener('mousemove', updatePositionTooltipHandler); }, 100); }
    function getCalculatedIncome() { let totalIncome = gameState.modifiers.baseIncome; let totalUpkeep = 0; gameState.units.forEach(unit => { const unitInfo = UNITS[unit.type]; if (unitInfo) totalUpkeep += unitInfo.upkeep; }); gameState.trainingQueue.forEach(queuedUnit => { const unitInfo = UNITS[queuedUnit.unitType]; if(unitInfo) totalUpkeep += unitInfo.upkeep * 0.25; }); gameState.worldMap.deployedArmies.forEach(army => { army.units.forEach( u => {const unitInfo = UNITS[u.type]; if(unitInfo) totalUpkeep += unitInfo.upkeep;}); }); totalIncome -= totalUpkeep; totalIncome *= gameState.modifiers.incomeMultiplier; return totalIncome; }
    function getCalculatedTechRate() { return gameState.modifiers.baseTechRate * gameState.modifiers.techRateMultiplier; }
    function getCalculatedEmpireDefense() { return Math.floor(gameState.modifiers.baseDefense * gameState.modifiers.defenseMultiplier + gameState.modifiers.globalDefenseBoost); }
    function getUnitEffectiveStats(unitType) { const unitInfo = UNITS[unitType]; if (!unitInfo) return { attack: 0, defense: 0, hp: 0, speed: 0 }; return { attack: unitInfo.baseAttack + gameState.modifiers.globalAttackBoost, defense: unitInfo.baseDefense + gameState.modifiers.globalDefenseBoost, hp: unitInfo.maxHp, speed: unitInfo.baseSpeed };}
    function applyEffects(itemData, isRemoval = false) { if (!itemData.effects) return; itemData.effects.forEach(effect => { let value = effect.value; if (isRemoval) { if (effect.operation === 'add') value = -value; else if (effect.operation === 'multiply' && value !== 0) value = 1 / value; else if (effect.operation === 'multiply' && value === 0) value = 0;} switch (effect.operation) { case 'add': if (gameState.resources.hasOwnProperty(effect.target)) gameState.resources[effect.target] += value; else if (gameState.modifiers.hasOwnProperty(effect.target)) gameState.modifiers[effect.target] += value; break; case 'multiply': if (gameState.modifiers.hasOwnProperty(effect.target)) gameState.modifiers[effect.target] *= value; break; } });}

    function updateResourceDisplays() { const calculatedIncome = getCalculatedIncome(); const incomeClass = calculatedIncome >= 0 ? 'resource-value' : 'resource-value" style="color: var(--error-color);'; const resourcesHtml = `<div class="resource-display"><span>üí∞ Gold:</span><span class="resource-value">${formatNumber(gameState.resources.gold)}</span></div><div class="resource-display"><span>üìà Income:</span><span class="${incomeClass}">${formatNumber(calculatedIncome, 1)}/s</span></div><div class="resource-display"><span>üë• Pop:</span><span class="resource-value">${gameState.resources.population}/${formatNumber(gameState.resources.maxPopulation)}</span></div><div class="resource-display"><span>üß™ Tech Pts:</span><span class="resource-value">${formatNumber(gameState.resources.technologyPoints)}</span></div><div class="resource-display"><span>üî¨ Research:</span><span class="resource-value">+${formatNumber(getCalculatedTechRate(), 1)}/s</span></div><div class="resource-display"><span>üõ°Ô∏è Empire Def:</span><span class="resource-value">${formatNumber(getCalculatedEmpireDefense())}</span></div>`; DOMElements.resourceDisplaysContainer.innerHTML = resourcesHtml; DOMElements.armyStrengthDisplay.textContent = formatNumber(calculateArmyStrength()); DOMElements.eraLabelDisplay.textContent = AGES[gameState.age].name; updateRaidAlertUI(); }
    function updateButtonStates() { document.querySelectorAll('#buildings-container .item-slot').forEach(slot => { const buildingId = slot.dataset.itemId; if (!buildingId) return; const buildingInfo = BUILDINGS[buildingId]; const count = gameState.buildings.filter(b => b.type === buildingId && (b.isConstructed || b.isPlaceholder)).length + gameState.constructionQueue.filter(b => b.type === buildingId).length; const cost = calculateBuildingCost(buildingInfo, count); slot.classList.toggle('disabled', gameState.resources.gold < cost || gameState.constructionQueue.length >= 5); const costEl = slot.querySelector('.item-cost'); if (costEl) costEl.textContent = formatNumber(cost); slot.classList.toggle('placing-active', gameState.placement.isPlacing && gameState.placement.buildingId === buildingId); }); document.querySelectorAll('#units-container .game-button').forEach(button => { const unitId = button.dataset.itemId; if (!unitId) return; const unitInfo = UNITS[unitId]; const cost = Math.floor(unitInfo.cost * gameState.modifiers.unitCostMultiplier); button.disabled = !(gameState.resources.gold >= cost && gameState.resources.population + unitInfo.population <= gameState.resources.maxPopulation && gameState.trainingQueue.length < 5); }); document.querySelectorAll('#tech-container .game-button').forEach(button => { const techId = button.dataset.itemId; if (!techId) return; const techInfo = TECHNOLOGIES[techId]; button.disabled = !!(gameState.currentResearch.id || gameState.resources.gold < techInfo.cost); }); if (gameState.age < AGES.length - 1) { const nextAgeCost = AGES[gameState.age + 1].techCost; const canAdvance = gameState.resources.technologyPoints >= nextAgeCost; DOMElements.advanceAgeButton.disabled = !canAdvance; DOMElements.advanceAgeButton.classList.toggle('pulse', canAdvance); } else { DOMElements.advanceAgeButton.disabled = true; DOMElements.advanceAgeButton.classList.remove('pulse'); } DOMElements.battleButton.disabled = gameState.battle.isActive || countTotalPlayerUnits() === 0; updateExpandLandButtonCosts(); DOMElements.cancelPlacementButton.style.display = gameState.placement.isPlacing ? 'flex' : 'none'; DOMElements.backToBaseButton.style.display = (Math.abs(camera.x) > BACK_TO_BASE_THRESHOLD || Math.abs(camera.y - (-(DOMElements.gameCanvas.height / 3))) > BACK_TO_BASE_THRESHOLD) ? 'block' : 'none'; updateDeployedArmiesUI();}
    function updateAllUIDisplays() { updateResourceDisplays(); updateResearchUI(); updateAgeUI(); updateTrainingQueueUI(); updateConstructionQueueUI(); updateDeployedArmiesUI(); loadAvailableUnits(); updateButtonStates(); }
    function updateResearchUI() { if (gameState.currentResearch.id) { const tech = TECHNOLOGIES[gameState.currentResearch.id]; DOMElements.currentResearchDisplay.textContent = `${tech.icon} ${tech.name}`; const progress = (gameState.currentResearch.progress / gameState.currentResearch.timeToComplete) * 100; DOMElements.researchProgressBar.style.width = `${Math.min(progress, 100)}%`; } else { DOMElements.currentResearchDisplay.textContent = "None"; DOMElements.researchProgressBar.style.width = '0%'; } DOMElements.researchedTechsList.innerHTML = gameState.technologies.map(techId => { const tech = TECHNOLOGIES[techId]; return `<div>${tech.icon} ${tech.name}</div>`; }).join(''); }
    function updateAgeUI() { if (gameState.age < AGES.length - 1) { const nextAgeCost = AGES[gameState.age + 1].techCost; DOMElements.advanceAgeCostDisplay.textContent = formatNumber(nextAgeCost); const progress = (gameState.resources.technologyPoints / nextAgeCost) * 100; DOMElements.ageProgressBar.style.width = `${Math.min(progress, 100)}%`; DOMElements.advanceAgeButton.querySelector('span:first-child').textContent = `Advance to ${AGES[gameState.age + 1].name}`; } else { DOMElements.advanceAgeCostDisplay.textContent = "MAX"; DOMElements.ageProgressBar.style.width = '100%'; DOMElements.advanceAgeButton.querySelector('span:first-child').textContent = "Maximum Age Reached"; DOMElements.advanceAgeButton.disabled = true; } }

    function loadAvailableBuildings() { DOMElements.buildingsContainer.innerHTML = ''; const available = Object.values(BUILDINGS).filter(b => b.minAge <= gameState.age && b.maxAge >= gameState.age); available.forEach(building => { const count = gameState.buildings.filter(b => b.type === building.id && (b.isConstructed || b.isPlaceholder)).length + gameState.constructionQueue.filter(b => b.type === building.id).length; const cost = calculateBuildingCost(building, count); const effectsDesc = building.effects.map(e => `${e.value > 0 ? '+' : ''}${e.value} ${e.target.replace(/([A-Z])/g, ' $1').toLowerCase()}`).join(', '); const el = document.createElement('div'); el.className = 'item-slot'; el.dataset.itemId = building.id; el.dataset.tooltip = `<strong>${building.name}</strong><br>${building.description}<br><em>Effect: ${effectsDesc}</em><br>Size: ${building.sizeX}x${building.sizeY}, Time: ${building.buildTime}s<br>Cost Multiplier: x${building.costMultiplier.toFixed(2)}`; el.innerHTML = `<div class="item-icon">${building.icon}</div><div class="item-details"><div class="item-name">${building.name}</div><div class="item-description">${building.description.substring(0,30)}...</div></div><div class="item-cost">${formatNumber(cost)}</div>`; el.addEventListener('click', () => togglePlacementMode(building.id)); DOMElements.buildingsContainer.appendChild(el); }); updateButtonStates(); }
    function calculateBuildingCost(buildingInfo, count) { return Math.floor(buildingInfo.baseCost * Math.pow(buildingInfo.costMultiplier, count)); }
    
    function togglePlacementMode(buildingId) {
        const buildingInfo = BUILDINGS[buildingId];
        const count = gameState.buildings.filter(b => b.type === buildingId && (b.isConstructed || b.isPlaceholder)).length + gameState.constructionQueue.filter(b => b.type === buildingId).length;
        const cost = calculateBuildingCost(buildingInfo, count);

        if (gameState.placement.isPlacing && gameState.placement.buildingId === buildingId) {
            cancelPlacementMode();
        } else {
             if (gameState.resources.gold < cost) {
                showNotification("Not enough gold!", 'error');
                return;
            }
            if (gameState.constructionQueue.length >= 5) {
                showNotification("Construction queue full (max 5)!", 'error');
                return;
            }
            gameState.placement.isPlacing = true;
            gameState.placement.buildingId = buildingId;
            DOMElements.gameCanvasContainer.style.cursor = 'copy';
            showNotification(`Placing ${buildingInfo.name}. Click on map.`, 'info', 5000);
            updateButtonStates();
        }
    }
    
    function cancelPlacementMode() {
        gameState.placement.isPlacing = false;
        gameState.placement.buildingId = null;
        DOMElements.gameCanvasContainer.style.cursor = 'grab';
        currentPlacingBuildingId = null; 
        updateButtonStates();
        renderGameView(); 
    }

    function attemptPlaceBuilding(gridX, gridY) {
        if (!gameState.placement.isPlacing || !gameState.placement.buildingId) return;
    
        const buildingId = gameState.placement.buildingId;
        const buildingInfo = BUILDINGS[buildingId];
        const buildingCount = gameState.buildings.filter(b => b.type === buildingId && (b.isConstructed || b.isPlaceholder)).length + gameState.constructionQueue.filter(b => b.type === buildingId).length;
        const cost = calculateBuildingCost(buildingInfo, buildingCount);
    
        if (gameState.resources.gold < cost) {
            showNotification("Not enough gold!", 'error');
            cancelPlacementMode();
            return;
        }
        if (gameState.constructionQueue.length >= 5) {
            showNotification("Construction queue full!", 'error');
            cancelPlacementMode();
            return;
        }
    
        if (canPlaceBuilding(buildingInfo, gridX, gridY)) {
            gameState.resources.gold -= cost;
            const newConstruction = {
                id: uniqueId('cons_'),
                type: buildingId,
                gridX: gridX,
                gridY: gridY,
                sizeX: buildingInfo.sizeX,
                sizeY: buildingInfo.sizeY,
                progress: 0,
                totalTime: buildingInfo.buildTime,
                cost: cost,
            };
            gameState.constructionQueue.push(newConstruction);
            
            gameState.buildings.push({ 
                ...newConstruction, 
                isPlaceholder: true,
                isConstructed: false,
            });

            showNotification(`${buildingInfo.name} construction started!`, 'success');
            addMessage(`Started construction: ${buildingInfo.name} at [${gridX},${gridY}].`);
            
            cancelPlacementMode(); 
            loadAvailableBuildings(); 
            updateAllUIDisplays();
            renderGameView();
        } else {
            showNotification("Cannot place building here (obstructed or outside owned area).", 'error');
        }
    }
    
    function processConstructionQueue(deltaTime) {
        if (gameState.constructionQueue.length === 0) return;
    
        const constructingItem = gameState.constructionQueue[0];
        constructingItem.progress += deltaTime;
    
        const placeholderBuilding = gameState.buildings.find(b => b.id === constructingItem.id && b.isPlaceholder);
        if(placeholderBuilding) placeholderBuilding.progress = constructingItem.progress;

        if (constructingItem.progress >= constructingItem.totalTime) {
            const buildingInfo = BUILDINGS[constructingItem.type];
            
            const finalBuildingIndex = gameState.buildings.findIndex(b => b.id === constructingItem.id);
            if (finalBuildingIndex !== -1) {
                 gameState.buildings[finalBuildingIndex] = {
                    id: constructingItem.id,
                    type: constructingItem.type,
                    level: 1,
                    constructedAt: gameState.stats.timePlayed,
                    gridX: constructingItem.gridX,
                    gridY: constructingItem.gridY,
                    sizeX: buildingInfo.sizeX,
                    sizeY: buildingInfo.sizeY,
                    isConstructed: true,
                    isPlaceholder: false,
                    progress: constructingItem.totalTime, 
                    totalTime: constructingItem.totalTime
                };
            }

            applyEffects(buildingInfo, false);
            gameState.stats.buildingsConstructed++;
            showNotification(`${buildingInfo.name} constructed!`, 'success');
            addMessage(`Finished construction: ${buildingInfo.name}.`);
            gameState.constructionQueue.shift();
            
            loadAvailableBuildings();
            updateAllUIDisplays();
            renderGameView();
        }
        updateConstructionQueueUI();
    }

    function updateConstructionQueueUI() {
        DOMElements.constructionQueueCount.textContent = gameState.constructionQueue.length;
        if (gameState.constructionQueue.length > 0) {
            DOMElements.constructionQueueDisplay.style.display = 'block';
            DOMElements.constructionQueueList.innerHTML = gameState.constructionQueue.map((item, index) => {
                const buildingInfo = BUILDINGS[item.type];
                const progressPercent = Math.min(100, (item.progress / item.totalTime) * 100);
                return `<div class="construction-queue-item-info">
                            <span>${index + 1}. ${buildingInfo.icon} ${buildingInfo.name}</span>
                            <span>${formatNumber(item.progress,0)}s / ${item.totalTime}s</span>
                        </div>
                        <div class="progress-container" style="height:5px; margin-bottom:5px;">
                            <div class="progress-bar-small" style="width:${progressPercent}%"></div>
                        </div>`;
            }).join('');
        } else {
            DOMElements.constructionQueueDisplay.style.display = 'none';
            DOMElements.constructionQueueList.innerHTML = "";
        }
    }


    function loadAvailableUnits() { DOMElements.unitsContainer.innerHTML = ''; const availableUnitTypes = Object.values(UNITS).filter(u => u.minAge <= gameState.age && u.maxAge >= gameState.age); availableUnitTypes.forEach(unit => { const cost = Math.floor(unit.cost * gameState.modifiers.unitCostMultiplier); const trainTime = Math.floor(unit.trainTime * gameState.modifiers.unitTrainTimeMultiplier); const el = document.createElement('button'); el.className = 'game-button'; el.dataset.itemId = unit.id; const effectiveStats = getUnitEffectiveStats(unit.id); el.dataset.tooltip = `<strong>${unit.name} (${unit.icon})</strong><br>${unit.description}<br>HP: ${effectiveStats.hp}, Atk: ${effectiveStats.attack}, Def: ${effectiveStats.defense}, Spd: ${effectiveStats.speed}<br>Pop: ${unit.population}, Upkeep: ${unit.upkeep.toFixed(1)}/s<br>Train Time: ${trainTime}s`; el.innerHTML = `<span>${unit.icon} ${unit.name} (Time: ${trainTime}s)</span><span>${formatNumber(cost)}</span>`; el.addEventListener('click', () => addUnitToTrainingQueue(unit.id)); DOMElements.unitsContainer.appendChild(el); }); const unitStacks = {}; gameState.units.forEach(unit => { if (!unitStacks[unit.type]) { unitStacks[unit.type] = { count: 0, unitDef: UNITS[unit.type] };} unitStacks[unit.type].count++; }); DOMElements.currentUnitsList.innerHTML = Object.values(unitStacks).map(stack => { return `<div class="unit-info"><span>${stack.unitDef.icon} ${stack.unitDef.name}</span><span>x${stack.count}</span></div>`; }).join('') || "No units in army."; DOMElements.currentUnitsDisplay.style.display = 'block'; updateButtonStates(); }
    function addUnitToTrainingQueue(unitId) { const unitInfo = UNITS[unitId]; const cost = Math.floor(unitInfo.cost * gameState.modifiers.unitCostMultiplier); const trainTime = Math.floor(unitInfo.trainTime * gameState.modifiers.unitTrainTimeMultiplier); if (gameState.resources.gold < cost) { showNotification("Not enough gold!", 'error'); return; } if (gameState.resources.population + unitInfo.population > gameState.resources.maxPopulation) { showNotification("Not enough pop!", 'error'); return; } if (gameState.trainingQueue.length >= 5) { showNotification("Queue full (max 5)!", 'error'); return; } gameState.resources.gold -= cost; gameState.trainingQueue.push({ id: uniqueId('trn_'), unitType: unitId, progress: 0, totalTime: trainTime, cost: cost, population: unitInfo.population }); showNotification(`${unitInfo.name} added to queue!`, 'success'); addMessage(`Training ${unitInfo.name}.`); updateTrainingQueueUI(); updateAllUIDisplays(); }
    function processTrainingQueue(deltaTime) { if (gameState.trainingQueue.length > 0) { const trainingUnit = gameState.trainingQueue[0]; trainingUnit.progress += deltaTime; if (trainingUnit.progress >= trainingUnit.totalTime) { if (gameState.resources.population + trainingUnit.population <= gameState.resources.maxPopulation) { gameState.resources.population += trainingUnit.population; const unitInfo = UNITS[trainingUnit.unitType]; gameState.units.push({ id: uniqueId('unt_'), type: trainingUnit.unitType, originalCost: trainingUnit.cost, recruitedAt: gameState.stats.timePlayed }); showNotification(`${unitInfo.name} trained!`, 'success'); addMessage(`${unitInfo.name} joined army.`); gameState.stats.unitsTrained = (gameState.stats.unitsTrained || 0) + 1; } else { showNotification(`${UNITS[trainingUnit.unitType].name} trained, but no pop! Unit lost. Gold refunded.`, 'error'); addMessage(`Could not field ${UNITS[trainingUnit.unitType].name}. Gold refunded.`); gameState.resources.gold += trainingUnit.cost; } gameState.trainingQueue.shift(); loadAvailableUnits(); updateAllUIDisplays(); } updateTrainingQueueUI(); }}
    function updateTrainingQueueUI() { DOMElements.trainingQueueCount.textContent = gameState.trainingQueue.length; if (gameState.trainingQueue.length > 0) { DOMElements.trainingQueueDisplay.style.display = 'block'; DOMElements.trainingQueueList.innerHTML = gameState.trainingQueue.map((item, index) => { const unitInfo = UNITS[item.unitType]; const progressPercent = Math.min(100, (item.progress / item.totalTime) * 100); return `<div class="training-queue-item-info"><span>${index + 1}. ${unitInfo.icon} ${unitInfo.name}</span><span>${formatNumber(item.progress,0)}s / ${item.totalTime}s</span></div><div class="progress-container" style="height:5px; margin-bottom:5px;"><div class="progress-bar-small" style="width:${progressPercent}%"></div></div>`; }).join(''); } else { DOMElements.trainingQueueDisplay.style.display = 'none'; DOMElements.trainingQueueList.innerHTML = ""; }}
    function countTotalPlayerUnits() { return gameState.units.length; }
    function calculateArmyStrength() { let strength = 0; gameState.units.forEach(unitInstance => { const unitStats = getUnitEffectiveStats(unitInstance.type); strength += (unitStats.attack * 1.5) + unitStats.defense + (unitStats.hp / 4); }); gameState.worldMap.deployedArmies.forEach(army => army.units.forEach(u => {const unitStats = getUnitEffectiveStats(u.type); strength += u.count * ((unitStats.attack*1.5) + unitStats.defense + (unitStats.hp/4)); })); return Math.floor(strength); }

    const ENEMY_OUTPOSTS = [
        { name: "Rival Tribe Camp", description: "Scout their camp.", icon: "üèïÔ∏è", rewardBase: 50, minAge: 0, maxAge: 1, composition: [{ type: "clubber", countMin: 3, countMax: 5, unitDef: UNITS.clubber}]},
        { name: "Boar Den", description: "Dangerous wild boars.", icon: "üêó", rewardBase: 70, minAge: 0, maxAge: 2, composition: [{ type: "wildBoar", countMin: 2, countMax: 4, unitDef: {name: "Wild Boar", icon:"üêó", maxHp:50, baseAttack:8, baseDefense:3, baseSpeed:4, isRanged: false}}]},
        { name: "Bandit Hideout", description: "Root out the bandits.", icon: "üè¥‚Äç‚ò†Ô∏è", rewardBase: 150, minAge: 1, maxAge: 3, composition: [{ type: "spearman", countMin: 4, countMax: 6, unitDef: UNITS.spearman}, {type: "archer", countMin:2, countMax:3, unitDef: UNITS.archer}]},
        { name: "Fortified Outpost", description: "A well-defended enemy position.", icon: "üè∞", rewardBase: 300, minAge: 2, maxAge: 4, composition: [{ type: "knight", countMin: 3, countMax: 5, unitDef: UNITS.knight}, {type: "archer", countMin:3, countMax:5, unitDef: UNITS.archer}]},
        { name: "Industrial Complex", description: "Heavily guarded factory.", icon: "üè≠", rewardBase: 1000, minAge: 4, maxAge: 5, composition: [{ type: "rifleman", countMin: 6, countMax: 10, unitDef: UNITS.rifleman}, {type: "cannon", countMin:1, countMax:2, unitDef: UNITS.cannon}]},
        { name: "Alien Wreckage", description: "Investigate the crash site.", icon: "üëΩ", rewardBase: 5000, minAge: 6, maxAge: 7, composition: [{ type: "drone", countMin: 5, countMax: 8, unitDef: UNITS.drone}, {type: "mech", countMin:1, countMax:2, unitDef: UNITS.mech}]},
    ];

    function findEnemies() { if (gameState.battle.isActive) { showNotification("Battle active!", 'error'); return; } if (countTotalPlayerUnits() === 0) { showNotification("Need units!", 'error'); return; } const ageStrengthMod = AGES[gameState.age].enemyStrengthModifier || 1; const outposts = ENEMY_OUTPOSTS.filter(e => e.minAge <= gameState.age && e.maxAge >= gameState.age).map(e => { let estimatedStrength = 0; e.composition.forEach(comp => { const unitDef = comp.unitDefOverride || comp.unitDef || UNITS[comp.type] || {maxHp:10,baseAttack:1,baseDefense:1,baseSpeed:1}; const count = Math.floor((comp.countMin + comp.countMax) / 2); estimatedStrength += count * (unitDef.baseAttack + unitDef.baseDefense + unitDef.maxHp/5) * ageStrengthMod; }); return { ...e, calculatedStrength: Math.floor(estimatedStrength), reward: Math.floor(e.rewardBase * ageStrengthMod) }; }); DOMElements.enemySelectionList.innerHTML = ''; outposts.forEach(outpost => { const el = document.createElement('div'); el.className = 'item-slot enemy-preview'; el.dataset.tooltip = `<strong>${outpost.name}</strong><br>${outpost.description}<br>Est. Strength: ${formatNumber(outpost.calculatedStrength)}<br>Reward: ~${formatNumber(outpost.reward)} Gold`; el.innerHTML = `<div class="item-icon enemy-icon">${outpost.icon}</div><div class="item-details"><div class="item-name">${outpost.name}</div><div class="item-description">Strength: ${formatNumber(outpost.calculatedStrength)}</div></div>`; el.addEventListener('click', () => initiateBattle(outpost, 'outpost')); DOMElements.enemySelectionList.appendChild(el); }); DOMElements.enemySelectionContainer.style.display = 'block'; }
    function initiateBattle(encounterData, battleType = 'outpost', deployedArmyId = null) {
        gameState.battle.isActive = true;
        gameState.battle.log = [];
        gameState.battle.battleType = battleType;
        gameState.battle.currentTurn = 'player';
        gameState.battle.actedStackIdsThisTurn = [];
        gameState.battle.selectedPlayerStackId = null;
        gameState.battle.selectedAction = null;
        gameState.battle.selectedTargetStackBattleId = null;
        gameState.battle.isAwaitingTargetSelection = false;
        gameState.battle.targetingSource = null;
        gameState.battle.agePowerCooldowns = {};
        addBattleLogEntry(`Battle against ${encounterData.name} begins!`);
        DOMElements.battleTitleText.textContent = `Battle: ${encounterData.name}`;
    
        let sourceUnits;
        if (deployedArmyId) {
            const deployedArmy = gameState.worldMap.deployedArmies.find(da => da.id === deployedArmyId);
            if (!deployedArmy) {
                console.error("Deployed army not found for battle:", deployedArmyId);
                gameState.battle.isActive = false; return;
            }
            sourceUnits = deployedArmy.units.flatMap(stack => Array(stack.count).fill(null).map(() => ({type: stack.type, id: uniqueId('deployed_unit_')}) ));
            gameState.battle.currentDeployedArmyId = deployedArmyId;
        } else {
            sourceUnits = gameState.units;
        }
    
        const playerUnitGroups = {};
        sourceUnits.forEach(unit => {
            if (!playerUnitGroups[unit.type]) {
                playerUnitGroups[unit.type] = { unitDef: UNITS[unit.type], ids: [] };
            }
            playerUnitGroups[unit.type].ids.push(unit.id);
        });
    
        gameState.battle.playerParty = Object.entries(playerUnitGroups).map(([type, group]) => {
            const unitDef = group.unitDef;
            const effectiveStats = getUnitEffectiveStats(type);
            const count = group.ids.length;
            return {
                type: type, name: unitDef.name, count: count, currentTotalHp: count * effectiveStats.hp,
                maxHpPerUnit: effectiveStats.hp, attackPerUnit: effectiveStats.attack, defensePerUnit: effectiveStats.defense,
                speed: effectiveStats.speed, icon: unitDef.icon, battleId: uniqueId('playerstack_'),
                isPlayerStack: true, isDefending: false, hasActedThisTurn: false, originalUnitIds: group.ids, unitDef: unitDef
            };
        });
    
        const ageStrengthMod = encounterData.ageLevel !== undefined ? (AGES[encounterData.ageLevel]?.enemyStrengthModifier || AGES[gameState.age].enemyStrengthModifier) : AGES[gameState.age].enemyStrengthModifier;
        gameState.battle.enemyParty = encounterData.composition.map(comp => {
            const baseDef = comp.unitDefOverride || comp.unitDef || UNITS[comp.type] || {name: comp.type, icon:"‚ùì", maxHp:20, baseAttack:5, baseDefense:2, baseSpeed:3, isRanged: false};
            const count = comp.countMin && comp.countMax ? Math.floor(Math.random() * (comp.countMax - comp.countMin + 1)) + comp.countMin : (comp.count || 1);
            const enemyMaxHp = Math.floor(baseDef.maxHp * (ageStrengthMod * 0.8 + 0.2));
            const enemyAttack = Math.floor(baseDef.baseAttack * ageStrengthMod);
            const enemyDefense = Math.floor(baseDef.baseDefense * ageStrengthMod);
            const enemySpeed = baseDef.baseSpeed;
            return {
                type: comp.type, name: baseDef.name, count: count, currentTotalHp: count * enemyMaxHp,
                maxHpPerUnit: enemyMaxHp, attackPerUnit: enemyAttack, defensePerUnit: enemyDefense,
                speed: enemySpeed, icon: baseDef.icon, battleId: uniqueId('enemystack_'),
                isPlayerStack: false, isDefending: false, originalEncounterData: encounterData, unitDef: baseDef
            };
        });
    
        gameState.battle.rewards = { gold: encounterData.reward || (encounterData.rewardBase * ageStrengthMod) || 50 };
        DOMElements.enemySelectionContainer.style.display = 'none';
        DOMElements.battleButton.disabled = true;
        DOMElements.battleButton.textContent = "Battle in Progress...";
        showModal(DOMElements.battleModalOverlay);
        DOMElements.battleArea.style.backgroundImage = AGES[encounterData.ageLevel !== undefined ? encounterData.ageLevel : gameState.age].battleBg || 'var(--secondary-color)';
        startPlayerTurn();
        renderBattleUI();
    }

    function renderBattleUI() {
        const createStackHTML = (stack, isPlayer) => {
            const hpPercent = Math.max(0, (stack.currentTotalHp / (stack.count * stack.maxHpPerUnit))) * 100 || 0;
            let classes = "battle-unit-stack" + (isPlayer ? " player-stack" : " enemy-stack");
            if (stack.currentTotalHp <= 0) classes += " defeated-stack";
            if (isPlayer && stack.battleId === gameState.battle.selectedPlayerStackId) classes += " selected-actor";
            if (isPlayer && stack.hasActedThisTurn && stack.currentTotalHp > 0) classes += " has-acted";
            if (isPlayer && !stack.hasActedThisTurn && stack.currentTotalHp > 0 && gameState.battle.currentTurn === 'player') classes += " selectable";
            if (!isPlayer && stack.currentTotalHp > 0 && (gameState.battle.selectedPlayerStackId || gameState.battle.isAwaitingTargetSelection)) classes += " targetable";
            if (!isPlayer && stack.battleId === gameState.battle.selectedTargetStackBattleId) classes += " selected-target";

            const tooltip = `HP/Unit: ${stack.maxHpPerUnit}\nAtk/Unit: ${stack.attackPerUnit}\nDef/Unit: ${stack.defensePerUnit}\nSpeed: ${stack.speed}${stack.unitDef.aoeType ? `\nAoE: ${stack.unitDef.aoeType.replace('_all_others','')} (${(stack.unitDef.aoeDamagePercent || 0)*100}%)` : ''}`;
            return `<div class="${classes}" data-battle-id="${stack.battleId}" data-tooltip="${tooltip.replace(/\n/g, '<br>')}" style="order:${100-stack.speed};"> <div class="battle-unit-icon">${stack.icon}</div> <div class="battle-unit-name">${stack.name}</div> <div class="battle-unit-count">x ${stack.count} (HP: ${formatNumber(stack.currentTotalHp)})</div> <div class="battle-unit-hp-bar"><div class="battle-unit-hp" style="width: ${hpPercent}%;"></div></div> <div class="battle-unit-stats-line">Atk: ${stack.attackPerUnit} | Def: ${stack.defensePerUnit} | Spd: ${stack.speed}</div> ${stack.isDefending ? 'üõ°Ô∏è Defending' : ''} </div>`;
        };
        DOMElements.playerBattlePartyContainer.innerHTML = gameState.battle.playerParty.map(stack => createStackHTML(stack, true)).join('');
        DOMElements.enemyBattlePartyContainer.innerHTML = gameState.battle.enemyParty.map(stack => createStackHTML(stack, false)).join('');
        document.querySelectorAll('.battle-unit-stack.player-stack.selectable').forEach(el => el.onclick = () => handlePlayerStackSelectionInBattle(el.dataset.battleId));
        document.querySelectorAll('.battle-unit-stack.enemy-stack.targetable').forEach(el => el.onclick = () => handleEnemyStackTargetSelectionInBattle(el.dataset.battleId));
        DOMElements.battleLogContainerModal.innerHTML = gameState.battle.log.map(entry => `<div class="battle-log-entry">${entry}</div>`).join('');
        DOMElements.battleLogContainerModal.scrollTop = DOMElements.battleLogContainerModal.scrollHeight;

        const isPlayerTurn = gameState.battle.currentTurn === 'player';
        const canAct = !!gameState.battle.selectedPlayerStackId;
        DOMElements.battleActionAttack.disabled = !isPlayerTurn || !canAct || gameState.battle.isAwaitingTargetSelection;
        DOMElements.battleActionDefend.disabled = !isPlayerTurn || !canAct || gameState.battle.isAwaitingTargetSelection;
        DOMElements.battleEndTurnButton.disabled = !isPlayerTurn || gameState.battle.isAwaitingTargetSelection;

        DOMElements.battleLeaveButton.style.display = gameState.battle.isActive ? 'flex' : 'none';
        renderAgePowers();
    }
    function handlePlayerStackSelectionInBattle(stackId) {
         if (!gameState.battle.isActive || gameState.battle.currentTurn !== 'player') return;
         const stack = findCombatantStackByBattleId(stackId);
         if (stack && stack.isPlayerStack && stack.currentTotalHp > 0 && !stack.hasActedThisTurn) {
            gameState.battle.selectedPlayerStackId = stackId;
            gameState.battle.selectedAction = null;
            gameState.battle.selectedTargetStackBattleId = null;
            addBattleLogEntry(`Selected ${stack.name} x${stack.count}. Choose action (Click Enemy/Defend).`);
            renderBattleUI();
         }
    }
    function handleEnemyStackTargetSelectionInBattle(targetStackBattleId) {
        if (!gameState.battle.isActive || gameState.battle.currentTurn !== 'player') return;
        const targetStack = findCombatantStackByBattleId(targetStackBattleId);
        if (!targetStack || targetStack.isPlayerStack || targetStack.currentTotalHp <= 0) {
            showNotification("Invalid target.", "error"); return;
        }

        if(gameState.battle.isAwaitingTargetSelection){
             gameState.battle.selectedTargetStackBattleId = targetStackBattleId;
             gameState.battle.isAwaitingTargetSelection = false;
             if(gameState.battle.targetingSource === 'agePower'){
                 applyAgePowerEffect(gameState.battle.currentPendingAgePower);
             }
             gameState.battle.currentPendingAgePower = null;
             gameState.battle.targetingSource = null;
        } else if (gameState.battle.selectedPlayerStackId) {
            gameState.battle.selectedTargetStackBattleId = targetStackBattleId;
            gameState.battle.selectedAction = 'attack';
            executeBattleAction();
        } else {
             showNotification("Select one of your units first!", "info");
        }
        renderBattleUI();
    }
    function addBattleLogEntry(message) { gameState.battle.log.push(message); if (gameState.battle.log.length > 50) gameState.battle.log.shift(); if (DOMElements.battleModalOverlay.classList.contains('visible')) renderBattleUI(); }
    function findCombatantStackByBattleId(battleId) { return gameState.battle.playerParty.find(s => s.battleId === battleId) || gameState.battle.enemyParty.find(s => s.battleId === battleId); }

    function startPlayerTurn() {
        gameState.battle.currentTurn = 'player';
        gameState.battle.actedStackIdsThisTurn = [];
        gameState.battle.playerParty.forEach(s => {
            s.hasActedThisTurn = false;
            s.isDefending = false;
        });
        gameState.battle.enemyParty.forEach(s => s.isDefending = false);
        gameState.battle.selectedPlayerStackId = null;
        gameState.battle.selectedAction = null;
        gameState.battle.selectedTargetStackBattleId = null;

        for (const powerId in gameState.battle.agePowerCooldowns) {
            if(gameState.battle.agePowerCooldowns[powerId] > 0) gameState.battle.agePowerCooldowns[powerId]--;
         }

        addBattleLogEntry("--- Player Turn Start ---");
        showNotification("Your Turn! Select a unit and action.", "info", 2000);
        renderBattleUI();
    }
    function setupBattleActionListeners() {
        DOMElements.battleActionDefend.onclick = () => { if (!gameState.battle.selectedPlayerStackId || gameState.battle.currentTurn !== 'player') return; gameState.battle.selectedAction = 'defend'; executeBattleAction(); };
        DOMElements.battleEndTurnButton.onclick = () => { if(gameState.battle.currentTurn === 'player') { addBattleLogEntry("--- Player Ends Turn ---"); startAiTurn(); }};
        DOMElements.battleLeaveButton.onclick = () => { if (gameState.battle.isActive) { addBattleLogEntry("Player conceded."); endBattle(false); } };
    }
    function executeBattleAction() {
        if (!gameState.battle.isActive || !gameState.battle.selectedAction || !gameState.battle.selectedPlayerStackId) return;
        const actingStack = findCombatantStackByBattleId(gameState.battle.selectedPlayerStackId);
        if (!actingStack || actingStack.currentTotalHp <= 0 || actingStack.hasActedThisTurn) { resetSelectionsAfterAction(); return; }

        let actionTaken = false;
        if (gameState.battle.selectedAction === 'attack') {
            if (!gameState.battle.selectedTargetStackBattleId) { showNotification("Attack error: No target selected (should not happen with new flow)!", "error"); resetSelectionsAfterAction(); return; }
            const targetStack = findCombatantStackByBattleId(gameState.battle.selectedTargetStackBattleId);
            if (!targetStack || targetStack.currentTotalHp <= 0) { showNotification("Invalid target.", "error"); gameState.battle.selectedTargetStackBattleId = null; renderBattleUI(); return; }
            performStackAttack(actingStack, targetStack); actionTaken = true;
        } else if (gameState.battle.selectedAction === 'defend') {
            actingStack.isDefending = true; actionTaken = true;
            addBattleLogEntry(`${actingStack.name} x${actingStack.count} is defending!`);
            createEffectPopup(actingStack.battleId, "üõ°Ô∏è Defending!");
        }

        if(actionTaken){
             actingStack.hasActedThisTurn = true;
             gameState.battle.actedStackIdsThisTurn.push(actingStack.battleId);
             resetSelectionsAfterAction();
        } else {
             resetSelectionsAfterAction();
        }
         const canPlayerActFurther = gameState.battle.playerParty.some(s => s.currentTotalHp > 0 && !s.hasActedThisTurn);
         if(!canPlayerActFurther && gameState.battle.currentTurn === 'player'){
             addBattleLogEntry("All player units have acted.");
             DOMElements.battleEndTurnButton.click();
         } else {
             checkBattleEndCondition();
             renderBattleUI();
         }
    }
     function resetSelectionsAfterAction() {
         gameState.battle.selectedPlayerStackId = null;
         gameState.battle.selectedAction = null;
         gameState.battle.selectedTargetStackBattleId = null;
         renderBattleUI();
     }

    function startAiTurn() {
        gameState.battle.currentTurn = 'ai';
        DOMElements.battleEndTurnButton.disabled = true;
        DOMElements.battleActionAttack.disabled = true;
        DOMElements.battleActionDefend.disabled = true;
        addBattleLogEntry("--- Enemy Turn Start ---");
        processAiActionsSequentially([...gameState.battle.enemyParty.filter(s => s.currentTotalHp > 0)].sort((a, b) => b.speed - a.speed));
    }

    function processAiActionsSequentially(aiStacks, index = 0) {
        if (!gameState.battle.isActive || index >= aiStacks.length) {
             if(gameState.battle.isActive) {
                 addBattleLogEntry("--- Enemy Turn End ---");
                 setTimeout(startPlayerTurn, 800);
             }
             return;
        }
        const aiStack = aiStacks[index];
        if(aiStack.currentTotalHp <= 0) {
             processAiActionsSequentially(aiStacks, index + 1);
             return;
        }
        aiStack.isDefending = false;
        const alivePlayerStacks = gameState.battle.playerParty.filter(s => s.currentTotalHp > 0);
        if (alivePlayerStacks.length === 0) {
             processAiActionsSequentially(aiStacks, index + 1);
             return;
        }
        let action = 'attack';
        if (aiStack.currentTotalHp < (aiStack.count * aiStack.maxHpPerUnit * 0.4) && Math.random() < 0.35) action = 'defend';
        let delay = 1000 + Math.random()*500;

        if (action === 'attack') {
            const targetStack = alivePlayerStacks[Math.floor(Math.random() * alivePlayerStacks.length)];
             setTimeout(() => {
                if(gameState.battle.isActive && aiStack.currentTotalHp > 0 && targetStack.currentTotalHp > 0) {
                    performStackAttack(aiStack, targetStack);
                    renderBattleUI();
                    checkBattleEndCondition();
                }
                if(gameState.battle.isActive) processAiActionsSequentially(aiStacks, index + 1);
             }, delay);
        } else {
            aiStack.isDefending = true;
            addBattleLogEntry(`${aiStack.name} x${aiStack.count} takes a defensive stance!`);
            createEffectPopup(aiStack.battleId, "üõ°Ô∏è Defending!");
            renderBattleUI();
            setTimeout(() => {
                if(gameState.battle.isActive) processAiActionsSequentially(aiStacks, index + 1);
             }, delay/2);
        }
    }

    function performStackAttack(attackerStack, mainTargetStack) {
        if (!attackerStack || !mainTargetStack || attackerStack.currentTotalHp <= 0 || mainTargetStack.currentTotalHp <= 0) return;

        let defenseMultiplier = mainTargetStack.isDefending ? 1.75 : 1.0;
        let effectiveDefense = mainTargetStack.defensePerUnit * defenseMultiplier;
        let baseDamagePerAttacker = Math.max(1, attackerStack.attackPerUnit - effectiveDefense);
        let totalDamageToMainTarget = Math.floor(baseDamagePerAttacker * attackerStack.count * (0.8 + Math.random() * 0.4));
        totalDamageToMainTarget = Math.max(attackerStack.count, totalDamageToMainTarget);

        const logPrefix = `${attackerStack.name} x${attackerStack.count} attacks ${mainTargetStack.name}`;
        animateAttack(attackerStack.battleId, mainTargetStack.battleId, attackerStack.unitDef.icon, !attackerStack.unitDef.isRanged, () => {
             applyDamageToStack(mainTargetStack, totalDamageToMainTarget, logPrefix, attackerStack.isPlayerStack);
             if (mainTargetStack.isDefending) addBattleLogEntry(`${mainTargetStack.name} was defending!`);

            const attackerDef = attackerStack.unitDef;
            if (attackerDef.aoeType === 'splash_all_others' && attackerDef.aoeDamagePercent > 0) {
                const splashPercent = attackerDef.aoeDamagePercent;
                const baseSplashDamage = Math.max(1, Math.floor(totalDamageToMainTarget * splashPercent));
                const enemyPartyToSplash = attackerStack.isPlayerStack ? gameState.battle.enemyParty : gameState.battle.playerParty;

                enemyPartyToSplash.forEach(otherStack => {
                    if (otherStack.battleId !== mainTargetStack.battleId && otherStack.currentTotalHp > 0 && otherStack.count > 0) {
                        let splashDefenseMult = otherStack.isDefending ? 1.75 : 1.0;
                        let splashEffectiveDef = otherStack.defensePerUnit * splashDefenseMult;
                        let actualSplashDamage = Math.max(1, Math.floor(baseSplashDamage * (0.8 + Math.random() * 0.4) - splashEffectiveDef * 0.5));
                        applyDamageToStack(otherStack, actualSplashDamage, `Splash damage to ${otherStack.name}`, attackerStack.isPlayerStack, true);
                    }
                });
            }
             renderBattleUI();
             checkBattleEndCondition();
        });
    }

    function checkBattleEndCondition() {
         if (!gameState.battle.isActive) return;
         const alivePlayerStacks = gameState.battle.playerParty.filter(s => s.currentTotalHp > 0 && s.count > 0).length;
         const aliveEnemyStacks = gameState.battle.enemyParty.filter(s => s.currentTotalHp > 0 && s.count > 0).length;
         if (alivePlayerStacks === 0) { endBattle(false); }
         else if (aliveEnemyStacks === 0) { endBattle(true); }
     }

    function endBattle(isVictory) {
        if (!gameState.battle.isActive) return;
        const battleType = gameState.battle.battleType;
        const currentDeployedArmyId = gameState.battle.currentDeployedArmyId;
        const enemyEncounterData = gameState.battle.enemyParty.length > 0 && gameState.battle.enemyParty[0].originalEncounterData ? gameState.battle.enemyParty[0].originalEncounterData : {name: "Unknown Foe"};
    
        gameState.battle.isActive = false;
    
        if (isVictory) {
            const rewardGold = Math.floor(gameState.battle.rewards.gold);
            gameState.resources.gold += rewardGold;
            gameState.stats.battlesWon++;
            gameState.stats.enemiesDefeated++;
            addBattleLogEntry(`VICTORY vs ${enemyEncounterData.name}! Gained ${formatNumber(rewardGold)} gold!`);
            showNotification(`Victory! +${formatNumber(rewardGold)} gold`, 'success', 4000);
    
            if (battleType === 'raid') {
                gameState.stats.raidsDefended = (gameState.stats.raidsDefended || 0) + 1;
                const raidId = enemyEncounterData.id;
                gameState.activeRaids = gameState.activeRaids.filter(r => r.id !== raidId);
                gameState.mapEntities.raiders = gameState.mapEntities.raiders.filter(rVisual => rVisual.raidId !== raidId);
                updateRaidAlertUI();
            } else if (battleType === 'world_outpost' && enemyEncounterData.id) {
                const outpost = gameState.worldMap.outposts.find(o => o.id === enemyEncounterData.id);
                if (outpost) outpost.isDefeated = true;
            }
        } else {
            gameState.stats.battlesLost++;
            addBattleLogEntry(`DEFEAT vs ${enemyEncounterData.name}! Your forces were routed.`);
            showNotification("Defeat! Your army was crushed.", 'error', 4000);
            if (battleType === 'raid') {
                const raid = gameState.activeRaids.find(r => r.id === enemyEncounterData.id);
                if (raid) {
                    raid.destructionStartTime = gameState.stats.timePlayed;
                    addMessage(`RAID ONGOING: ${raid.name} will begin destroying buildings!`, true);
                }
            }
        }
    
        if (currentDeployedArmyId) {
            const deployedArmyIndex = gameState.worldMap.deployedArmies.findIndex(da => da.id === currentDeployedArmyId);
            if (deployedArmyIndex !== -1) {
                if (isVictory) { // If victorious, army is disbanded from deployed state (units assumed lost or returned to main pool earlier if system were more complex)
                    gameState.worldMap.deployedArmies.splice(deployedArmyIndex, 1);
                    addBattleLogEntry("Deployed army disbanded after battle.");
                } else { // If defeat, army is lost
                     gameState.worldMap.deployedArmies.splice(deployedArmyIndex, 1);
                     addBattleLogEntry("Deployed army was wiped out!");
                }
            }
             gameState.battle.currentDeployedArmyId = null;
        } else { // Home guard battle
            const newGameStateUnits = [];
            let totalUnitsLostCount = 0;
            gameState.units.forEach(originalUnit => {
                const stackItBelongedTo = gameState.battle.playerParty.find(s => s.originalUnitIds.includes(originalUnit.id));
                if (stackItBelongedTo) {
                    if (stackItBelongedTo.currentTotalHp > 0 && stackItBelongedTo.count > 0) {
                        const indexOfThisUnitInStackOriginals = stackItBelongedTo.originalUnitIds.indexOf(originalUnit.id);
                        if (indexOfThisUnitInStackOriginals < stackItBelongedTo.count) {
                            newGameStateUnits.push(originalUnit);
                        } else {
                            gameState.resources.population -= UNITS[originalUnit.type].population; totalUnitsLostCount++;
                        }
                    } else {
                        gameState.resources.population -= UNITS[originalUnit.type].population; totalUnitsLostCount++;
                    }
                } else { newGameStateUnits.push(originalUnit); }
            });
            gameState.units = newGameStateUnits;
            if (totalUnitsLostCount > 0) addBattleLogEntry(`You lost ${totalUnitsLostCount} individual warriors from home guard.`);
        }
    
        gameState.resources.population = Math.max(0, gameState.resources.population);
        gameState.battle = getDefaultGameState().battle; 
        hideModal(DOMElements.battleModalOverlay);
        DOMElements.battleButton.disabled = (countTotalPlayerUnits() === 0 && gameState.worldMap.deployedArmies.length === 0);
        DOMElements.battleButton.textContent = "Find Random Enemy Outpost";
        loadAvailableUnits();
        updateAllUIDisplays();
        renderGameView();
    }

    function applyDamageToStack(targetStack, damageAmount, logMessagePrefix = "", attackerIsPlayer, isSplash = false) {
        const oldTargetCount = targetStack.count;
        const damageDealt = Math.min(targetStack.currentTotalHp, damageAmount);
        targetStack.currentTotalHp -= damageDealt;
        targetStack.count = Math.ceil(targetStack.currentTotalHp / targetStack.maxHpPerUnit);

        if (!isSplash) {
            addBattleLogEntry(`${logMessagePrefix} for ${damageDealt} damage! (${targetStack.name} HP: ${targetStack.currentTotalHp})`);
        } else {
             addBattleLogEntry(` -> ${targetStack.name} takes ${damageDealt} splash damage.`);
        }

        const targetElement = DOMElements.battleModalOverlay.querySelector(`.battle-unit-stack[data-battle-id="${targetStack.battleId}"]`);
        if (targetElement) {
            const damagePopup = document.createElement('div');
            damagePopup.className = 'damage-popup';
            damagePopup.textContent = `-${damageDealt}`;
            const battleAreaRect = DOMElements.battleArea.getBoundingClientRect();
            const targetRect = targetElement.getBoundingClientRect();
            damagePopup.style.left = `${targetRect.left - battleAreaRect.left + targetRect.width / 2 - 15}px`;
            damagePopup.style.top = `${targetRect.top - battleAreaRect.top + targetRect.height / 3 - 20}px`;
            DOMElements.battleArea.appendChild(damagePopup);
            setTimeout(() => damagePopup.remove(), 1250);
        }

        if (targetStack.currentTotalHp <= 0) {
            targetStack.count = 0;
             targetStack.currentTotalHp = 0;
            if (!isSplash) addBattleLogEntry(`${targetStack.name} stack has been wiped out!`);
        } else if (!isSplash && oldTargetCount > targetStack.count) {
            addBattleLogEntry(`${targetStack.name} lost ${oldTargetCount - targetStack.count} units.`);
        }
        renderBattleUI();
    }
    function createEffectPopup(targetStackBattleId, effectText, type = 'effect') {
        const targetElement = DOMElements.battleModalOverlay.querySelector(`.battle-unit-stack[data-battle-id="${targetStackBattleId}"]`);
        if (targetElement) {
            const popup = document.createElement('div');
            popup.className = type === 'heal' ? 'heal-popup' : 'effect-popup';
            popup.textContent = effectText;
            const battleAreaRect = DOMElements.battleArea.getBoundingClientRect();
            const targetRect = targetElement.getBoundingClientRect();
            popup.style.left = `${targetRect.left - battleAreaRect.left + targetRect.width / 2 - (effectText.length * 4)}px`;
            popup.style.top = `${targetRect.top - battleAreaRect.top - 20}px`;
            DOMElements.battleArea.appendChild(popup);
            setTimeout(() => popup.remove(), 1450);
        }
    }
    function animateAttack(attackerId, targetId, icon, isMelee, onCompleteCallback) {
        const attackerElement = DOMElements.battleModalOverlay.querySelector(`.battle-unit-stack[data-battle-id="${attackerId}"]`);
        const targetElement = DOMElements.battleModalOverlay.querySelector(`.battle-unit-stack[data-battle-id="${targetId}"]`);
        if (!attackerElement || !targetElement) { if(onCompleteCallback) onCompleteCallback(); return; }

        const animationDuration = isMelee ? 700 : 400;
        const isPlayerAttacking = attackerElement.classList.contains('player-stack');

        if (isMelee) {
            attackerElement.classList.add(isPlayerAttacking ? 'anim-melee-attack' : 'anim-melee-attack-enemy');
            setTimeout(() => {
                attackerElement.classList.remove(isPlayerAttacking ? 'anim-melee-attack' : 'anim-melee-attack-enemy');
                if(onCompleteCallback) onCompleteCallback();
            }, animationDuration);
        } else {
            const projectile = document.createElement('div');
            projectile.className = 'projectile';
            projectile.textContent = icon;

            const projectileContainerRect = DOMElements.projectileContainer.getBoundingClientRect();
            const attackerRect = attackerElement.getBoundingClientRect();
            const targetRect = targetElement.getBoundingClientRect();

            const startX = (attackerRect.left + attackerRect.width / 2) - projectileContainerRect.left;
            const startY = (attackerRect.top + attackerRect.height / 3) - projectileContainerRect.top; 
            const endX = (targetRect.left + targetRect.width / 2) - projectileContainerRect.left;
            const endY = (targetRect.top + targetRect.height / 2) - projectileContainerRect.top;

            projectile.style.position = 'absolute';
            projectile.style.left = `${startX - 10}px`; 
            projectile.style.top = `${startY - 10}px`;
            DOMElements.projectileContainer.appendChild(projectile);

             requestAnimationFrame(() => {
                projectile.style.transform = `translate(${endX - startX}px, ${endY - startY}px)`;
             });

            setTimeout(() => {
                 projectile.classList.add('hit');
                setTimeout(() => {
                    projectile.remove();
                }, 100); 
                if(onCompleteCallback) onCompleteCallback();
            }, animationDuration);
        }
    }

    function renderAgePowers() {
        DOMElements.battleAgePowersContainer.innerHTML = '';
        const currentAgePower = AGES[gameState.age].specialPower;
        if (currentAgePower) {
            const cooldown = gameState.battle.agePowerCooldowns[currentAgePower.id] || 0;
            const canAfford = checkAgePowerCost(currentAgePower);
            const canUse = cooldown <= 0 && canAfford && gameState.battle.currentTurn === 'player' && !gameState.battle.isAwaitingTargetSelection;
            const el = document.createElement('button');
            el.className = 'game-button age-power-button';
            el.disabled = !canUse;
            el.dataset.powerId = currentAgePower.id;
            el.dataset.tooltip = `<strong>${currentAgePower.name} (${currentAgePower.icon})</strong><br>${currentAgePower.description}<br>Cost: ${currentAgePower.cost} ${currentAgePower.costType}<br>${cooldown > 0 ? `Cooldown: ${cooldown} turns` : (canAfford ? 'Ready!' : 'Cannot afford')}`;
            el.innerHTML = `<span>${currentAgePower.icon} ${currentAgePower.name} ${cooldown > 0 ? `(${cooldown})` : ''}</span><span>${currentAgePower.cost} ${currentAgePower.costType.slice(0,1).toUpperCase()}</span>`;
            el.onclick = () => attemptUseAgePower(currentAgePower.id);
            DOMElements.battleAgePowersContainer.appendChild(el);
        } else {
             DOMElements.battleAgePowersContainer.innerHTML = "<span style='align-self: center; opacity: 0.7;'>No Age Power available.</span>";
        }
    }
    function checkAgePowerCost(powerDef) {
        if (powerDef.costType === 'gold') return gameState.resources.gold >= powerDef.cost;
        if (powerDef.costType === 'tech') return gameState.resources.technologyPoints >= powerDef.cost;
        return true;
    }
    function attemptUseAgePower(powerId) {
        const powerDef = AGES[gameState.age].specialPower;
        if (!powerDef || powerDef.id !== powerId || (gameState.battle.agePowerCooldowns[powerId] || 0) > 0 || !checkAgePowerCost(powerDef) || gameState.battle.currentTurn !== 'player') return;

         if (powerDef.targetType === 'enemy_stack_select' || powerDef.targetType === 'player_stack_select' || powerDef.targetType === 'directDamageSplash') {
              gameState.battle.isAwaitingTargetSelection = true;
              gameState.battle.targetingSource = 'agePower';
              gameState.battle.currentPendingAgePower = powerDef;
              gameState.battle.selectedAction = null;
              gameState.battle.selectedPlayerStackId = null;
              showNotification(`Select target for ${powerDef.name}.`, 'info', 3000);
              addBattleLogEntry(`Activated ${powerDef.name}. Select target.`);
              renderBattleUI();
         } else {
             applyAgePowerEffect(powerDef);
         }
    }

    function applyAgePowerEffect(powerDef) {
        if (!checkAgePowerCost(powerDef)) { showNotification(`Error: Cannot afford ${powerDef.name}!`, 'error'); return; }
        if (powerDef.costType === 'gold') gameState.resources.gold -= powerDef.cost;
        else if (powerDef.costType === 'tech') gameState.resources.technologyPoints -= powerDef.cost;

        addBattleLogEntry(`Player uses Age Power: ${powerDef.name}!`);
        createEffectPopup(gameState.battle.playerParty.length > 0 ? gameState.battle.playerParty[0].battleId : 'none', `${powerDef.icon} ${powerDef.name}!`, 'info');

        let targetStack;
        switch (powerDef.effect) {
            case 'directDamage':
            case 'directDamageSplash':
                 targetStack = findCombatantStackByBattleId(gameState.battle.selectedTargetStackBattleId);
                 if(targetStack) {
                     applyDamageToStack(targetStack, powerDef.damageBase, `${powerDef.name} hits ${targetStack.name}`, true);
                     if(powerDef.effect === 'directDamageSplash' && powerDef.aoeDamagePercent > 0){
                        const splashDamage = Math.max(1,Math.floor(powerDef.damageBase * powerDef.aoeDamagePercent));
                        gameState.battle.enemyParty.forEach(otherTarget => {
                            if(otherTarget.battleId !== targetStack.battleId && otherTarget.currentTotalHp > 0){
                                applyDamageToStack(otherTarget, splashDamage, `Splash from ${powerDef.name} hits ${otherTarget.name}`, true, true);
                            }
                        });
                     }
                 } else { addBattleLogEntry("Invalid or no target selected for age power!");}
                 break;
            case 'aoeDamage':
                const targets = powerDef.targetType === 'all_enemies' ? gameState.battle.enemyParty : gameState.battle.playerParty;
                 targets.forEach(tStack => {
                    if (tStack.currentTotalHp > 0) {
                        applyDamageToStack(tStack, powerDef.damageBase, `${powerDef.name} strikes ${tStack.name}`, true, true);
                    }
                });
                break;
            case 'buff_attack_once':
                 targetStack = findCombatantStackByBattleId(gameState.battle.selectedTargetStackBattleId);
                 if(targetStack && targetStack.isPlayerStack) {
                      targetStack.temporaryAttackMultiplier = (targetStack.temporaryAttackMultiplier || 1) * powerDef.buffAmount;
                      addBattleLogEntry(`${targetStack.name} gets an attack boost!`);
                      createEffectPopup(targetStack.battleId, `‚öîÔ∏è+ Atk Up!`);
                 } else { addBattleLogEntry(`Invalid target for Rally Troops.`);}
                 break;
            case 'buff_defense_all':
                gameState.battle.playerParty.forEach(pStack => {
                    if(pStack.currentTotalHp > 0) {
                        pStack.isDefending = true;
                        createEffectPopup(pStack.battleId, `üõ°Ô∏è++ Def Up!`);
                    }
                });
                 addBattleLogEntry(`All player units bolster their defenses!`);
                 break;
            default:
                addBattleLogEntry(`Age power effect '${powerDef.effect}' not fully implemented.`);
        }

        gameState.battle.agePowerCooldowns[powerDef.id] = powerDef.cooldownTurns;
        gameState.battle.selectedTargetStackBattleId = null;
        renderBattleUI();
        updateResourceDisplays();
        checkBattleEndCondition();
    }

    function loadAvailableTechnologies() { DOMElements.techContainer.innerHTML = ''; const available = Object.values(TECHNOLOGIES).filter(tech => tech.minAge <= gameState.age && !gameState.technologies.includes(tech.id) && tech.prereqs.every(prereq => gameState.technologies.includes(prereq))); available.forEach(tech => { const effectsDesc = tech.effects.map(e => { let valStr = e.operation === 'multiply' ? `x${e.value.toFixed(1)}` : (e.value > 0 ? `+${e.value}` : `${e.value}`); return `${valStr} ${e.target.replace(/([A-Z])/g, ' $1').toLowerCase()}`; }).join(', '); const el = document.createElement('button'); el.className = 'game-button'; el.dataset.itemId = tech.id; el.dataset.tooltip = `<strong>${tech.name} (${tech.icon})</strong><br>${tech.description}<br><em>Effect: ${effectsDesc}</em><br>Time: ${tech.researchTime}s`; el.innerHTML = `<span>${tech.icon} ${tech.name}</span><span>${formatNumber(tech.cost)}</span>`; el.addEventListener('click', () => startResearch(tech.id)); DOMElements.techContainer.appendChild(el); }); updateButtonStates(); }
    function startResearch(techId) { if (gameState.currentResearch.id) { showNotification("Researching!", 'error'); return; } const techInfo = TECHNOLOGIES[techId]; if (gameState.resources.gold < techInfo.cost) { showNotification("No gold!", 'error'); return; } gameState.resources.gold -= techInfo.cost; gameState.currentResearch = { id: techId, progress: 0, timeToComplete: techInfo.researchTime }; showNotification(`Researching ${techInfo.name}...`, 'info'); addMessage(`Started research: ${techInfo.name}.`); updateAllUIDisplays(); }
    function completeResearch() { const techId = gameState.currentResearch.id; const techInfo = TECHNOLOGIES[techId]; gameState.technologies.push(techId); applyEffects(techInfo); gameState.stats.techsResearched++; gameState.currentResearch = { id: null, progress: 0, timeToComplete: 0 }; showNotification(`${techInfo.name} researched!`, 'success'); addMessage(`Completed research: ${techInfo.name}.`); loadAvailableTechnologies(); loadAvailableBuildings(); loadAvailableUnits(); updateAllUIDisplays(); }
    function advanceAge() {
        if (gameState.age >= AGES.length - 1) return;
        const nextAgeReq = AGES[gameState.age + 1];
        if (gameState.resources.technologyPoints >= nextAgeReq.techCost) {
            gameState.resources.technologyPoints -= nextAgeReq.techCost;
            gameState.age++;
            showNotification(`Advanced to ${AGES[gameState.age].name}!`, 'success', 5000);
            addMessage(`Empire advanced to the ${AGES[gameState.age].name}!`);
    
            const buildingsToProcess = [...gameState.buildings];
            buildingsToProcess.forEach(buildingInstance => {
                if (!buildingInstance.isConstructed) return; 
    
                const currentBuildingDef = BUILDINGS[buildingInstance.type];
                if (currentBuildingDef.upgradesTo) {
                    const upgradeToDefId = currentBuildingDef.upgradesTo;
                    const upgradeToDef = BUILDINGS[upgradeToDefId];
    
                    if (upgradeToDef && upgradeToDef.minAge <= gameState.age) {
                        
                        let canUpgradeFit = true;
                        if (upgradeToDef.sizeX > currentBuildingDef.sizeX || upgradeToDef.sizeY > currentBuildingDef.sizeY) {
                             canUpgradeFit = checkUpgradeFit(buildingInstance, upgradeToDef);
                        }

                        if (canUpgradeFit) {
                            const originalBuilding = gameState.buildings.find(b => b.id === buildingInstance.id);
                            if (originalBuilding && originalBuilding.type !== upgradeToDefId) {
                                addMessage(`INFO: Your ${currentBuildingDef.name} automatically upgraded to ${upgradeToDef.name}!`);
                                applyEffects(currentBuildingDef, true); 
                                originalBuilding.type = upgradeToDefId;
                                originalBuilding.level = (originalBuilding.level || 1) + 1;
                                originalBuilding.sizeX = upgradeToDef.sizeX; 
                                originalBuilding.sizeY = upgradeToDef.sizeY; 
                                applyEffects(upgradeToDef, false); 
                            }
                        } else {
                             addMessage(`INFO: Your ${currentBuildingDef.name} at [${buildingInstance.gridX},${buildingInstance.gridY}] could not upgrade to ${upgradeToDef.name} due to lack of space.`, 'error');
                        }
                    }
                }
            });
            generateWorldOutpostsIfNeeded();
            loadAvailableBuildings();
            loadAvailableUnits();
            loadAvailableTechnologies();
            updateAllUIDisplays();
            renderGameView();
        } else {
            showNotification("Not enough Tech Points!", 'error');
        }
    }
    function checkUpgradeFit(buildingInstance, newBuildingDef) {
        for (let y = 0; y < newBuildingDef.sizeY; y++) {
            for (let x = 0; x < newBuildingDef.sizeX; x++) {
                const checkX = buildingInstance.gridX + x;
                const checkY = buildingInstance.gridY + y;
                 if (x >= buildingInstance.sizeX || y >= buildingInstance.sizeY) { 
                    const occupyingBuilding = getBuildingAtGrid(checkX, checkY);
                    if (occupyingBuilding && occupyingBuilding.id !== buildingInstance.id) {
                        return false; 
                    }
                }
            }
        }
        return true;
    }


    function checkAchievements() { ACHIEVEMENTS_DATA.forEach(ach => { if (!gameState.achievements.includes(ach.id) && ach.condition(gameState)) unlockAchievement(ach); }); }
    function unlockAchievement(achievement) { gameState.achievements.push(achievement.id); DOMElements.achievementNamePopup.textContent = achievement.name; DOMElements.achievementNotificationPopup.classList.add('show'); addMessage(`üèÜ Achievement: ${achievement.name}`, true); setTimeout(() => DOMElements.achievementNotificationPopup.classList.remove('show'), 4000); }
    function showAchievementsScreen() { let contentHtml = `<h2>Achievements</h2><div id="achievements-list">`;ACHIEVEMENTS_DATA.forEach(ach => { const isUnlocked = gameState.achievements.includes(ach.id); contentHtml += `<div class="item-slot ${isUnlocked ? '' : 'disabled'}" style="cursor:default;"><div class="item-icon">${isUnlocked ? 'üèÜ' : '‚ö™'}</div><div class="item-details"><div class="item-name">${ach.name}</div><div class="item-description">${ach.description}</div></div><div class="item-cost" style="color:${isUnlocked ? 'var(--success-color)' : 'var(--text-color)'};">${isUnlocked ? 'Unlocked' : 'Locked'}</div></div>`; }); contentHtml += `</div>`; DOMElements.genericOverlayContent.innerHTML = contentHtml; DOMElements.genericOverlayCloseButton.onclick = () => hideModal(DOMElements.genericOverlay); showModal(DOMElements.genericOverlay); }
    function showTutorial(startAtZero = false) { if (startAtZero) gameState.tutorial.step = 0; displayTutorialStep(); showModal(DOMElements.tutorialOverlay); }
    function displayTutorialStep() { const stepData = TUTORIAL_STEPS[gameState.tutorial.step]; DOMElements.tutorialTitle.textContent = stepData.title; DOMElements.tutorialBodyContent.innerHTML = `<p>${stepData.content.replace(/\n/g, '</p><p>')}</p>`; DOMElements.tutorialPrevButton.disabled = gameState.tutorial.step === 0; DOMElements.tutorialNextButton.style.display = gameState.tutorial.step === TUTORIAL_STEPS.length - 1 ? 'none' : 'flex'; DOMElements.tutorialCloseButton.style.display = gameState.tutorial.step === TUTORIAL_STEPS.length - 1 ? 'flex' : 'none'; }
    function nextTutorialStep() { if (gameState.tutorial.step < TUTORIAL_STEPS.length - 1) { gameState.tutorial.step++; displayTutorialStep(); } }
    function previousTutorialStep() { if (gameState.tutorial.step > 0) { gameState.tutorial.step--; displayTutorialStep(); } }
    function closeTutorial() { gameState.tutorial.complete = true; hideModal(DOMElements.tutorialOverlay); saveGame(true); }

    function checkForNewRaid(currentTime) { if (gameState.battle.isActive || gameState.activeRaids.length > 2) return; const ageData = AGES[gameState.age]; const timePlayedModifier = Math.min(2.5, 1 + (gameState.stats.timePlayed / 1200)); const raidChance = ageData.raidChanceBase * timePlayedModifier; if (Math.random() < raidChance) { spawnRaid(currentTime); } }
    function spawnRaid(currentTime) {
        gameState.stats.raidsSpawned++; 
        const ageData = AGES[gameState.age];
        const strengthPool = (50 + gameState.stats.timePlayed / 20 + gameState.stats.battlesWon * 8) * ageData.raidStrengthMod;
        const availableEnemyTypesForAge = Object.values(UNITS).filter(u => u.minAge <= gameState.age && u.maxAge >= Math.max(0,gameState.age-1));
        if(availableEnemyTypesForAge.length === 0) availableEnemyTypesForAge.push(UNITS.clubber);
    
        const composition = [];
        let currentStrengthForComp = 0;
        let tries = 0;
        while(currentStrengthForComp < strengthPool && tries < 10 && composition.length < 5) {
            const randomUnitDef = availableEnemyTypesForAge[Math.floor(Math.random() * availableEnemyTypesForAge.length)];
            const unitStr = (randomUnitDef.baseAttack + randomUnitDef.baseDefense + randomUnitDef.maxHp/5);
            const maxCountPossible = Math.floor((strengthPool - currentStrengthForComp) / Math.max(1,unitStr));
            if (maxCountPossible <=0) { tries++; continue;}
            const count = Math.max(1, Math.min(10, Math.floor(Math.random() * maxCountPossible) + 1));
            composition.push({ type: randomUnitDef.id, count: count, unitDef: randomUnitDef });
            currentStrengthForComp += count * unitStr;
            tries++;
        }
        if (composition.length === 0) { 
            const fallbackUnit = UNITS.clubber; 
            composition.push({type: fallbackUnit.id, count: Math.max(1,Math.floor(strengthPool / (fallbackUnit.baseAttack*2))), unitDef: fallbackUnit});
            currentStrengthForComp = (fallbackUnit.baseAttack*2) * composition[0].count;
        }
    
        const raidId = uniqueId('raid_');
        const raidName = `${AGES[gameState.age].name.split(" ")[0]} Marauders`;
        const raidIcon = ["üê∫","‚öîÔ∏è","üè¥‚Äç‚ò†Ô∏è","üë∫","üíÄ","üëΩ"][Math.min(gameState.age, 5)];
        
        gameState.activeRaids.push({ 
            id: raidId, name: raidName, icon: raidIcon, composition: composition, 
            arrivalTime: currentTime + RAID_BASE_DURATION_BEFORE_DESTRUCTION, 
            destructionStartTime: null, 
            timeToDestroyBuildingInterval: Math.max(15, 50 - gameState.age * 4), 
            currentTargetBuildingId: null, 
            strengthScore: Math.floor(currentStrengthForComp)
        });
    
        const startEdge = Math.floor(Math.random() * 4); 
        let startMapX, startMapY;
        switch(startEdge) {
            case 0: startMapX = gameState.map.ownedTilesX[0] - 3; startMapY = Math.floor(Math.random() * (gameState.map.ownedTilesY[1] - gameState.map.ownedTilesY[0] + 1)) + gameState.map.ownedTilesY[0]; break; 
            case 1: startMapX = gameState.map.ownedTilesX[1] + 3; startMapY = Math.floor(Math.random() * (gameState.map.ownedTilesY[1] - gameState.map.ownedTilesY[0] + 1)) + gameState.map.ownedTilesY[0]; break; 
            case 2: startMapX = Math.floor(Math.random() * (gameState.map.ownedTilesX[1] - gameState.map.ownedTilesX[0] + 1)) + gameState.map.ownedTilesX[0]; startMapY = gameState.map.ownedTilesY[0] - 3; break; 
            default: startMapX = Math.floor(Math.random() * (gameState.map.ownedTilesX[1] - gameState.map.ownedTilesX[0] + 1)) + gameState.map.ownedTilesX[0]; startMapY = gameState.map.ownedTilesY[1] + 3; break; 
        }

        gameState.mapEntities.raiders.push({
            id: uniqueId('raider_vis_'), raidId: raidId, icon: raidIcon, 
            gridX: startMapX, gridY: startMapY,
            targetGridX: null, targetGridY: null, speed: 0.05 + Math.random()*0.05,
            state: 'approaching', targetBuildingId: null
        });

        addMessage(`WARNING: ${raidName} ${raidIcon} are approaching! Intercept them!`, true);
        showNotification(`${raidName} detected!`, 'error', 5000);
        updateRaidAlertUI();
        renderGameView();
    }

    function processActiveRaids(currentTime) { 
        for (let i = gameState.activeRaids.length - 1; i >= 0; i--) {
            const raid = gameState.activeRaids[i];
            const raiderVisuals = gameState.mapEntities.raiders.filter(rv => rv.raidId === raid.id);

            if (raid.destructionStartTime && currentTime >= raid.destructionStartTime) {
                let targetBuildingToDamage = null;
                let engagedRaider = raiderVisuals.find(rv => rv.state === 'engaging_building' && rv.targetBuildingId);

                if (engagedRaider) {
                    targetBuildingToDamage = gameState.buildings.find(bldg => bldg.id === engagedRaider.targetBuildingId && bldg.isConstructed);
                }
    
                if (!targetBuildingToDamage && raiderVisuals.length > 0) {
                    const anyRaider = raiderVisuals[0]; 
                    let closestDist = Infinity;
                    const constructedBuildings = gameState.buildings.filter(b => b.isConstructed);
                    for(const b of constructedBuildings) {
                        const dist = Math.sqrt(Math.pow(anyRaider.gridX - b.gridX, 2) + Math.pow(anyRaider.gridY - b.gridY, 2));
                        if(dist < closestDist) {
                            closestDist = dist;
                            targetBuildingToDamage = b;
                        }
                    }
                }
                
                if (targetBuildingToDamage) {
                    const buildingDef = BUILDINGS[targetBuildingToDamage.type];
                    applyEffects(buildingDef, true); 
                    const buildingIndex = gameState.buildings.findIndex(b => b.id === targetBuildingToDamage.id);
                    if (buildingIndex !== -1) gameState.buildings.splice(buildingIndex, 1);

                    gameState.stats.buildingsLostToRaids++;
                    addMessage(`RAID DAMAGE! Your ${buildingDef.name} has been destroyed by ${raid.name}!`, true);
                    showNotification(`${buildingDef.name} destroyed by raiders!`, 'error');
                    loadAvailableBuildings();
                    renderGameView();
                    raid.destructionStartTime = currentTime + raid.timeToDestroyBuildingInterval; 
    
                    raiderVisuals.forEach(rv => {
                        if (rv.targetBuildingId === targetBuildingToDamage.id) {
                            rv.state = 'pillaging_area'; rv.targetBuildingId = null; rv.targetGridX = null;
                        }
                    });
                }
                
                if(gameState.buildings.filter(b=>b.isConstructed).length === 0) { 
                    addMessage(`${raid.name} have pillaged all they can and departed.`, true);
                    gameState.activeRaids.splice(i,1);
                    raiderVisuals.forEach(rv => rv.state = 'leaving');
                }

            } else if (!raid.destructionStartTime && currentTime >= raid.arrivalTime) {
                raid.destructionStartTime = currentTime + raid.timeToDestroyBuildingInterval;
                addMessage(`ALERT! ${raid.name} ${raid.icon} have reached your settlement and will begin pillaging!`, true);
                raiderVisuals.forEach(rv => { rv.state = 'pillaging_area'; rv.targetGridX = null; });
            }

            raiderVisuals.forEach(raiderVisual => {
                 if (raiderVisual.state === 'approaching' || raiderVisual.state === 'pillaging_area') {
                    if (raiderVisual.targetGridX === null || (Math.abs(raiderVisual.gridX - raiderVisual.targetGridX) < 0.5 && Math.abs(raiderVisual.gridY - raiderVisual.targetGridY) < 0.5)) {
                        raiderVisual.targetGridX = Math.floor(Math.random() * (gameState.map.ownedTilesX[1] - gameState.map.ownedTilesX[0] + 1)) + gameState.map.ownedTilesX[0];
                        raiderVisual.targetGridY = Math.floor(Math.random() * (gameState.map.ownedTilesY[1] - gameState.map.ownedTilesY[0] + 1)) + gameState.map.ownedTilesY[0];
                    }
                     const dx = raiderVisual.targetGridX - raiderVisual.gridX;
                     const dy = raiderVisual.targetGridY - raiderVisual.gridY;
                     const dist = Math.sqrt(dx*dx + dy*dy);
                     
                     let intendedNextGridX = raiderVisual.gridX;
                     let intendedNextGridY = raiderVisual.gridY;

                     if (dist > raiderVisual.speed) {
                         intendedNextGridX += (dx / dist) * raiderVisual.speed;
                         intendedNextGridY += (dy / dist) * raiderVisual.speed;
                     } else {
                         intendedNextGridX = raiderVisual.targetGridX;
                         intendedNextGridY = raiderVisual.targetGridY;
                     }
                     
                     const buildingAtIntendedNext = getBuildingAtGrid(Math.round(intendedNextGridX), Math.round(intendedNextGridY));

                     if (buildingAtIntendedNext && buildingAtIntendedNext.isConstructed && 
                         (Math.round(intendedNextGridX) !== Math.round(raiderVisual.gridX) || Math.round(intendedNextGridY) !== Math.round(raiderVisual.gridY))) {
                         if (raiderVisual.state !== 'engaging_building' || raiderVisual.targetBuildingId !== buildingAtIntendedNext.id) {
                             raiderVisual.state = 'engaging_building';
                             raiderVisual.targetBuildingId = buildingAtIntendedNext.id;
                         }
                     } else {
                         raiderVisual.gridX = intendedNextGridX;
                         raiderVisual.gridY = intendedNextGridY;
                         if (raiderVisual.state === 'engaging_building' && (!buildingAtIntendedNext || buildingAtIntendedNext.id !== raiderVisual.targetBuildingId)) {
                             raiderVisual.state = 'pillaging_area'; 
                             raiderVisual.targetBuildingId = null;
                             raiderVisual.targetGridX = null; 
                         }
                     }
                } else if (raiderVisual.state === 'leaving') {
                    raiderVisual.gridX += (raiderVisual.gridX > 0 ? 1 : -1) * raiderVisual.speed * 2;
                    raiderVisual.gridY += (raiderVisual.gridY > 0 ? 1 : -1) * raiderVisual.speed * 2;
                     if (Math.abs(raiderVisual.gridX) > MAX_MAP_GRID_DIM + 5 || Math.abs(raiderVisual.gridY) > MAX_MAP_GRID_DIM + 5) {
                        gameState.mapEntities.raiders = gameState.mapEntities.raiders.filter(rv => rv.id !== raiderVisual.id);
                    }
                }
            });
        }
        updateRaidAlertUI();
    }
    function updateRaidAlertUI() { if (gameState.activeRaids.length > 0) { DOMElements.raidAlertSection.style.display = 'block'; DOMElements.activeRaidsList.innerHTML = gameState.activeRaids.map(raid => { let statusText = "Approaching..."; if (raid.destructionStartTime && gameState.stats.timePlayed >= raid.destructionStartTime) statusText = "PILLAGING!"; else if (gameState.stats.timePlayed >= raid.arrivalTime) statusText = "ARRIVED!"; return `<div class="item-slot" style="border-left: 3px solid var(--error-color);"><div class="item-icon enemy-icon">${raid.icon}</div><div class="item-details"><div class="item-name">${raid.name} (Str: ${formatNumber(raid.strengthScore)})</div><div class="item-description">${statusText}</div></div><button class="game-button raid-alert-button" style="padding: 5px 10px; flex-grow:0; min-width: 100px;" onclick="interceptRaid('${raid.id}')">Intercept!</button></div>`; }).join(''); } else { DOMElements.raidAlertSection.style.display = 'none'; } }
    function interceptRaid(raidId) { const raid = gameState.activeRaids.find(r => r.id === raidId); if (raid && !gameState.battle.isActive) { if (countTotalPlayerUnits() === 0) { showNotification("You have no units to intercept the raid!", "error"); return; } const encounterDataForBattle = { id: raid.id, name: raid.name, description: "Hostile raiders attacking your settlement!", icon: raid.icon, composition: raid.composition, reward: Math.floor(raid.strengthScore * 0.5 + 50) }; initiateBattle(encounterDataForBattle, 'raid'); } else if(gameState.battle.isActive) { showNotification("Cannot intercept raid while another battle is in progress.", "info"); } }

    function saveGame(isAutoSave = false) { try { const stateToSave = JSON.parse(JSON.stringify(gameState)); if (stateToSave.battle.isActive) stateToSave.battle = getDefaultGameState().battle; localStorage.setItem(SAVE_GAME_KEY, JSON.stringify(stateToSave)); if (!isAutoSave) { showNotification("Game Saved!", 'success'); addMessage("Game progress saved."); } } catch (e) { console.error("Error saving game:", e); showNotification("Error saving. Storage full?", 'error'); } }
    function loadGame() { const savedData = localStorage.getItem(SAVE_GAME_KEY); if (savedData) { try { const loadedState = JSON.parse(savedData); if (loadedState.gameVersion?.split('.')[0] !== gameState.gameVersion?.split('.')[0] && !confirm("Saved game version mismatch likely. Load anyway? May cause issues.")) return; const defaultState = getDefaultGameState(); gameState = deepMerge(defaultState, loadedState); if (!gameState.battle.isActive) gameState.battle = defaultState.battle; if(!gameState.battle.agePowerCooldowns) gameState.battle.agePowerCooldowns = {}; if (!gameState.map) gameState.map = defaultState.map; if (!gameState.constructionQueue) gameState.constructionQueue = []; if (!gameState.mapEntities || !gameState.mapEntities.raiders) gameState.mapEntities = {raiders: []}; else { gameState.mapEntities.raiders = gameState.mapEntities.raiders || []; } if(!gameState.worldMap || !gameState.worldMap.outposts) gameState.worldMap = {outposts: [], deployedArmies: []}; else { gameState.worldMap.deployedArmies = gameState.worldMap.deployedArmies || []; } if (!gameState.map.ownedTilesX || !gameState.map.ownedTilesY) {gameState.map.ownedTilesX = [-5,5]; gameState.map.ownedTilesY = [-5,5];} if(!gameState.stats.mapExpansions) gameState.stats.mapExpansions = 0; if(gameState.map.nextExpansionCost === undefined) gameState.map.nextExpansionCost = 100 + gameState.stats.mapExpansions * 75; if(!gameState.map.discoveredTiles) gameState.map.discoveredTiles = {}; nextRaidCheckTime = gameState.stats.timePlayed + RAID_CHECK_INTERVAL / 1000;  showNotification("Game Loaded!", 'success'); addMessage("Game progress loaded."); loadAvailableBuildings(); loadAvailableUnits(); loadAvailableTechnologies(); updateAllUIDisplays(); renderGameView(); if (!gameState.tutorial.complete) showTutorial(); } catch (e) { console.error("Error loading game:", e); showNotification("Error loading. Corrupted data?", 'error'); localStorage.removeItem(SAVE_GAME_KEY); gameState = getDefaultGameState(); initGame(); } } else { showNotification("No saved game found.", 'info'); } }
    function deepMerge(target, source) { for (const key in source) { if (source.hasOwnProperty(key)) { if (source[key] instanceof Object && key in target && target[key] instanceof Object && !(source[key] instanceof Element) && !Array.isArray(source[key]) && key !== 'mapEntities' && key !== 'activeRaids' && key !== 'worldMap' ) { deepMerge(target[key], source[key]); } else if (Array.isArray(source[key])) { target[key] = source[key].map(item => typeof item === 'object' && item !== null ? deepMerge(Array.isArray(item) ? [] : {}, item) : item); } else { target[key] = source[key]; } } } return target; }


    function gridToScreen(gridX, gridY) {
        const isoX = (gridX - gridY) * TILE_WIDTH_ISO / 2;
        const isoY = (gridX + gridY) * TILE_HEIGHT_ISO / 2;
        return {
            x: DOMElements.gameCanvas.width / 2 + isoX - camera.x,
            y: DOMElements.gameCanvas.height / 2 + isoY - camera.y 
        };
    }

    function screenToGrid(screenX, screenY) {
        const adjScreenX = screenX - DOMElements.gameCanvas.width / 2 + camera.x;
        const adjScreenY = screenY - DOMElements.gameCanvas.height / 2 + camera.y;
        
        const gridX = Math.round((adjScreenX / (TILE_WIDTH_ISO / 2) + adjScreenY / (TILE_HEIGHT_ISO / 2)) / 2);
        const gridY = Math.round((adjScreenY / (TILE_HEIGHT_ISO / 2) - adjScreenX / (TILE_WIDTH_ISO / 2)) / 2);
        return { x: gridX, y: gridY };
    }
    
    function resizeCanvas() { 
        const c = DOMElements.gameCanvas.parentElement; 
        DOMElements.gameCanvas.width = c.clientWidth; 
        DOMElements.gameCanvas.height = c.clientHeight; 
        DOMElements.minimapCanvas.width = DOMElements.minimapContainer.clientWidth;
        DOMElements.minimapCanvas.height = DOMElements.minimapContainer.clientHeight;
        renderGameView(); 
    }
    
    function renderGameView() {
        if (!ctx) return;
        ctx.clearRect(0, 0, DOMElements.gameCanvas.width, DOMElements.gameCanvas.height);
        drawMainCanvasBackground(gameState.age);
        drawMapGrid();
        drawBuildingsOnMap();
        drawWorldOutposts();
        drawPlacementPreview();
        drawMapEntities();
        drawDeployedArmiesOnMap();
        drawMinimap();
    }

    function drawMainCanvasBackground(age) {
        const width = DOMElements.gameCanvas.width;
        const height = DOMElements.gameCanvas.height;
        let skyColor1, skyColor2, horizonDrawer;
    
        const ageStyles = [
            { sky1: '#6DD5FA', sky2: '#2980B9', horizon: drawForestHorizon },      
            { sky1: '#f5cba7', sky2: '#f9e79f', horizon: drawAncientHorizon },   
            { sky1: '#85929e', sky2: '#aeb6bf', horizon: drawMedievalHorizon },  
            { sky1: '#fad7a0', sky2: '#fdebd0', horizon: drawRenaissanceHorizon },
            { sky1: '#4a4e69', sky2: '#7d8ba9', horizon: drawIndustrialHorizon }, 
            { sky1: '#9db4c0', sky2: '#c5d8e0', horizon: drawModernHorizon },    
            { sky1: '#141e30', sky2: '#243b55', horizon: drawFutureHorizon }       
        ];
    
        const currentStyle = ageStyles[Math.min(age, ageStyles.length - 1)];
        skyColor1 = currentStyle.sky1;
        skyColor2 = currentStyle.sky2;
        horizonDrawer = currentStyle.horizon;
    
        const skyGradient = ctx.createLinearGradient(0, 0, 0, height * 0.65); 
        skyGradient.addColorStop(0, skyColor1);
        skyGradient.addColorStop(1, skyColor2);
        ctx.fillStyle = skyGradient;
        ctx.fillRect(0, 0, width, height);
    
        if (horizonDrawer) {
            horizonDrawer(height * 0.60, width); 
        }
        
        if (age >= 4) {
            ctx.save();
            for (let i = 0; i < (age > 5 ? 150: 70) ; i++) {
                const x = Math.random() * width;
                const y = Math.random() * height * 0.55; 
                const size = Math.random() * (age > 5 ? 2 : 1.5) + 0.5;
                ctx.fillStyle = age > 5 ? `hsla(${Math.random() * 60 + 200}, 100%, ${Math.random()*30+70}%, ${Math.random() * 0.8 + 0.3})` 
                                         : `rgba(255, 255, 240, ${Math.random() * 0.6 + 0.2})`;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.restore();
        }
        ctx.fillStyle = (age === 0 || age === 1 || (age >=5 && age % 2 !==0)) ? 'rgba(255, 245, 200, 0.95)' : 'rgba(235, 235, 255, 0.85)'; 
        ctx.beginPath();
        ctx.arc(width * (0.15 + ( (gameState.stats.timePlayed/60) % (width*0.7) ) / (width*0.7) * 0.7), height * 0.15, Math.min(width, height) * 0.035, 0, Math.PI * 2);
        ctx.fill();
    }
    
    function drawForestHorizon(horizonY, canvasWidth) {
        const treeColors = ['#1E4D2B', '#2A6F48', '#3B8C58', '#2E573C'];
        ctx.fillStyle = '#4A3B31'; 
        ctx.fillRect(0, horizonY, canvasWidth, DOMElements.gameCanvas.height - horizonY);

        function drawTree(x, y, height, width, color) {
            ctx.fillStyle = color;
            ctx.fillRect(x - width / 2, y - height * 0.3, width, height * 0.3); 
            ctx.beginPath();
            ctx.ellipse(x, y - height * 0.3, width * 1.2, height * 0.7, 0, 0, Math.PI * 2);
            ctx.fill();
        }
        for (let layer = 0; layer < 3; layer++) {
            const numTrees = 20 - layer * 5;
            const treeMaxHeight = 80 - layer * 20;
            const treeMaxWidth = 15 - layer * 3;
            const yOffset = layer * 15;
            for (let i = 0; i < numTrees; i++) {
                const x = Math.random() * canvasWidth;
                const h = Math.random() * (treeMaxHeight * 0.5) + (treeMaxHeight * 0.5);
                const w = Math.random() * (treeMaxWidth * 0.5) + (treeMaxWidth * 0.5);
                drawTree(x, horizonY + yOffset - h / 2, h, w, treeColors[layer % treeColors.length]);
            }
        }
    }
    function drawAncientHorizon(horizonY, canvasWidth) { drawDesertDunes(horizonY, '#D2B48C', canvasWidth); drawPyramidsSimple(horizonY, '#B8860B', canvasWidth); }
    function drawMedievalHorizon(horizonY, canvasWidth) { drawMountains(horizonY, '#4A3B50', canvasWidth, 0.2, 0.08); drawSimpleCastleSilhouettes(horizonY, '#3E3248', canvasWidth); }
    function drawRenaissanceHorizon(horizonY, canvasWidth) { drawRollingHills(horizonY, '#8FBC8F', canvasWidth); drawSimpleTownSilhouettes(horizonY, '#556B2F', canvasWidth); }
    function drawIndustrialHorizon(horizonY, canvasWidth) { drawFlatCityScape(horizonY, '#3E4A52', canvasWidth); drawSmokeStacks(horizonY, '#2C373D', canvasWidth); }
    function drawModernHorizon(horizonY, canvasWidth) { drawModernSkyline(horizonY, '#52606E', canvasWidth); }
    function drawFutureHorizon(horizonY, canvasWidth) { drawFuturisticDomes(horizonY, '#3A7CA5', canvasWidth); drawFloatingStructures(horizonY, '#5E90AE', canvasWidth); }

    function drawMountains(horizonY, color, canvasWidth, maxHeightFactor, minHeightFactor) { ctx.fillStyle = color; ctx.beginPath(); ctx.moveTo(0, horizonY); let x = 0; while(x < canvasWidth) { const h = Math.random() * (DOMElements.gameCanvas.height * maxHeightFactor) + (DOMElements.gameCanvas.height * minHeightFactor); const peakX = x + Math.random() * (canvasWidth*0.15) + (canvasWidth*0.05); ctx.lineTo(peakX, horizonY - h); x = peakX + Math.random() * (canvasWidth*0.05); ctx.lineTo(Math.min(canvasWidth, x), horizonY); } ctx.lineTo(canvasWidth, DOMElements.gameCanvas.height); ctx.lineTo(0, DOMElements.gameCanvas.height); ctx.closePath(); ctx.fill(); }
    function drawDesertDunes(horizonY, color, canvasWidth) { ctx.fillStyle = color; ctx.beginPath(); ctx.moveTo(0, horizonY); for (let x = 0; x < canvasWidth; x += 50) { ctx.quadraticCurveTo(x + 25, horizonY - (Math.random() * 30 + 10), x + 50, horizonY); } ctx.lineTo(canvasWidth, DOMElements.gameCanvas.height); ctx.lineTo(0, DOMElements.gameCanvas.height); ctx.closePath(); ctx.fill(); }
    function drawPyramidsSimple(horizonY, color, canvasWidth) { ctx.fillStyle = color; ctx.beginPath(); ctx.moveTo(canvasWidth * 0.3, horizonY); ctx.lineTo(canvasWidth * 0.4, horizonY - 80); ctx.lineTo(canvasWidth * 0.5, horizonY); ctx.closePath(); ctx.fill(); ctx.beginPath(); ctx.moveTo(canvasWidth * 0.6, horizonY); ctx.lineTo(canvasWidth * 0.65, horizonY - 50); ctx.lineTo(canvasWidth * 0.7, horizonY); ctx.closePath(); ctx.fill();}
    function drawSimpleCastleSilhouettes(horizonY, color, canvasWidth) { ctx.fillStyle = color; ctx.fillRect(canvasWidth*0.2, horizonY - 60, 40, 60); ctx.fillRect(canvasWidth*0.2+10, horizonY - 80, 20, 20); ctx.fillRect(canvasWidth*0.7, horizonY - 80, 60, 80); ctx.fillRect(canvasWidth*0.7+5, horizonY - 100, 15, 20); ctx.fillRect(canvasWidth*0.7+40, horizonY - 100, 15, 20); }
    function drawRollingHills(horizonY, color, canvasWidth) { ctx.fillStyle = color; ctx.beginPath(); ctx.moveTo(0, horizonY); for (let x = 0; x < canvasWidth; x += 100) { ctx.quadraticCurveTo(x + 50, horizonY - (Math.random() * 40 + 20), x + 100, horizonY - (Math.random()*10)); }  ctx.lineTo(canvasWidth, DOMElements.gameCanvas.height); ctx.lineTo(0, DOMElements.gameCanvas.height); ctx.closePath(); ctx.fill(); }
    function drawSimpleTownSilhouettes(horizonY, color, canvasWidth) { ctx.fillStyle = color; for(let i=0; i<10; i++){ let x = Math.random() * canvasWidth * 0.8 + canvasWidth * 0.1; let h = Math.random()*30+20; let w = Math.random()*20+15; ctx.fillRect(x, horizonY - h, w, h); if(Math.random() > 0.5) {ctx.beginPath(); ctx.moveTo(x, horizonY-h); ctx.lineTo(x+w/2, horizonY-h-10); ctx.lineTo(x+w, horizonY-h); ctx.closePath(); ctx.fill();}}}
    function drawFlatCityScape(horizonY, color, canvasWidth) { ctx.fillStyle = color; ctx.fillRect(0, horizonY - 20, canvasWidth, 20); }
    function drawSmokeStacks(horizonY, color, canvasWidth) { ctx.fillStyle = color; for (let i = 0; i < 5; i++) { const x = Math.random() * canvasWidth; const h = Math.random() * 40 + 30; ctx.fillRect(x, horizonY - h, 10, h); ctx.beginPath(); ctx.ellipse(x+5, horizonY - h -10, 8, 3,0,0, Math.PI*2); ctx.fillStyle = lightenColor(color, 20); ctx.fill(); } }
    function drawModernSkyline(horizonY, color, canvasWidth) { ctx.fillStyle = color; for (let i = 0; i < 15; i++) { const x = Math.random() * canvasWidth; const h = Math.random() * 80 + 40; const w = Math.random() * 30 + 10; ctx.fillRect(x, horizonY - h, w, h); } }
    function drawFuturisticDomes(horizonY, color, canvasWidth) { ctx.fillStyle = color; for (let i = 0; i < 3; i++) { const x = canvasWidth * (0.2 + i * 0.3) + (Math.random()-0.5)*50; const r = Math.random() * 50 + 30; ctx.beginPath(); ctx.arc(x, horizonY, r, Math.PI, 0); ctx.fill(); } }
    function drawFloatingStructures(horizonY, color, canvasWidth) { ctx.fillStyle = color; for (let i = 0; i < 4; i++) { const x = Math.random() * canvasWidth; const yOff = Math.random() * 30 + 20; const w = Math.random() * 40 + 20; const h = Math.random() * 20 + 10; ctx.fillRect(x, horizonY - h - yOff, w, h); } }


    function drawMapGrid() {
        const gridLineColor = getComputedStyle(document.documentElement).getPropertyValue('--map-grid-line-color').trim();
        const mapTileColor = getComputedStyle(document.documentElement).getPropertyValue('--map-tile-color').trim();
        const mapTileBorder = getComputedStyle(document.documentElement).getPropertyValue('--map-tile-border').trim();

        const viewBounds = {
            minGridX: screenToGrid(0,0).x - 5, maxGridX: screenToGrid(DOMElements.gameCanvas.width, DOMElements.gameCanvas.height).x + 5,
            minGridY: screenToGrid(DOMElements.gameCanvas.width,0).y - 5, maxGridY: screenToGrid(0,DOMElements.gameCanvas.height).y + 5,
        };
        
        const sortedTiles = [];
        const minX = Math.max(gameState.map.ownedTilesX[0], viewBounds.minGridX - 10); // expand render slightly for undiscovered edges
        const maxX = Math.min(gameState.map.ownedTilesX[1], viewBounds.maxGridX + 10);
        const minY = Math.max(gameState.map.ownedTilesY[0], viewBounds.minGridY - 10);
        const maxY = Math.min(gameState.map.ownedTilesY[1], viewBounds.maxGridY + 10);

        for (let gy = minY ; gy <= maxY; gy++) {
            for (let gx = minX; gx <= maxX; gx++) {
                 if (!isTileOwned(gx,gy) && !isTileDiscovered(gx,gy) && !gameState.placement.isPlacing) continue; // only draw owned or discovered (unless placing)
                 sortedTiles.push({gx, gy});
            }
        }
        sortedTiles.sort((a,b) => (a.gx + a.gy) - (b.gx + b.gy) || a.gy - b.gy);


        sortedTiles.forEach(tile => {
            const tileTopVertex = gridToScreen(tile.gx, tile.gy);
            ctx.beginPath();
            ctx.moveTo(tileTopVertex.x, tileTopVertex.y);
            ctx.lineTo(tileTopVertex.x + TILE_WIDTH_ISO / 2, tileTopVertex.y + TILE_HEIGHT_ISO / 2);
            ctx.lineTo(tileTopVertex.x, tileTopVertex.y + TILE_HEIGHT_ISO);
            ctx.lineTo(tileTopVertex.x - TILE_WIDTH_ISO / 2, tileTopVertex.y + TILE_HEIGHT_ISO / 2);
            ctx.closePath();
            
            if (isTileOwned(tile.gx, tile.gy)) {
                ctx.fillStyle = mapTileColor;
                ctx.fill();
                ctx.strokeStyle = mapTileBorder;
            } else if (isTileDiscovered(tile.gx, tile.gy)) {
                ctx.fillStyle = lightenColor(mapTileColor, -30); // Darker for discovered but not owned
                ctx.fill();
                ctx.strokeStyle = darkenColor(mapTileBorder, 20);
            } else {
                return; // Should not happen with the loop condition
            }
            ctx.lineWidth = 1;
            ctx.stroke();

             if (gameState.placement.isPlacing && isTileOwned(tile.gx, tile.gy)) {
                ctx.strokeStyle = gridLineColor;
                ctx.lineWidth = 0.5;
                ctx.stroke();
            }
        });
    }

    function drawBuildingsOnMap() {
        const buildingsToDraw = [...gameState.buildings].sort((a, b) => (a.gridX + a.gridY) - (b.gridX + b.gridY) || a.gridY - b.gridY);

        buildingsToDraw.forEach(building => {
            const buildingDef = BUILDINGS[building.type];
            if (!buildingDef) return;
            if (!isTileDiscovered(building.gridX, building.gridY) && !isTileDiscovered(building.gridX + building.sizeX -1, building.gridY + building.sizeY -1 )) return;
    
            const buildingAnchorTopVertex = gridToScreen(building.gridX, building.gridY);
            const buildingVisualHeight = TILE_HEIGHT_ISO * 0.5 + (Math.max(buildingDef.sizeX, buildingDef.sizeY)-1)*TILE_HEIGHT_ISO*0.2 + (buildingDef.sizeX + buildingDef.sizeY -2)*TILE_HEIGHT_ISO*0.1; 
            
            const topSurfaceOriginX = buildingAnchorTopVertex.x;
            const topSurfaceOriginY = buildingAnchorTopVertex.y - buildingVisualHeight;
    
            ctx.fillStyle = buildingDef.color || '#555';
            ctx.globalAlpha = building.isConstructed ? 1 : (0.4 + building.progress/building.totalTime * 0.3);
            
            ctx.beginPath(); 
            ctx.moveTo(topSurfaceOriginX, topSurfaceOriginY); 
            ctx.lineTo(topSurfaceOriginX + (TILE_WIDTH_ISO / 2 * buildingDef.sizeX), topSurfaceOriginY + (TILE_HEIGHT_ISO / 2 * buildingDef.sizeX)); 
            ctx.lineTo(topSurfaceOriginX + (TILE_WIDTH_ISO / 2 * (buildingDef.sizeX - buildingDef.sizeY)) , topSurfaceOriginY + (TILE_HEIGHT_ISO / 2 * (buildingDef.sizeX + buildingDef.sizeY)) ); 
            ctx.lineTo(topSurfaceOriginX - (TILE_WIDTH_ISO / 2 * buildingDef.sizeY), topSurfaceOriginY + (TILE_HEIGHT_ISO / 2 * buildingDef.sizeY)); 
            ctx.closePath();
            ctx.fill();
            ctx.strokeStyle = darkenColor(buildingDef.color, 20);
            ctx.stroke();
            
            ctx.beginPath(); 
            ctx.moveTo(topSurfaceOriginX, topSurfaceOriginY);
            ctx.lineTo(topSurfaceOriginX + (TILE_WIDTH_ISO / 2 * buildingDef.sizeX), topSurfaceOriginY + (TILE_HEIGHT_ISO / 2 * buildingDef.sizeX));
            ctx.lineTo(topSurfaceOriginX + (TILE_WIDTH_ISO / 2 * buildingDef.sizeX), topSurfaceOriginY + (TILE_HEIGHT_ISO / 2 * buildingDef.sizeX) + buildingVisualHeight);
            ctx.lineTo(topSurfaceOriginX, topSurfaceOriginY + buildingVisualHeight);
            ctx.closePath();
            ctx.fillStyle = darkenColor(buildingDef.color, 10);
            ctx.fill();
            ctx.stroke();
            
            ctx.beginPath(); 
            ctx.moveTo(topSurfaceOriginX - (TILE_WIDTH_ISO / 2 * buildingDef.sizeY), topSurfaceOriginY + (TILE_HEIGHT_ISO / 2 * buildingDef.sizeY)); 
            ctx.lineTo(topSurfaceOriginX + (TILE_WIDTH_ISO / 2 * (buildingDef.sizeX - buildingDef.sizeY)) , topSurfaceOriginY + (TILE_HEIGHT_ISO / 2 * (buildingDef.sizeX + buildingDef.sizeY)) ); 
            ctx.lineTo(topSurfaceOriginX + (TILE_WIDTH_ISO / 2 * (buildingDef.sizeX - buildingDef.sizeY)) , topSurfaceOriginY + (TILE_HEIGHT_ISO / 2 * (buildingDef.sizeX + buildingDef.sizeY)) + buildingVisualHeight);
            ctx.lineTo(topSurfaceOriginX - (TILE_WIDTH_ISO / 2 * buildingDef.sizeY), topSurfaceOriginY + (TILE_HEIGHT_ISO / 2 * buildingDef.sizeY) + buildingVisualHeight);
            ctx.closePath();
            ctx.fillStyle = lightenColor(buildingDef.color, 10);
            ctx.fill();
            ctx.stroke();

            ctx.globalAlpha = 1;
            const iconSize = TILE_HEIGHT_ISO*0.4 * Math.min(buildingDef.sizeX, buildingDef.sizeY, 1.8);
            ctx.font = `${iconSize}px Sans-serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = 'white';
            const topFaceCenterX = topSurfaceOriginX + (TILE_WIDTH_ISO / 4 * (buildingDef.sizeX - buildingDef.sizeY));
            const topFaceCenterY = topSurfaceOriginY + (TILE_HEIGHT_ISO / 4 * (buildingDef.sizeX + buildingDef.sizeY));
            ctx.fillText(buildingDef.icon, topFaceCenterX, topFaceCenterY);
    
            if (!building.isConstructed || (building.isPlaceholder && building.progress < building.totalTime)) {
                const progress = building.progress / building.totalTime;
                const barWidth = TILE_WIDTH_ISO * 0.4 * Math.max(buildingDef.sizeX, buildingDef.sizeY);
                const barHeight = 6;
                const barX = topFaceCenterX - barWidth / 2;
                const barY = topFaceCenterY + iconSize * 0.6;
    
                ctx.fillStyle = '#333';
                ctx.fillRect(barX, barY, barWidth, barHeight);
                ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--accent-color').trim();
                ctx.fillRect(barX, barY, barWidth * progress, barHeight);
                ctx.strokeStyle = '#111';
                ctx.strokeRect(barX, barY, barWidth, barHeight);
            }
        });
    }
    function darkenColor(hex, percent) {
        hex = hex.replace(/^\s*#|\s*$/g, '');
        if(hex.length == 3){
            hex = hex.replace(/(.)/g, '$1$1');
        }
        var r = parseInt(hex.substr(0, 2), 16),
            g = parseInt(hex.substr(2, 2), 16),
            b = parseInt(hex.substr(4, 2), 16);
    
        r = Math.max(0, Math.min(255, r - Math.floor(255 * percent / 100)));
        g = Math.max(0, Math.min(255, g - Math.floor(255 * percent / 100)));
        b = Math.max(0, Math.min(255, b - Math.floor(255 * percent / 100)));
    
        return '#' + r.toString(16).padStart(2, '0') + g.toString(16).padStart(2, '0') + b.toString(16).padStart(2, '0');
    }
    function lightenColor(hex, percent) {
        return darkenColor(hex, -percent);
    }


    function drawPlacementPreview() {
        if (!gameState.placement.isPlacing || !gameState.placement.buildingId || mouseGridPos.x === -1) return;
    
        const buildingDef = BUILDINGS[gameState.placement.buildingId];
        if (!buildingDef) return;
    
        const finalPlaceX = mouseGridPos.x;
        const finalPlaceY = mouseGridPos.y;

        const isValid = canPlaceBuilding(buildingDef, finalPlaceX, finalPlaceY);
        gameState.placement.validPlacement = isValid; 
    
        ctx.globalAlpha = 0.5;
        for (let y = 0; y < buildingDef.sizeY; y++) {
            for (let x = 0; x < buildingDef.sizeX; x++) {
                const currentTileX = finalPlaceX + x;
                const currentTileY = finalPlaceY + y;
                const tileTopVertex = gridToScreen(currentTileX, currentTileY);
    
                ctx.beginPath();
                ctx.moveTo(tileTopVertex.x, tileTopVertex.y);
                ctx.lineTo(tileTopVertex.x + TILE_WIDTH_ISO / 2, tileTopVertex.y + TILE_HEIGHT_ISO / 2);
                ctx.lineTo(tileTopVertex.x, tileTopVertex.y + TILE_HEIGHT_ISO);
                ctx.lineTo(tileTopVertex.x - TILE_WIDTH_ISO / 2, tileTopVertex.y + TILE_HEIGHT_ISO / 2);
                ctx.closePath();
                ctx.fillStyle = isValid ? getComputedStyle(document.documentElement).getPropertyValue('--building-placeholder-valid').trim() 
                                        : getComputedStyle(document.documentElement).getPropertyValue('--building-placeholder-invalid').trim();
                ctx.fill();
            }
        }
        ctx.globalAlpha = 1;
    }
    
    function drawMapEntities() {
        const entitiesToDraw = [...gameState.mapEntities.raiders].sort((a,b) => (a.gridX + a.gridY) - (b.gridX + b.gridY) || a.gridY - b.gy);

        entitiesToDraw.forEach(raider => {
            if(!isTileDiscovered(Math.round(raider.gridX), Math.round(raider.gridY))) return;

            const screenPos = gridToScreen(raider.gridX, raider.gridY);
            ctx.font = `${TILE_HEIGHT_ISO*0.6}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            const raidInfo = gameState.activeRaids.find(r => r.id === raider.raidId);
            if (raidInfo) {
                ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--error-color').trim();
                ctx.globalAlpha = 0.7;
                ctx.beginPath();
                ctx.ellipse(screenPos.x, screenPos.y + TILE_HEIGHT_ISO * 0.4, TILE_WIDTH_ISO*0.2, TILE_HEIGHT_ISO*0.15, 0, 0, Math.PI * 2); 
                ctx.fill();
                ctx.globalAlpha = 1;

                ctx.fillStyle = 'white';
                ctx.fillText(raider.icon, screenPos.x, screenPos.y);
                
                if (raider.state === 'engaging_building' && raider.targetBuildingId) {
                     ctx.strokeStyle = 'rgba(231, 76, 60, 0.7)'; 
                     ctx.lineWidth = 3;
                     ctx.beginPath();
                     ctx.moveTo(screenPos.x, screenPos.y); 
                     const targetBuilding = gameState.buildings.find(b => b.id === raider.targetBuildingId);
                     if(targetBuilding) {
                        const buildingDef = BUILDINGS[targetBuilding.type];
                        const targetAnchorTopVertex = gridToScreen(targetBuilding.gridX, targetBuilding.gridY);
                        const targetVisualHeight = TILE_HEIGHT_ISO * 0.5 + (Math.max(buildingDef.sizeX, buildingDef.sizeY)-1)*TILE_HEIGHT_ISO*0.2 + (buildingDef.sizeX + buildingDef.sizeY -2)*TILE_HEIGHT_ISO*0.1; 
                        const targetTopFaceOriginY = targetAnchorTopVertex.y - targetVisualHeight;
                        const targetTopFaceCenterX = targetAnchorTopVertex.x + (TILE_WIDTH_ISO / 4 * (buildingDef.sizeX - buildingDef.sizeY));
                        const targetTopFaceCenterY = targetTopFaceOriginY + (TILE_HEIGHT_ISO / 4 * (buildingDef.sizeX + buildingDef.sizeY));

                        ctx.lineTo(targetTopFaceCenterX, targetTopFaceCenterY);
                        ctx.stroke();
                        
                        ctx.fillStyle = 'rgba(255,0,0,0.2)';
                        ctx.beginPath();
                        ctx.arc(screenPos.x, screenPos.y, 15 + Math.sin(gameState.stats.timePlayed*5)*3, 0, Math.PI*2);
                        ctx.fill();

                     }
                }
            }
        });
    }

    function handleCanvasMouseMove(event) {
        const rect = DOMElements.gameCanvas.getBoundingClientRect();
        const mouseX = event.clientX - rect.left;
        const mouseY = event.clientY - rect.top;

        if (isPanning) {
            camera.x -= (mouseX - panStartX);
            camera.y -= (mouseY - panStartY);
            panStartX = mouseX;
            panStartY = mouseY;
            renderGameView();
            return;
        }

        if (gameState.placement.isPlacing) {
             mouseGridPos = screenToGrid(mouseX, mouseY);
             renderGameView();
        }
    }
    
    function handleCanvasClick(event) {
        const rect = DOMElements.gameCanvas.getBoundingClientRect();
        const clickX = event.clientX - rect.left;
        const clickY = event.clientY - rect.top;
        const clickedGridPos = screenToGrid(clickX, clickY);

        if (gameState.placement.isPlacing && gameState.placement.buildingId) {
            attemptPlaceBuilding(clickedGridPos.x, clickedGridPos.y);
        } else {
             const clickedOutpost = gameState.worldMap.outposts.find(outpost => 
                !outpost.isDefeated && outpost.isDiscovered &&
                clickedGridPos.x >= outpost.gridX && clickedGridPos.x < outpost.gridX + 1 &&
                clickedGridPos.y >= outpost.gridY && clickedGridPos.y < outpost.gridY + 1 
             );
             if (clickedOutpost) {
                openWorldMapOutpostInteractionModal(clickedOutpost);
                return;
             }
        }
    }

    function mainGameLoop() { const deltaTime = 1; const currentTime = gameState.stats.timePlayed; gameState.stats.timePlayed += deltaTime; gameState.resources.gold += getCalculatedIncome() * deltaTime; gameState.resources.technologyPoints += getCalculatedTechRate() * deltaTime; if (gameState.currentResearch.id) { gameState.currentResearch.progress += deltaTime; if (gameState.currentResearch.progress >= gameState.currentResearch.timeToComplete) completeResearch(); } processTrainingQueue(deltaTime); processConstructionQueue(deltaTime); if (currentTime >= nextRaidCheckTime) { checkForNewRaid(currentTime); nextRaidCheckTime = currentTime + RAID_CHECK_INTERVAL / 1000; } processActiveRaids(currentTime); processDeployedArmies(deltaTime); if (!gameState.battle.isActive) { updateAllUIDisplays(); renderGameView(); } else { updateResourceDisplays(); updateRaidAlertUI(); renderBattleUI(); } if (gameState.stats.timePlayed > 0 && gameState.stats.timePlayed % 90 === 0) { saveGame(true); addMessage("Game autosaved.", false); }}
    function initEventListeners() { 
        window.addEventListener('resize', resizeCanvas); 
        DOMElements.gameCanvas.addEventListener('mousemove', handleCanvasMouseMove); 
        DOMElements.gameCanvas.addEventListener('click', handleCanvasClick); 
        DOMElements.gameCanvas.addEventListener('mousedown', (e) => { if (e.button === 0 && !gameState.placement.isPlacing) {isPanning = true; DOMElements.gameCanvasContainer.classList.add('grabbing'); panStartX = e.clientX - DOMElements.gameCanvas.getBoundingClientRect().left; panStartY = e.clientY - DOMElements.gameCanvas.getBoundingClientRect().top;} });
        window.addEventListener('mouseup', (e) => { if (e.button === 0) {isPanning = false; DOMElements.gameCanvasContainer.classList.remove('grabbing');} });
        DOMElements.gameCanvas.addEventListener('mouseleave', () => {isPanning = false; DOMElements.gameCanvasContainer.classList.remove('grabbing');});
        DOMElements.backToBaseButton.addEventListener('click', () => {camera.x = 0; camera.y = -(DOMElements.gameCanvas.height / 3); renderGameView(); DOMElements.backToBaseButton.style.display = 'none';});


        DOMElements.cancelPlacementButton.addEventListener('click', cancelPlacementMode); 
        DOMElements.expandLandNorthButton.addEventListener('click', () => expandMap('N')); DOMElements.expandLandSouthButton.addEventListener('click', () => expandMap('S')); DOMElements.expandLandWestButton.addEventListener('click', () => expandMap('W')); DOMElements.expandLandEastButton.addEventListener('click', () => expandMap('E')); 
        DOMElements.saveButton.addEventListener('click', () => saveGame(false)); DOMElements.loadButton.addEventListener('click', loadGame); 
        DOMElements.tutorialButton.addEventListener('click', () => showTutorial(true)); DOMElements.tutorialForceCloseButton.addEventListener('click', closeTutorial); DOMElements.tutorialPrevButton.addEventListener('click', previousTutorialStep); DOMElements.tutorialNextButton.addEventListener('click', nextTutorialStep); DOMElements.tutorialCloseButton.addEventListener('click', closeTutorial); 
        DOMElements.achievementsButton.addEventListener('click', showAchievementsScreen); DOMElements.advanceAgeButton.addEventListener('click', advanceAge); DOMElements.battleButton.addEventListener('click', findEnemies); 
        DOMElements.upgradePanelCloseButton.addEventListener('click', () => hideModal(DOMElements.upgradePanelOverlay)); 
        DOMElements.genericOverlayCloseButton.addEventListener('click', () => hideModal(DOMElements.genericOverlay)); 
        DOMElements.worldMapOutpostModalCloseButton.addEventListener('click', () => hideModal(DOMElements.worldMapOutpostInteractionModal));
        DOMElements.battleModalCloseButton.addEventListener('click', () => { if(gameState.battle.isActive) { addBattleLogEntry("Battle manually closed - Conceded."); endBattle(false);} hideModal(DOMElements.battleModalOverlay); }); DOMElements.tabButtons.forEach(tab => { tab.addEventListener('click', () => { DOMElements.tabButtons.forEach(t => t.classList.remove('active')); DOMElements.tabContents.forEach(c => c.classList.remove('active')); tab.classList.add('active'); document.getElementById(`${tab.dataset.tab}-tab-content`).classList.add('active'); }); }); document.body.addEventListener('mouseover', displayTooltip); setupBattleActionListeners(); }
    function initGame() { gameState = getDefaultGameState(); ctx = DOMElements.gameCanvas.getContext('2d'); minimapCtx = DOMElements.minimapCanvas.getContext('2d'); initEventListeners(); resizeCanvas(); camera.x = 0; camera.y = -(DOMElements.gameCanvas.height / 3); discoverArea(BASE_LOCATION_GRID.x, BASE_LOCATION_GRID.y, 8); generateWorldOutpostsIfNeeded(); loadAvailableBuildings(); loadAvailableUnits(); loadAvailableTechnologies(); updateAllUIDisplays(); renderGameView(); nextRaidCheckTime = gameState.stats.timePlayed + RAID_CHECK_INTERVAL / 1000; if (!localStorage.getItem(SAVE_GAME_KEY)) { if(!gameState.tutorial.complete) showTutorial(); } else { loadGame(); } gameLoopIntervalId = setInterval(mainGameLoop, 1000); achievementCheckIntervalId = setInterval(checkAchievements, 5000); addMessage(`Welcome to Age of Empire Tycoon ${gameState.gameVersion}! Forge your destiny.`, true); }
    document.addEventListener('DOMContentLoaded', initGame);

    function drawWorldOutposts() {
        gameState.worldMap.outposts.forEach(outpost => {
            if (!outpost.isDiscovered || outpost.isDefeated) return;
    
            const screenPos = gridToScreen(outpost.gridX, outpost.gridY);
            ctx.font = `${TILE_HEIGHT_ISO * 0.7}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
    
            
            ctx.fillStyle = 'rgba(100, 20, 20, 0.7)'; 
            ctx.beginPath();
            ctx.ellipse(screenPos.x, screenPos.y + TILE_HEIGHT_ISO * 0.4, TILE_WIDTH_ISO * 0.3, TILE_HEIGHT_ISO * 0.2, 0, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = outpost.isDefeated ? '#555' : '#e74c3c';
            ctx.fillText(outpost.icon || 'üìç', screenPos.x, screenPos.y);
    
            if (outpost.name && isTileDiscovered(outpost.gridX, outpost.gridY)) { 
                 const distanceToPlayerBase = Math.sqrt(Math.pow(outpost.gridX - BASE_LOCATION_GRID.x, 2) + Math.pow(outpost.gridY - BASE_LOCATION_GRID.y, 2));
                ctx.font = '10px Arial';
                ctx.fillStyle = 'white';
                 if (distanceToPlayerBase < 15) { // Show strength if close
                    ctx.fillText(`${outpost.name} (Str: ${formatNumber(outpost.strength)})`, screenPos.x, screenPos.y - TILE_HEIGHT_ISO * 0.7);
                } else {
                    ctx.fillText(`${outpost.name} (Unknown Strength)`, screenPos.x, screenPos.y - TILE_HEIGHT_ISO * 0.7);
                }
            }
        });
    }

    function drawMinimap() {
        if (!minimapCtx) return;
        const mapWidth = DOMElements.minimapCanvas.width;
        const mapHeight = DOMElements.minimapCanvas.height;
    
        minimapCtx.clearRect(0, 0, mapWidth, mapHeight);
        minimapCtx.fillStyle = 'rgba(10,20,30,0.8)';
        minimapCtx.fillRect(0,0,mapWidth,mapHeight);

        const mapCenterX = mapWidth / 2;
        const mapCenterY = mapHeight / 2;

        const playerViewCenterX = camera.x / (TILE_WIDTH_ISO/2); 
        const playerViewCenterY = camera.y / (TILE_HEIGHT_ISO/2);
    
        Object.keys(gameState.map.discoveredTiles).forEach(key => {
            const [gx, gy] = key.split(',').map(Number);
            const tileMiniX = mapCenterX + (gx - playerViewCenterX) * MINIMAP_PIXEL_PER_TILE;
            const tileMiniY = mapCenterY + (gy - playerViewCenterY) * MINIMAP_PIXEL_PER_TILE;
    
            if (tileMiniX < -MINIMAP_PIXEL_PER_TILE || tileMiniX > mapWidth || tileMiniY < -MINIMAP_PIXEL_PER_TILE || tileMiniY > mapHeight) return;
    
            if (isTileOwned(gx, gy)) {
                minimapCtx.fillStyle = 'rgba(46, 204, 113, 0.6)'; // Green for owned
            } else {
                minimapCtx.fillStyle = 'rgba(52, 73, 94, 0.4)'; // Darker for discovered not owned
            }
            minimapCtx.fillRect(tileMiniX, tileMiniY, MINIMAP_PIXEL_PER_TILE, MINIMAP_PIXEL_PER_TILE);
        });
    
        gameState.worldMap.outposts.forEach(outpost => {
            if (outpost.isDiscovered && !outpost.isDefeated) {
                const outpostMiniX = mapCenterX + (outpost.gridX - playerViewCenterX) * MINIMAP_PIXEL_PER_TILE;
                const outpostMiniY = mapCenterY + (outpost.gridY - playerViewCenterY) * MINIMAP_PIXEL_PER_TILE;
                if (outpostMiniX < -MINIMAP_PIXEL_PER_TILE*2 || outpostMiniX > mapWidth || outpostMiniY < -MINIMAP_PIXEL_PER_TILE*2 || outpostMiniY > mapHeight) return;
                minimapCtx.fillStyle = 'red';
                minimapCtx.fillRect(outpostMiniX -1, outpostMiniY-1, MINIMAP_PIXEL_PER_TILE+2, MINIMAP_PIXEL_PER_TILE+2);
            }
        });
    
        // Player view rectangle on minimap
        const viewRectWidth = DOMElements.gameCanvas.width / (TILE_WIDTH_ISO/2) * MINIMAP_PIXEL_PER_TILE / 2; // Approximate conversion
        const viewRectHeight = DOMElements.gameCanvas.height / (TILE_HEIGHT_ISO/2) * MINIMAP_PIXEL_PER_TILE / 2;
        minimapCtx.strokeStyle = 'yellow';
        minimapCtx.lineWidth = 1;
        minimapCtx.strokeRect(mapCenterX - viewRectWidth/2, mapCenterY - viewRectHeight/2, viewRectWidth, viewRectHeight);
        
        // Base location dot
        const baseMiniX = mapCenterX + (BASE_LOCATION_GRID.x - playerViewCenterX) * MINIMAP_PIXEL_PER_TILE;
        const baseMiniY = mapCenterY + (BASE_LOCATION_GRID.y - playerViewCenterY) * MINIMAP_PIXEL_PER_TILE;
        minimapCtx.fillStyle = 'cyan';
        minimapCtx.beginPath();
        minimapCtx.arc(baseMiniX + MINIMAP_PIXEL_PER_TILE/2, baseMiniY + MINIMAP_PIXEL_PER_TILE/2, 3,0,Math.PI*2);
        minimapCtx.fill();
    }

    function generateWorldOutpostsIfNeeded() {
        const currentOutpostCount = gameState.worldMap.outposts.length;
        const desiredOutpostCount = 5 + gameState.age * 3 + Math.floor(gameState.stats.mapExpansions / 2);
        const outpostSpawnRadiusMin = 10 + gameState.age * 3;
        const outpostSpawnRadiusMax = MAX_MAP_GRID_DIM - 5;


        for (let i = currentOutpostCount; i < desiredOutpostCount; i++) {
            let attempts = 0;
            let newOutpostX, newOutpostY;
            let validPosition = false;

            while (!validPosition && attempts < 50) {
                const angle = Math.random() * 2 * Math.PI;
                const radius = Math.random() * (outpostSpawnRadiusMax - outpostSpawnRadiusMin) + outpostSpawnRadiusMin;
                newOutpostX = Math.round(BASE_LOCATION_GRID.x + Math.cos(angle) * radius);
                newOutpostY = Math.round(BASE_LOCATION_GRID.y + Math.sin(angle) * radius);

                if (Math.abs(newOutpostX) > MAX_MAP_GRID_DIM || Math.abs(newOutpostY) > MAX_MAP_GRID_DIM) {
                    attempts++; continue;
                }
                
                let tooClose = gameState.worldMap.outposts.some(op => Math.sqrt(Math.pow(op.gridX - newOutpostX, 2) + Math.pow(op.gridY - newOutpostY, 2)) < 8);
                if (!tooClose && !isTileOwned(newOutpostX, newOutpostY)) {
                    validPosition = true;
                }
                attempts++;
            }

            if (validPosition) {
                const distance = Math.sqrt(Math.pow(newOutpostX - BASE_LOCATION_GRID.x, 2) + Math.pow(newOutpostY - BASE_LOCATION_GRID.y, 2));
                const outpostAge = Math.min(AGES.length - 1, Math.floor(gameState.age + distance / 20)); 
                const templateIndex = Math.min(ENEMY_OUTPOSTS.length-1, Math.floor(Math.random() * (outpostAge +1)) );
                const template = ENEMY_OUTPOSTS[templateIndex];

                const outpostStrengthMod = 1 + (distance / 30); 
                const baseStrength = template.composition.reduce((sum, comp) => {
                    const unitDef = comp.unitDef || UNITS[comp.type];
                    return sum + (comp.countMin + comp.countMax)/2 * (unitDef.baseAttack + unitDef.baseDefense + unitDef.maxHp/5);
                },0) * (AGES[outpostAge]?.enemyStrengthModifier || 1);


                gameState.worldMap.outposts.push({
                    id: uniqueId('outpost_'),
                    name: `${AGES[outpostAge].name.split(" ")[0]} Outpost`,
                    icon: template.icon,
                    gridX: newOutpostX,
                    gridY: newOutpostY,
                    ageLevel: outpostAge,
                    composition: template.composition,
                    rewardBase: Math.floor(template.rewardBase * (1 + outpostAge*0.2)),
                    strength: Math.floor(baseStrength * outpostStrengthMod),
                    isDefeated: false,
                    isDiscovered: false, 
                });
            }
        }
    }
    
    function openWorldMapOutpostInteractionModal(outpost) {
        lastClickedWorldOutpost = outpost;
        DOMElements.worldMapOutpostModalTitle.textContent = outpost.name;
        
        const distance = Math.sqrt(Math.pow(outpost.gridX - BASE_LOCATION_GRID.x, 2) + Math.pow(outpost.gridY - BASE_LOCATION_GRID.y, 2));
        const travelTimeEstimate = Math.floor(distance * 1.5); // Seconds per grid unit approx
        let bodyHTML = `<p>Location: [${outpost.gridX}, ${outpost.gridY}]</p>`;
        bodyHTML += `<p>Distance: ${formatNumber(distance,1)} units</p>`;
        
        if (distance < 15) { // Arbitrary "close enough" distance
            bodyHTML += `<p>Strength: ${formatNumber(outpost.strength)}</p>`;
            bodyHTML += `<p>Dominant Age: ${AGES[outpost.ageLevel].name}</p>`;
            bodyHTML += `Composition (estimate): ${outpost.composition.map(c => `${c.unitDef.icon} x${c.countMin}-${c.countMax}`).join(', ')}`;
        } else {
            bodyHTML += `<p>Strength: Unknown (Too far to scout)</p>`;
            bodyHTML += `<p>Dominant Age: Likely ${AGES[outpost.ageLevel].name}</p>`;
        }
        
        DOMElements.worldMapOutpostModalBody.innerHTML = bodyHTML;
    
        DOMElements.worldMapOutpostModalActions.innerHTML = '';
        if (gameState.units.length > 0) {
            const deployButton = document.createElement('button');
            deployButton.className = 'game-button success';
            deployButton.textContent = `Deploy Army (Est. ${travelTimeEstimate}s)`;
            deployButton.onclick = () => deployArmyToOutpost(outpost, travelTimeEstimate);
            DOMElements.worldMapOutpostModalActions.appendChild(deployButton);
        } else {
            DOMElements.worldMapOutpostModalActions.innerHTML = '<p>You have no units available to deploy.</p>';
        }
        
        const closeButton = document.createElement('button');
        closeButton.className = 'game-button';
        closeButton.textContent = 'Close';
        closeButton.onclick = () => hideModal(DOMElements.worldMapOutpostInteractionModal);
        DOMElements.worldMapOutpostModalActions.appendChild(closeButton);

        showModal(DOMElements.worldMapOutpostInteractionModal);
    }

    function deployArmyToOutpost(outpost, travelTime) {
        if (gameState.units.length === 0) {
            showNotification("No units to deploy!", "error");
            return;
        }
        const armyUnits = gameState.units.map(u => ({ type: u.type, id: u.id })); 
        const unitStacksForDeployment = {};
        armyUnits.forEach(unit => {
            if(!unitStacksForDeployment[unit.type]) unitStacksForDeployment[unit.type] = { type: unit.type, count: 0, icon: UNITS[unit.type].icon};
            unitStacksForDeployment[unit.type].count++;
        });

        gameState.worldMap.deployedArmies.push({
            id: uniqueId('army_'),
            targetOutpostId: outpost.id,
            targetGridX: outpost.gridX,
            targetGridY: outpost.gridY,
            units: Object.values(unitStacksForDeployment),
            travelProgress: 0,
            totalTravelTime: travelTime,
            status: 'marching', 
        });
    
        gameState.units = []; 
        gameState.resources.population = 0; 
    
        addMessage(`Army deployed to ${outpost.name}. Arrival in ${travelTime}s.`);
        showNotification(`Army marching to ${outpost.name}!`, "info");
        hideModal(DOMElements.worldMapOutpostInteractionModal);
        updateAllUIDisplays();
    }

    function processDeployedArmies(deltaTime) {
        for (let i = gameState.worldMap.deployedArmies.length - 1; i >= 0; i--) {
            const army = gameState.worldMap.deployedArmies[i];
            if (army.status === 'marching') {
                army.travelProgress += deltaTime;
                if (army.travelProgress >= army.totalTravelTime) {
                    army.status = 'arrived';
                    army.travelProgress = army.totalTravelTime;
                    const outpost = gameState.worldMap.outposts.find(o => o.id === army.targetOutpostId);
                    addMessage(`Army has arrived at ${outpost ? outpost.name : 'destination'}!`, true);
                    showNotification(`Army arrived at ${outpost ? outpost.name : 'Unknown Outpost'}!`, 'success');
                    
                    if (outpost && !outpost.isDefeated) {
                        openWorldMapOutpostInteractionModal(outpost); // Re-open modal with attack option
                    } else {
                         army.status = 'returning';
                         army.travelProgress = 0; // Reset for return trip
                         addMessage('Target outpost gone or defeated. Army returning.', 'info');
                    }
                }
            } else if (army.status === 'returning') {
                army.travelProgress += deltaTime;
                 if (army.travelProgress >= army.totalTravelTime) { // Assuming same travel time back
                    addMessage(`Army has returned to base.`, true);
                    showNotification(`Army returned!`, 'success');
                    army.units.forEach(stack => { // This part needs proper re-integration of units
                        for(let j=0; j < stack.count; j++){
                            if(gameState.resources.population + UNITS[stack.type].population <= gameState.resources.maxPopulation){
                                gameState.units.push({id: uniqueId('ret_unt_'), type: stack.type, originalCost: UNITS[stack.type].cost });
                                gameState.resources.population += UNITS[stack.type].population;
                            } else {
                                addMessage(`Could not field returning ${UNITS[stack.type].name} - no population space.`);
                            }
                        }
                    });
                    gameState.worldMap.deployedArmies.splice(i, 1);
                }
            }
            discoverArea(Math.round(army.gridX), Math.round(army.gridY), 3); // Discover as army moves (simple visual, needs real pathing)
        }
        updateDeployedArmiesUI();
    }
    
    function updateDeployedArmiesUI() {
        DOMElements.deployedArmiesCount.textContent = gameState.worldMap.deployedArmies.length;
        if(gameState.worldMap.deployedArmies.length > 0) {
            DOMElements.deployedArmiesSection.style.display = 'block';
            DOMElements.deployedArmiesList.innerHTML = gameState.worldMap.deployedArmies.map((army, index) => {
                const targetOutpost = gameState.worldMap.outposts.find(o => o.id === army.targetOutpostId);
                const targetName = targetOutpost ? targetOutpost.name : 'Unknown Location';
                let statusText = '';
                let progressPercent = 0;
                if (army.status === 'marching') {
                    progressPercent = Math.min(100, (army.travelProgress / army.totalTravelTime) * 100);
                    statusText = `Marching to ${targetName} (${formatNumber(army.travelProgress,0)}s / ${army.totalTravelTime}s)`;
                } else if (army.status === 'arrived') {
                    progressPercent = 100;
                    statusText = `Arrived at ${targetName}. Awaiting orders.`;
                } else if (army.status === 'returning') {
                    progressPercent = Math.min(100, (army.travelProgress / army.totalTravelTime) * 100);
                    statusText = `Returning from ${targetName} (${formatNumber(army.travelProgress,0)}s / ${army.totalTravelTime}s)`;
                }
                
                const unitsSummary = army.units.map(u => `${u.icon}x${u.count}`).join(', ');

                let recallButtonHTML = '';
                if (army.status === 'marching' || army.status === 'arrived') {
                    recallButtonHTML = `<button class="game-button building-cancel-button" onclick="recallDeployedArmy('${army.id}')" title="Recall Army">‚Ü™Ô∏è</button>`;
                }

                return `<div class="deployed-army-info">
                            <div style="flex-grow:1;">
                                <span>${index + 1}. Army to ${targetName}</span><br>
                                <small>${statusText} (${unitsSummary})</small>
                            </div>
                            ${recallButtonHTML}
                        </div>
                        ${army.status !== 'arrived' ? `<div class="progress-container" style="height:5px; margin-bottom:5px;"><div class="progress-bar-small" style="width:${progressPercent}%"></div></div>` : ''}`;
            }).join('');
        } else {
            DOMElements.deployedArmiesSection.style.display = 'none';
        }
    }
    function recallDeployedArmy(armyId) {
        const army = gameState.worldMap.deployedArmies.find(a => a.id === armyId);
        if (army && (army.status === 'marching' || army.status === 'arrived')) {
            army.status = 'returning';
            army.totalTravelTime = army.travelProgress; // Time to return is how long it took to get there from current point
            army.travelProgress = 0; // Reset progress for return trip
            addMessage(`Army #${army.id.slice(-4)} recalled. Returning to base.`, 'info');
            hideModal(DOMElements.worldMapOutpostInteractionModal); // Close modal if open for this army's target
            updateAllUIDisplays();
        }
    }

    function drawDeployedArmiesOnMap() {
        gameState.worldMap.deployedArmies.forEach(army => {
            if (army.status === 'marching' || army.status === 'returning') {
                const targetOutpost = gameState.worldMap.outposts.find(o => o.id === army.targetOutpostId);
                let currentGridX, currentGridY;
                
                let startX = BASE_LOCATION_GRID.x, startY = BASE_LOCATION_GRID.y;
                let endX = targetOutpost ? targetOutpost.gridX : BASE_LOCATION_GRID.x; // if no target, return to base
                let endY = targetOutpost ? targetOutpost.gridY : BASE_LOCATION_GRID.y;

                if (army.status === 'returning') { // Swap start and end for returning
                    [startX, endX] = [endX, startX];
                    [startY, endY] = [endY, startY];
                }

                const progressRatio = army.travelProgress / army.totalTravelTime;
                currentGridX = startX + (endX - startX) * progressRatio;
                currentGridY = startY + (endY - startY) * progressRatio;
                army.gridX = currentGridX; 
                army.gridY = currentGridY;

                if (!isTileDiscovered(Math.round(currentGridX), Math.round(currentGridY))) return;


                const screenPos = gridToScreen(currentGridX, currentGridY);
                ctx.font = `${TILE_HEIGHT_ISO*0.6}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                ctx.fillStyle = 'rgba(50, 150, 255, 0.7)'; 
                ctx.beginPath();
                ctx.ellipse(screenPos.x, screenPos.y + TILE_HEIGHT_ISO * 0.4, TILE_WIDTH_ISO*0.2, TILE_HEIGHT_ISO*0.15, 0, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = 'white';
                ctx.fillText('‚öîÔ∏è', screenPos.x, screenPos.y);
            }
        });
    }


    </script>
</body>
</html>
