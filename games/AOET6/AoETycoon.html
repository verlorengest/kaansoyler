
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Age of Empire Tycoon - Definitive Edition</title>
    <style>
        :root {
            --primary-color: #2c3e50; --secondary-color: #34495e; --accent-color: #f1c40f;
            --background-color: #1c2833; --text-color: #ecf0f1; --border-color: #273746;
            --button-color: #2980b9; --button-hover: #3498db; --button-active: #2471a3;
            --button-disabled-bg: #566573; --button-disabled-text: #95a5a6;
            --error-color: #e74c3c; --success-color: #2ecc71; --info-color: #3498db;
            --font-primary: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            --font-monospace: 'Courier New', Courier, monospace;
            --map-tile-color: #4a6b8a; --map-tile-border: #2c4a6a;
            --map-grid-line-color: rgba(236, 240, 241, 0.05);
            --building-placeholder-valid: rgba(46, 204, 113, 0.5);
            --building-placeholder-invalid: rgba(231, 76, 60, 0.5);
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background-color: var(--background-color); color: var(--text-color); font-family: var(--font-primary);
            overflow: hidden; height: 100vh; display: flex; flex-direction: column;
        }
        #game-container { display: flex; height: 100vh; width: 100vw; }
        #game-canvas-container { flex: 3; position: relative; overflow: hidden; background-color: #000; cursor: grab; }
        #game-canvas-container.grabbing { cursor: grabbing; }
        #game-canvas { width: 100%; height: 100%; display: block; }
        #projectile-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 25; }
        #minimap-container {
            position: absolute; bottom: 15px; right: 15px;
            width: 200px; height: 150px; border: 2px solid var(--accent-color);
            background-color: rgba(0,0,0,0.6); z-index: 30; box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }
        #minimap-canvas { width: 100%; height: 100%; }
        #back-to-base-button {
            position: absolute; top: 70px; left: 15px; z-index: 30;
            background-color: var(--accent-color); color: var(--primary-color);
            padding: 8px 12px; border-radius: 5px; display:none; cursor: pointer;
            font-weight: bold; box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }
        #back-to-base-button:hover { background-color: #f39c12; }

        #sidebar {
            flex: 1; min-width: 380px; max-width: 500px; background-color: var(--primary-color);
            border-left: 2px solid var(--border-color); overflow-y: auto; padding: 15px;
            display: flex; flex-direction: column; gap: 15px;
        }
        .sidebar-section { padding: 15px; background-color: var(--secondary-color); border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.2); }
        .section-title { color: var(--accent-color); border-bottom: 2px solid var(--accent-color); padding-bottom: 8px; margin-bottom: 12px; font-size: 1.1em; font-weight: 600; }
        .resource-display { display: flex; justify-content: space-between; margin-bottom: 8px; font-size: 0.95em; }
        .resource-name { font-weight: 500; }
        .resource-value { font-family: var(--font-monospace); color: var(--accent-color); font-weight: bold; }
        .game-button {
            background-color: var(--button-color); border: none; color: var(--text-color); padding: 10px 15px; text-align: left;
            text-decoration: none; font-size: 0.9em; border-radius: 5px; margin: 5px 0; cursor: pointer;
            transition: background-color 0.2s ease-in-out, transform 0.1s ease, box-shadow 0.2s;
            display: flex; justify-content: space-between; align-items: center; width: 100%;
        }
        .game-button span:first-child { flex-grow: 1; }
        .game-button span:last-child { margin-left: 10px; font-weight: bold; }
        .game-button:hover:not(:disabled) { background-color: var(--button-hover); transform: translateY(-1px); box-shadow: 0 2px 5px rgba(0,0,0,0.2); }
        .game-button:active:not(:disabled) { background-color: var(--button-active); transform: translateY(0px); }
        .game-button:disabled { background-color: var(--button-disabled-bg); color: var(--button-disabled-text); cursor: not-allowed; }
        .game-button.pulse:not(:disabled) { animation: pulse-animation 1.5s infinite; }
        @keyframes pulse-animation { 0% { box-shadow: 0 0 0 0 rgba(241, 196, 15, 0.7); } 70% { box-shadow: 0 0 0 10px rgba(241, 196, 15, 0); } 100% { box-shadow: 0 0 0 0 rgba(241, 196, 15, 0); } }
        .game-button.raid-alert-button { background-color: var(--error-color); animation: pulse-danger-animation 1s infinite alternate; }
        @keyframes pulse-danger-animation { 0% { box-shadow: 0 0 0 0 rgba(231, 76, 60, 0.7); transform: scale(1); } 100% { box-shadow: 0 0 0 8px rgba(231, 76, 60, 0); transform: scale(1.02); } }
        .game-button.age-power-button { background-color: var(--info-color); }
        .game-button.age-power-button:hover:not(:disabled) { background-color: var(--button-hover); }
        .game-button.building-cancel-button { background-color: var(--error-color); margin-left: 10px; flex-grow: 0; padding: 5px 10px; min-width: 30px; max-width: 30px; }
        .unit-info, .training-queue-item-info, .construction-queue-item-info, .deployed-army-info { display: flex; justify-content: space-between; font-size: 0.85em; color: #bdc3c7; padding: 3px 5px; background-color: rgba(0,0,0,0.1); border-radius: 3px; margin-bottom: 3px; }
        .training-queue-item-info .progress-bar-small, .construction-queue-item-info .progress-bar-small, .deployed-army-info .progress-bar-small { height: 5px; background-color: var(--accent-color); border-radius: 2px; margin-top: 2px; width:0%; transition: width 0.3s linear; }
        #messages-container { position: absolute; bottom: 15px; left: 15px; width: clamp(300px, 50%, 600px); max-height: 150px; overflow-y: auto; background-color: rgba(0, 0, 0, 0.75); border-radius: 8px; padding: 12px; z-index: 10; font-size: 0.9em; box-shadow: 0 2px 5px rgba(0,0,0,0.3); }
        .message { margin-bottom: 6px; opacity: 0; animation: fadeIn 0.5s forwards; } .message:last-child { margin-bottom: 0; } @keyframes fadeIn { to { opacity: 1; } }
        #notification { position: absolute; top: 20px; left: 50%; transform: translateX(-50%); color: var(--text-color); padding: 12px 25px; border-radius: 8px; font-size: 1em; font-weight: 500; z-index: 100; display: none; box-shadow: 0 3px 8px rgba(0,0,0,0.3); opacity: 0; transition: opacity 0.3s ease-in-out; }
        #notification.show { display: block; opacity: 1; } #notification.error { background-color: var(--error-color); } #notification.success { background-color: var(--success-color); } #notification.info { background-color: var(--button-color); }
        .progress-container { width: 100%; background-color: var(--border-color); height: 12px; border-radius: 6px; margin-top: 5px; overflow: hidden; }
        .progress-bar { height: 100%; border-radius: 6px; background-color: var(--accent-color); width: 0%; transition: width 0.3s ease-in-out; }
        .item-slot { width: 100%; margin-bottom: 10px; background-color: rgba(0, 0, 0, 0.15); border-radius: 6px; display: flex; align-items: center; cursor: pointer; padding: 8px; transition: background-color 0.2s, box-shadow 0.2s; border: 1px solid transparent; }
        .item-slot:hover:not(.disabled):not(.placing-active) { background-color: rgba(0, 0, 0, 0.25); box-shadow: 0 0 8px rgba(var(--accent-color), 0.5); border-color: var(--accent-color); }
        .item-slot.disabled { opacity: 0.6; cursor: not-allowed; background-color: rgba(0,0,0,0.1); }
        .item-slot.placing-active { background-color: var(--accent-color) !important; color: var(--background-color) !important; border-color: var(--background-color) !important; }
        .item-slot.placing-active .item-cost, .item-slot.placing-active .item-description { color: var(--primary-color) !important; }
        .item-icon { width: 45px; height: 45px; background-color: var(--border-color); border-radius: 5px; display: flex; justify-content: center; align-items: center; font-size: 1.8em; margin-right: 12px; flex-shrink: 0; }
        .item-details { flex: 1; overflow: hidden; } .item-name { font-weight: 600; font-size: 1em; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .item-description { font-size: 0.8em; color: #bdc3c7; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .item-cost { font-weight: bold; font-family: var(--font-monospace); font-size: 0.95em; margin-left: 10px; color: var(--accent-color); min-width: 50px; text-align: right; }
        .tab-navigation { display: flex; margin-bottom: -1px; }
        .tab-button { flex: 1; padding: 12px; text-align: center; background-color: var(--secondary-color); cursor: pointer; transition: background-color 0.2s, color 0.2s; border: 1px solid var(--border-color); border-bottom: none; border-top-left-radius: 5px; border-top-right-radius: 5px; font-weight: 500; }
        .tab-button.active { background-color: var(--primary-color); color: var(--accent-color); border-bottom: 1px solid var(--primary-color); }
        .tab-button:not(.active):hover { background-color: var(--button-hover); }
        .tab-content { display: none; border: 1px solid var(--border-color); border-top: none; border-bottom-left-radius: 5px; border-bottom-right-radius: 5px; background-color: var(--primary-color); }
        .tab-content.active { display: block; }
        .log-container { background-color: rgba(0, 0, 0, 0.2); padding: 10px; border-radius: 5px; height: 120px; overflow-y: auto; font-size: 0.85em; border: 1px solid var(--border-color); }
        .log-container div { margin-bottom: 4px; }
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.85); display: flex; justify-content: center; align-items: center; z-index: 1000; opacity: 0; visibility: hidden; transition: opacity 0.3s ease, visibility 0s linear 0.3s; }
        .modal-overlay.visible { opacity: 1; visibility: visible; transition: opacity 0.3s ease, visibility 0s linear 0s; }
        .modal-content { background-color: var(--primary-color); border-radius: 10px; padding: 25px; max-width: 90vw; width: 600px; text-align: left; box-shadow: 0 5px 15px rgba(0,0,0,0.5); position: relative; max-height: 80vh; overflow-y: auto; }
        .modal-content h2 { color: var(--accent-color); margin-bottom: 15px; text-align: center; font-size: 1.5em; }
        .modal-content p { margin-bottom: 12px; line-height: 1.6; font-size: 0.95em; }
        .modal-navigation { display: flex; justify-content: space-between; margin-top: 25px; }
        .modal-close-button { position: absolute; top: 15px; right: 15px; background: none; border: none; color: var(--text-color); font-size: 1.8em; cursor: pointer; line-height: 1; }
        .era-label { position: absolute; top: 15px; left: 15px; background-color: rgba(0, 0, 0, 0.75); color: var(--accent-color); padding: 8px 12px; border-radius: 5px; font-size: 0.9em; font-weight: bold; z-index: 5; }
        #achievement-notification-popup { position: fixed; bottom: 20px; right: 20px; background-color: var(--accent-color); color: var(--background-color); padding: 15px 25px; border-radius: 8px; font-size: 1em; z-index: 101; display: none; text-align: center; box-shadow: 0 3px 10px rgba(0,0,0,0.3); opacity: 0; transform: translateY(20px); transition: opacity 0.3s ease, transform 0.3s ease; }
        #achievement-notification-popup.show { display: block; opacity: 1; transform: translateY(0); }
        #achievement-notification-popup strong { display: block; margin-bottom: 5px; font-size: 1.1em;}
        .tooltip { position: absolute; background-color: rgba(10, 10, 20, 0.95); color: var(--text-color); padding: 10px 15px; border-radius: 6px; font-size: 0.85em; z-index: 2000; pointer-events: none; opacity: 0; transition: opacity 0.2s ease-in-out; max-width: 300px; border: 1px solid var(--accent-color); box-shadow: 0 2px 8px rgba(0,0,0,0.4); line-height: 1.5; }
        .tooltip.visible { opacity: 1; } .tooltip strong { color: var(--accent-color); }
        .enemy-icon { background-color: var(--error-color); }
        #buildings-container, #units-container, #tech-container, #upgrades-container, #enemy-selection-list, #achievements-list, #training-queue-list, #active-raids-list, #battle-age-powers-container, #construction-queue-list, #deployed-armies-list { display: flex; flex-direction: column; gap: 8px; }
        #current-units-display .section-title { margin-bottom: 5px; } #current-units-display .unit-info { padding: 2px 5px; background-color: rgba(0,0,0,0.1); border-radius: 3px; margin-bottom: 3px;}

        #battle-modal-overlay .modal-content { width: 95vw; max-width: 1400px; height: 90vh; max-height: 850px; display: flex; flex-direction: column; }
        #battle-area {
            display: flex; justify-content: space-between; align-items: flex-start; flex-grow: 1;
            padding: 20px 10px; border-radius: 8px; margin-bottom: 15px; position: relative; gap: 15px;
            background-size: cover; background-position: center; transition: background-image 0.5s ease-in-out;
            border: 2px solid var(--border-color); background-color: rgba(0,0,0,0.1);
        }
        .battle-party {
             display: flex; flex-wrap: wrap; align-content: flex-start; justify-content: center;
             gap: 12px; width: 50%; max-height: 600px; overflow-y: auto;
             padding: 15px; background-color: rgba(0,0,0,0.25); border-radius: 8px;
             align-items: flex-start;
        }
        .battle-unit-stack {
            background-color: var(--primary-color); padding: 10px 12px; border-radius: 6px; text-align: center;
            border: 3px solid transparent; cursor: pointer; transition: all 0.2s ease-out;
            min-width: 170px; max-width: 200px; flex-basis: 180px; flex-grow: 1;
            margin-bottom: 8px; position: relative; box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        .battle-unit-stack.player-stack.selectable:not(.has-acted):not(.selected-actor):hover { border-color: var(--button-hover); transform: scale(1.03); box-shadow: 0 0 10px var(--button-hover);}
        .battle-unit-stack.player-stack.selected-actor { border-color: var(--accent-color); box-shadow: 0 0 15px var(--accent-color); transform: scale(1.06); z-index: 5; }
        .battle-unit-stack.player-stack.has-acted { opacity: 0.7; cursor: default; background-color: var(--secondary-color); border-color: #555;}
        .battle-unit-stack.enemy-stack.targetable:hover:not(.selected-target) { border-color: var(--button-hover); transform: scale(1.03); box-shadow: 0 0 10px var(--button-hover);}
        .battle-unit-stack.enemy-stack.selected-target { border-color: var(--error-color); box-shadow: 0 0 15px var(--error-color); transform: scale(1.06); z-index: 5; }
        .battle-unit-stack.defeated-stack { opacity: 0.4; background-color: #333; cursor: default; border-color: #111; }
        .battle-unit-icon { font-size: 2.8em; margin-bottom: 5px; display: block; }
        .battle-unit-name { font-weight: bold; font-size: 1em; margin-bottom: 3px;}
        .battle-unit-count { font-size: 0.95em; color: var(--accent-color); margin-bottom: 5px;}
        .battle-unit-hp-bar { width: 100%; height: 12px; background-color: var(--error-color); border-radius: 6px; margin-top: 5px; overflow: hidden; border: 1px solid var(--border-color); }
        .battle-unit-hp { height: 100%; background-color: var(--success-color); width: 100%; transition: width 0.3s ease-out; }
        .battle-unit-stats-line { font-size: 0.85em; color: #bdc3c7; margin-top: 3px;}
        .battle-unit-stack.anim-melee-attack { animation: melee-attack-anim 0.7s ease-in-out; }
        @keyframes melee-attack-anim {
            0% { transform: translateX(0) scale(1.06); }
            25% { transform: translateX(30px) scale(1.1); }
            50% { transform: translateX(60px) scale(1.15); z-index: 10; }
            75% { transform: translateX(30px) scale(1.1); }
            100% { transform: translateX(0) scale(1.06); z-index: 5; }
        }
        .battle-unit-stack.anim-melee-attack-enemy { animation: melee-attack-anim-enemy 0.7s ease-in-out; }
        @keyframes melee-attack-anim-enemy {
            0% { transform: translateX(0) scale(1); }
            25% { transform: translateX(-30px) scale(1.05); }
            50% { transform: translateX(-60px) scale(1.1); z-index: 10; }
            75% { transform: translateX(-30px) scale(1.05); }
            100% { transform: translateX(0) scale(1); z-index: auto; }
        }
        .projectile {
            position: absolute; font-size: 1.8em; z-index: 20; pointer-events: none; color: var(--accent-color);
            transition: transform 0.4s cubic-bezier(0.5, -0.3, 0.8, 1.2), opacity 0.4s linear;
            text-shadow: 0 0 6px black; opacity: 1;
        }
        .projectile.hit { opacity: 0; }

        #battle-controls-area { display: flex; justify-content: space-between; align-items: flex-start; gap: 20px;}
        #battle-actions { display: flex; flex-direction: column; gap: 10px; margin-bottom: 10px; width: 25%; }
        #battle-age-powers-container { width: 45%; display: flex; flex-wrap: wrap; gap: 10px; justify-content: flex-start; }
        #battle-age-powers-container .game-button { padding: 10px 14px; font-size: 0.9em; flex-grow: 0; min-width: 140px; }
        #battle-turn-controls { width: 25%; display:flex; flex-direction: column; align-items: flex-end; gap: 10px;}
        #battle-turn-controls .game-button {width: auto; min-width: 150px; background-color: var(--success-color); }
        #battle-turn-controls .game-button:hover:not(:disabled) { background-color: #27ae60; }

        #battle-log-container-modal { height: 150px; overflow-y: auto; background-color: rgba(0,0,0,0.35); padding: 12px; border-radius: 6px; font-size: 0.9em; margin-top:15px; border: 1px solid var(--border-color);}
        .battle-log-entry { animation: fadeIn 0.3s; }
        .damage-popup, .heal-popup, .effect-popup {
            position: absolute; font-size: 1.9em; font-weight: bold; animation: floatUpAndFade 1.3s forwards;
            pointer-events: none; text-shadow: 2px 2px 3px black; z-index: 30;
        }
        .damage-popup { color: var(--error-color); } .heal-popup { color: var(--success-color); }
        .effect-popup { color: var(--info-color); }
        @keyframes floatUpAndFade { 0% { opacity: 1; transform: translateY(0) scale(0.9); } 20% { transform: translateY(-15px) scale(1.15); } 100% { opacity: 0; transform: translateY(-70px) scale(0.7); } }
    
        #city-management-section { margin-top: 15px; }
        .map-controls { display:flex; gap:10px; margin-bottom: 10px; }
        .map-controls .game-button { flex-grow: 1;}
        #world-map-outpost-interaction-modal .modal-content {width: 450px;}
        #deployed-armies-section .section-title {margin-bottom: 5px;}
    </style>
</head>
<body>
    <div id="game-container">
        <div id="game-canvas-container">
            <canvas id="game-canvas"></canvas>
            <div id="projectile-container"></div>
            <div id="messages-container"></div>
            <div id="notification"><span id="notification-message"></span></div>
            <div class="era-label" id="era-label-display">Prehistoric Age</div>
            <button id="back-to-base-button">Return to Base</button>
            <div id="minimap-container"><canvas id="minimap-canvas"></canvas></div>
            <div id="achievement-notification-popup"><strong>Achievement!</strong> <div id="achievement-name-popup"></div></div>
        </div>
        <div id="sidebar">
            <div class="sidebar-section"><div class="section-title">Resources</div><div id="resource-displays"></div></div>
            <div id="raid-alert-section" class="sidebar-section" style="display:none;"><div class="section-title" style="color: var(--error-color);">⚠️ Active Raids!</div><div id="active-raids-list"></div></div>
            
            <div class="tab-navigation">
                <button class="tab-button active" data-tab="buildings">City & Buildings</button>
                <button class="tab-button" data-tab="units">Units & Battle</button>
                <button class="tab-button" data-tab="research">Research</button>
            </div>

            <div class="tab-content active" id="buildings-tab-content">
                <div class="sidebar-section">
                    <div class="section-title">Construct Buildings</div>
                    <div id="buildings-container"></div>
                     <div id="construction-queue-display" style="margin-top:15px;"><div class="section-title">Construction Queue (<span id="construction-queue-count">0</span>)</div><div id="construction-queue-list"></div></div>
                </div>
                <div class="sidebar-section" id="city-management-section">
                    <div class="section-title">City Management</div>
                    <div class="map-controls">
                        <button class="game-button" id="expand-land-north-button">Expand North (<span id="expand-cost-north">0</span> 💰)</button>
                        <button class="game-button" id="expand-land-south-button">Expand South (<span id="expand-cost-south">0</span> 💰)</button>
                    </div>
                     <div class="map-controls">
                        <button class="game-button" id="expand-land-west-button">Expand West (<span id="expand-cost-west">0</span> 💰)</button>
                        <button class="game-button" id="expand-land-east-button">Expand East (<span id="expand-cost-east">0</span> 💰)</button>
                    </div>
                    <button class="game-button" id="cancel-placement-button" style="display:none; background-color: var(--error-color);">Cancel Placement Mode</button>
                </div>
            </div>

            <div class="tab-content" id="units-tab-content">
                <div class="sidebar-section"><div class="section-title">Train Units</div><div id="units-container"></div>
                    <div id="training-queue-display" style="margin-top:15px;"><div class="section-title">Training Queue (<span id="training-queue-count">0</span>)</div><div id="training-queue-list"></div></div>
                    <div id="current-units-display" style="margin-top:15px;"><div class="section-title">Current Army Stacks</div><div id="current-units-list"></div></div>
                    <div id="deployed-armies-section" style="margin-top:15px;"><div class="section-title">Deployed Armies (<span id="deployed-armies-count">0</span>)</div><div id="deployed-armies-list"></div></div>
                    <div class="resource-display" style="margin-top:10px;"><span class="resource-name">Total Army Strength:</span><span class="resource-value" id="army-strength-display">0</span></div>
                </div>
                <div class="sidebar-section"><div class="section-title">Engage in Battle</div><button class="game-button" id="battle-button">Find Random Enemy Outpost</button><div id="enemy-selection-container" style="display: none; margin-top: 10px;"><div id="enemy-selection-list"></div></div></div>
            </div>
            <div class="tab-content" id="research-tab-content">
                <div class="sidebar-section"><div class="section-title">Current Research</div><div id="current-research-display">None</div><div class="progress-container"><div class="progress-bar" id="research-progress-bar"></div></div></div>
                <div class="sidebar-section"><div class="section-title">Available Technologies</div><div id="tech-container"></div></div>
                <div class="sidebar-section"><div class="section-title">Age Advancement</div><button class="game-button" id="advance-age-button" disabled><span>Advance to Next Age</span><span id="advance-age-cost-display">1000</span></button><div class="progress-container"><div class="progress-bar" id="age-progress-bar"></div></div><div id="researched-techs-display" style="margin-top:15px;"><div class="section-title">Researched Techs</div><div id="researched-techs-list" style="font-size: 0.85em; max-height: 100px; overflow-y: auto;"></div></div></div>
            </div>
      
            <div class="sidebar-section" style="margin-top: auto;"><div class="section-title">Game Controls</div><button class="game-button" id="edit-buildings-button">Edit Buildings</button><button class="game-button" id="save-button">Save</button><button class="game-button" id="load-button">Load</button><button class="game-button" id="tutorial-button">Tutorial</button><button class="game-button" id="achievements-button">Achievements</button><button class="game-button" id="resign-button" style="background-color: var(--error-color);">Resign Game</button></div>

    
        </div>
    </div>

    <div class="modal-overlay" id="tutorial-overlay"><div class="modal-content"><button class="modal-close-button" id="tutorial-force-close-button">&times;</button><h2 id="tutorial-title">Welcome!</h2><div id="tutorial-body-content"></div><div class="modal-navigation"><button class="game-button" id="tutorial-prev-button" disabled>Previous</button><button class="game-button" id="tutorial-next-button">Next</button><button class="game-button" id="tutorial-close-button" style="display: none;">Start Game</button></div></div></div>
    <div class="modal-overlay" id="upgrade-panel-overlay"><div class="modal-content"><button class="modal-close-button" id="upgrade-panel-close-button">&times;</button><h2>Upgrade Building</h2><div id="upgrades-container"></div></div></div>
    <div class="modal-overlay" id="generic-overlay"><div class="modal-content" id="generic-overlay-content"><button class="modal-close-button" id="generic-overlay-close-button">&times;</button></div></div>

    <div class="modal-overlay" id="battle-modal-overlay">
        <div class="modal-content">
            <button class="modal-close-button" id="battle-modal-close-button" style="display:none;">&times;</button>
            <h2 id="battle-title-text">Battle!</h2>
            <div id="battle-area">
                <div id="player-battle-party" class="battle-party"></div>
                <div id="enemy-battle-party" class="battle-party"></div>
            </div>
            <div id="battle-controls-area">
                <div id="battle-actions">
                    <button class="game-button" id="battle-action-attack" disabled style="display: none;">Attack</button>
                    <button class="game-button" id="battle-action-defend" disabled>Defend</button>
                </div>
                <div id="battle-age-powers-container">
                </div>
                 <div id="battle-turn-controls">
                    <button class="game-button" id="battle-end-turn-button" disabled>End Turn</button>
                    <button class="game-button" id="battle-leave-button" style="display:none; margin-top: 15px; background-color: var(--error-color);">Concede Battle</button>
                 </div>
            </div>
            <div class="section-title" style="margin-top:10px;">Battle Log</div>
            <div id="battle-log-container-modal" class="log-container"></div>
        </div>
    </div>

    <div class="modal-overlay" id="world-map-outpost-interaction-modal">
        <div class="modal-content">
            <button class="modal-close-button" id="world-map-outpost-modal-close-button">&times;</button>
            <h2 id="world-map-outpost-modal-title">Outpost Interaction</h2>
            <div id="world-map-outpost-modal-body"></div>
            <div id="world-map-outpost-modal-actions" style="margin-top: 20px; display: flex; gap: 10px;"></div>
        </div>
    </div>




    <div class="modal-overlay" id="deploy-unit-selection-modal">
        <div class="modal-content" style="width: 500px;">
            <button class="modal-close-button" id="deploy-unit-selection-modal-close-button">×</button>
            <h2 id="deploy-unit-selection-modal-title">Select Units for Deployment</h2>
            <div id="deploy-unit-selection-modal-body" style="max-height: 300px; overflow-y: auto; margin-bottom: 15px;">
                <!-- Unit selection items will be dynamically populated here -->
            </div>
            <p>Estimated Travel Time: <span id="deploy-travel-time-estimate">0</span>s</p>
            <div id="deploy-unit-selection-modal-actions" style="margin-top: 20px; display: flex; justify-content: flex-end; gap: 10px;">
                <button class="game-button" id="cancel-deployment-selection-button">Cancel</button>
                <button class="game-button success" id="confirm-deployment-button">Confirm & Deploy</button>
            </div>
        </div>
    </div>


      
    <div class="modal-overlay" id="edit-mode-actions-overlay" style="background-color: transparent; pointer-events: none; align-items: flex-start; justify-content: flex-start;">
            <div class="modal-content" id="edit-mode-actions-content" style="position: absolute; pointer-events: auto; width: auto; min-width:150px; padding:10px; display:none; flex-direction: column; gap: 8px;">
                <div id="selected-building-info-edit" style="font-weight:bold; margin-bottom:5px; text-align:center; color: var(--accent-color);"></div>
                <button class="game-button" id="move-building-button-edit" style="padding: 8px 12px; font-size: 0.85em;">Move Building</button>
                <button class="game-button" id="delete-building-button-edit" style="background-color: var(--error-color); padding: 8px 12px; font-size: 0.85em;">Delete Building</button>
                <button class="game-button" id="cancel-building-selection-button-edit" style="background-color: var(--secondary-color); padding: 8px 12px; font-size: 0.85em;">Deselect</button>
            </div>
        </div>

    



    <div class="tooltip" id="tooltip-element"></div>

    <script>
"use strict";
const AGES = [
  {
    name: "Prehistoric Age",
    techCost: 0,
    enemyStrengthModifier: 1.0,
    raidChanceBase: 0.01,
    raidStrengthMod: 0.8,
    battleBg: "linear-gradient(to bottom, #78A451, #4F7731)",
    specialPower: null,
  },
  {
    name: "Ancient Age",
    techCost: 200,
    enemyStrengthModifier: 1.2,
    raidChanceBase: 0.015,
    raidStrengthMod: 1.0,
    battleBg: "linear-gradient(to bottom, #D4AC6E, #A07D4E)",
    specialPower: {
      id: "hail_of_arrows",
      name: "Hail of Arrows",
      icon: "🎯",
      description: "Lightly damages all enemy stacks.",
      costType: "gold",
      cost: 50,
      cooldownTurns: 3,
      effect: "aoeDamage",
      damageBase: 15,
      aoeDamagePercent: 1.0,
      targetType: "all_enemies",
    },
  },
  {
    name: "Medieval Age",
    techCost: 1000,
    enemyStrengthModifier: 1.5,
    raidChanceBase: 0.02,
    raidStrengthMod: 1.2,
    battleBg: "linear-gradient(to bottom, #6A8A65, #4C6A48)",
    specialPower: {
      id: "rally_troops",
      name: "Rally Troops",
      icon: "🚩",
      description: "Temporarily boosts attack of one player stack.",
      costType: "tech",
      cost: 25,
      cooldownTurns: 4,
      effect: "buff_attack_once",
      buffAmount: 1.2,
      buffDuration: 1,
      targetType: "player_stack_select",
    },
  },
  {
    name: "Renaissance Age",
    techCost: 5000,
    enemyStrengthModifier: 2.0,
    raidChanceBase: 0.025,
    raidStrengthMod: 1.4,
    battleBg: "linear-gradient(to bottom, #B0A090, #8C7C6C)",
    specialPower: {
      id: "cannon_barrage",
      name: "Cannon Barrage",
      icon: "💣",
      description:
        "Deals moderate damage to one enemy stack and splashes to others.",
      costType: "gold",
      cost: 200,
      cooldownTurns: 5,
      effect: "directDamageSplash",
      damageBase: 100,
      aoeDamagePercent: 0.3,
      targetType: "enemy_stack_select",
    },
  },
  {
    name: "Industrial Age",
    techCost: 20000,
    enemyStrengthModifier: 2.0,
    raidChanceBase: 0.03,
    raidStrengthMod: 2.0,
    battleBg: "linear-gradient(to bottom, #777C80, #54585C)",
    specialPower: {
      id: "trench_warfare",
      name: "Entrench",
      icon: "⛏️",
      description: "Greatly boosts defense of all player stacks for 1 turn.",
      costType: "tech",
      cost: 100,
      cooldownTurns: 5,
      effect: "buff_defense_all",
      buffAmount: 1.5,
      buffDuration: 1,
      targetType: "all_player",
    },
  },
  {
    name: "Modern Age",
    techCost: 100000,
    enemyStrengthModifier: 3.0,
    raidChanceBase: 0.035,
    raidStrengthMod: 2.5,
    battleBg: "linear-gradient(to bottom, #9DB0BF, #748DA0)",
    specialPower: {
      id: "airstrike",
      name: "Airstrike",
      icon: "✈️",
      description: "Deals heavy damage to all enemy stacks.",
      costType: "gold",
      cost: 1000,
      cooldownTurns: 8,
      effect: "aoeDamage",
      damageBase: 300,
      aoeDamagePercent: 1.0,
      targetType: "all_enemies",
    },
  },
  {
    name: "Future Age",
    techCost: 500000,
    enemyStrengthModifier: 4.0,
    raidChanceBase: 0.04,
    raidStrengthMod: 3.0,
    battleBg: "linear-gradient(to bottom, #4A6B8A, #2C4A6A, #0D2A49)",
    specialPower: {
      id: "orbital_laser",
      name: "Orbital Laser",
      icon: "🛰️",
      description: "Massive damage to a single enemy stack.",
      costType: "tech",
      cost: 500,
      cooldownTurns: 10,
      effect: "directDamage",
      damageBase: 1000,
      targetType: "enemy_stack_select",
    },
  },
];
const BUILDINGS = {
  hut: {
    id: "hut",
    name: "Hut",
    description: "Pop. capacity.",
    baseCost: 20,
    costMultiplier: 1.18,
    effects: [{ target: "maxPopulation", value: 2, operation: "add" }],
    minAge: 0,
    maxAge: 1,
    icon: "🏠",
    upgradesTo: "house",
    sizeX: 1,
    sizeY: 1,
    buildTime: 5,
    color: "#8b4513",
  },
  house: {
    id: "house",
    name: "House",
    description: "More pop. capacity.",
    baseCost: 100,
    costMultiplier: 1.25,
    effects: [{ target: "maxPopulation", value: 5, operation: "add" }],
    minAge: 1,
    maxAge: 3,
    icon: "🏘️",
    upgradesTo: "apartment",
    sizeX: 2,
    sizeY: 1,
    buildTime: 10,
    color: "#a0522d",
  },
  apartment: {
    id: "apartment",
    name: "Apartment",
    description: "Large pop. capacity.",
    baseCost: 500,
    costMultiplier: 1.3,
    effects: [{ target: "maxPopulation", value: 15, operation: "add" }],
    minAge: 3,
    maxAge: 5,
    icon: "🏢",
    upgradesTo: "arcology",
    sizeX: 2,
    sizeY: 2,
    buildTime: 20,
    color: "#696969",
  },
  arcology: {
    id: "arcology",
    name: "Arcology",
    description: "Massive pop. capacity.",
    baseCost: 5000,
    costMultiplier: 1.4,
    effects: [{ target: "maxPopulation", value: 50, operation: "add" }],
    minAge: 5,
    maxAge: 7,
    icon: "🏙️",
    upgradesTo: null,
    sizeX: 3,
    sizeY: 3,
    buildTime: 40,
    color: "#2f4f4f",
  },
  foodGathering: {
    id: "foodGathering",
    name: "Foraging Post",
    description: "Basic income.",
    baseCost: 15,
    costMultiplier: 1.18,
    effects: [{ target: "baseIncome", value: 1.2, operation: "add" }],
    minAge: 0,
    maxAge: 1,
    icon: "🍇",
    upgradesTo: "farm",
    sizeX: 1,
    sizeY: 1,
    buildTime: 4,
    color: "#228b22",
  },
  farm: {
    id: "farm",
    name: "Farm",
    description: "Good income.",
    baseCost: 60,
    costMultiplier: 1.25,
    effects: [{ target: "baseIncome", value: 3.8, operation: "add" }],
    minAge: 1,
    maxAge: 3,
    icon: "🌾",
    upgradesTo: "factory",
    sizeX: 2,
    sizeY: 2,
    buildTime: 12,
    color: "#556b2f",
  },
  factory: {
    id: "factory",
    name: "Factory",
    description: "Strong income.",
    baseCost: 350,
    costMultiplier: 1.3,
    effects: [{ target: "baseIncome", value: 11, operation: "add" }],
    minAge: 3,
    maxAge: 5,
    icon: "🏭",
    upgradesTo: "robotFactory",
    sizeX: 3,
    sizeY: 2,
    buildTime: 25,
    color: "#808080",
  },
  robotFactory: {
    id: "robotFactory",
    name: "Automated Facility",
    description: "Excellent income.",
    baseCost: 2500,
    costMultiplier: 1.4,
    effects: [{ target: "baseIncome", value: 35, operation: "add" }],
    minAge: 5,
    maxAge: 7,
    icon: "🤖🏭",
    upgradesTo: null,
    sizeX: 3,
    sizeY: 3,
    buildTime: 50,
    color: "#778899",
  },
  studyCircle: {
    id: "studyCircle",
    name: "Study Circle",
    description: "Basic research.",
    baseCost: 30,
    costMultiplier: 1.2,
    effects: [{ target: "baseTechRate", value: 0.25, operation: "add" }],
    minAge: 0,
    maxAge: 2,
    icon: "📚",
    upgradesTo: "library",
    sizeX: 1,
    sizeY: 1,
    buildTime: 6,
    color: "#4169e1",
  },
  library: {
    id: "library",
    name: "Library",
    description: "Collect knowledge.",
    baseCost: 150,
    costMultiplier: 1.28,
    effects: [{ target: "baseTechRate", value: 0.7, operation: "add" }],
    minAge: 2,
    maxAge: 4,
    icon: "📖",
    upgradesTo: "university",
    sizeX: 2,
    sizeY: 1,
    buildTime: 15,
    color: "#4682b4",
  },
  university: {
    id: "university",
    name: "University",
    description: "Advanced research.",
    baseCost: 800,
    costMultiplier: 1.35,
    effects: [{ target: "baseTechRate", value: 2.0, operation: "add" }],
    minAge: 4,
    maxAge: 6,
    icon: "🎓",
    upgradesTo: "researchLab",
    sizeX: 3,
    sizeY: 2,
    buildTime: 30,
    color: "#000080",
  },
  researchLab: {
    id: "researchLab",
    name: "Research Lab",
    description: "Cutting-edge science.",
    baseCost: 4000,
    costMultiplier: 1.4,
    effects: [{ target: "baseTechRate", value: 5.5, operation: "add" }],
    minAge: 6,
    maxAge: 7,
    icon: "🧪",
    upgradesTo: null,
    sizeX: 2,
    sizeY: 2,
    buildTime: 60,
    color: "#191970",
  },
  woodenWall: {
    id: "woodenWall",
    name: "Wooden Palisade",
    description: "Basic defense.",
    baseCost: 50,
    costMultiplier: 1.05,
    effects: [{ target: "baseDefense", value: 10, operation: "add" }],
    minAge: 0,
    maxAge: 2,
    icon: "🪵",
    upgradesTo: "stoneWall",
    sizeX: 1,
    sizeY: 1,
    buildTime: 3,
    color: "#d2b48c",
  },
  stoneWall: {
    id: "stoneWall",
    name: "Stone Wall",
    description: "Improved defense.",
    baseCost: 100,
    costMultiplier: 1.05,
    effects: [{ target: "baseDefense", value: 25, operation: "add" }],
    minAge: 2,
    maxAge: 4,
    icon: "🧱",
    upgradesTo: "concrete",
    sizeX: 1,
    sizeY: 1,
    buildTime: 8,
    color: "#708090",
  },
  concrete: {
    id: "concrete",
    name: "Concrete Bunker",
    description: "Modern defense.",
    baseCost: 500,
    costMultiplier: 1.05,
    effects: [{ target: "baseDefense", value: 60, operation: "add" }],
    minAge: 4,
    maxAge: 6,
    icon: "🏛️",
    upgradesTo: "shieldGen",
    sizeX: 1,
    sizeY: 1,
    buildTime: 18,
    color: "#a9a9a9",
  },
  shieldGen: {
    id: "shieldGen",
    name: "Shield Generator",
    description: "Energy shield.",
    baseCost: 2500,
    costMultiplier: 1.6,
    effects: [{ target: "baseDefense", value: 150, operation: "add" }],
    minAge: 6,
    maxAge: 7,
    icon: "🛡️✨",
    upgradesTo: null,
    sizeX: 2,
    sizeY: 2,
    buildTime: 35,
    color: "#00ced1",
  },
};
const UNITS = {
  clubber: {
    id: "clubber",
    name: "Clubber",
    description: "Basic melee",
    cost: 10,
    upkeep: 0.1,
    maxHp: 30,
    baseAttack: 6,
    baseDefense: 2,
    baseSpeed: 3,
    population: 1,
    minAge: 0,
    maxAge: 1,
    icon: "🪨",
    trainTime: 2,
    isRanged: false,
  },
  spearman: {
    id: "spearman",
    name: "Spearman",
    description: "Decent melee",
    cost: 25,
    upkeep: 0.1,
    maxHp: 45,
    baseAttack: 9,
    baseDefense: 4,
    baseSpeed: 3,
    population: 1,
    minAge: 1,
    maxAge: 2,
    icon: "🔱",
    trainTime: 3,
    isRanged: false,
  },
  archer: {
    id: "archer",
    name: "Archer",
    description: "Ranged support",
    cost: 35,
    upkeep: 0.15,
    maxHp: 35,
    baseAttack: 12,
    baseDefense: 2,
    baseSpeed: 4,
    population: 1,
    minAge: 1,
    maxAge: 3,
    icon: "🏹",
    trainTime: 5,
    isRanged: true,
  },
  knight: {
    id: "knight",
    name: "Knight",
    description: "Heavy cavalry",
    cost: 90,
    upkeep: 0.25,
    maxHp: 120,
    baseAttack: 18,
    baseDefense: 12,
    baseSpeed: 5,
    population: 2,
    minAge: 2,
    maxAge: 4,
    icon: "🐎",
    trainTime: 10,
    isRanged: false,
  },
  catapult: {
    id: "catapult",
    name: "Catapult",
    description: "Siege Unit",
    cost: 130,
    upkeep: 1.0,
    maxHp: 50,
    baseAttack: 65,
    baseDefense: 5,
    baseSpeed: 1,
    population: 3,
    minAge: 2,
    maxAge: 4,
    icon: "⚪",
    trainTime: 28,
    aoeType: "splash_all_others",
    aoeDamagePercent: 0.25,
    isRanged: true,
  },
  musketeer: {
    id: "musketeer",
    name: "Musketeer",
    description: "Gunpowder unit",
    cost: 180,
    upkeep: 1.0,
    maxHp: 80,
    baseAttack: 35,
    baseDefense: 18,
    baseSpeed: 3,
    population: 2,
    minAge: 3,
    maxAge: 5,
    icon: "🔫",
    trainTime: 5,
    isRanged: true,
  },
  cannon: {
    id: "cannon",
    name: "Cannon",
    description: "Heavy Siege Unit",
    cost: 280,
    upkeep: 1.5,
    maxHp: 110,
    baseAttack: 200,
    baseDefense: 12,
    baseSpeed: 1,
    population: 4,
    minAge: 3,
    maxAge: 5,
    icon: "💣",
    trainTime: 40,
    aoeType: "splash_all_others",
    aoeDamagePercent: 0.33,
    isRanged: true,
  },
  rifleman: {
    id: "rifleman",
    name: "Rifleman",
    description: "Modern infantry",
    cost: 350,
    upkeep: 1.1,
    maxHp: 140,
    baseAttack: 60,
    baseDefense: 30,
    baseSpeed: 4,
    population: 2,
    minAge: 4,
    maxAge: 6,
    icon: "🔪",
    trainTime: 30,
    isRanged: true,
  },
  tank: {
    id: "tank",
    name: "Tank",
    description: "Armored Powerful Unit",
    cost: 700,
    upkeep: 2.0,
    maxHp: 350,
    baseAttack: 75,
    baseDefense: 70,
    baseSpeed: 3,
    population: 5,
    minAge: 4,
    maxAge: 6,
    icon: "🚜",
    trainTime: 50,
    aoeType: "splash_all_others",
    aoeDamagePercent: 0.4,
    isRanged: true,
  },
  commando: {
    id: "commando",
    name: "Commando",
    description: "Elite forces",
    cost: 900,
    upkeep: 1,
    maxHp: 200,
    baseAttack: 110,
    baseDefense: 60,
    baseSpeed: 6,
    population: 3,
    minAge: 5,
    maxAge: 7,
    icon: "🪖",
    trainTime: 45,
    isRanged: true,
  },
  helicopter: {
    id: "helicopter",
    name: "Attack Heli",
    description: "Air assault AoE",
    cost: 1800,
    upkeep: 4,
    maxHp: 380,
    baseAttack: 180,
    baseDefense: 90,
    baseSpeed: 7,
    population: 6,
    minAge: 5,
    maxAge: 7,
    icon: "🚁",
    trainTime: 70,
    aoeType: "splash_all_others",
    aoeDamagePercent: 0.4,
    isRanged: true,
  },
  mech: {
    id: "mech",
    name: "Battle Mech",
    description: "War machine",
    cost: 4500,
    upkeep: 7.5,
    maxHp: 550,
    baseAttack: 250,
    baseDefense: 170,
    baseSpeed: 3,
    population: 8,
    minAge: 6,
    maxAge: 7,
    icon: "🤖💥",
    trainTime: 100,
    aoeType: "splash_all_others",
    aoeDamagePercent: 0.35,
    isRanged: true,
  },
  drone: {
    id: "drone",
    name: "Combat Drone",
    description: "Autonomous unit",
    cost: 2700,
    upkeep: 6,
    maxHp: 220,
    baseAttack: 200,
    baseDefense: 110,
    baseSpeed: 8,
    population: 4,
    minAge: 6,
    maxAge: 7,
    icon: "🛸",
    trainTime: 80,
    isRanged: true,
  },
};
const TECHNOLOGIES = {
  fire: {
    id: "fire",
    name: "Fire",
    description: "Control fire.",
    cost: 25,
    effects: [
      { target: "incomeMultiplier", value: 1.2, operation: "multiply" },
    ],
    researchTime: 30,
    minAge: 0,
    icon: "🔥",
    prereqs: [],
  },
  stoneTools: {
    id: "stoneTools",
    name: "Stone Tools",
    description: "Basic tools.",
    cost: 40,
    effects: [{ target: "globalAttackBoost", value: 1, operation: "add" }],
    researchTime: 45,
    minAge: 0,
    icon: "🪓",
    prereqs: [],
  },
  writing: {
    id: "writing",
    name: "Writing",
    description: "Record knowledge.",
    cost: 100,
    effects: [
      { target: "techRateMultiplier", value: 1.3, operation: "multiply" },
    ],
    researchTime: 60,
    minAge: 1,
    icon: "📝",
    prereqs: [],
  },
  agriculture: {
    id: "agriculture",
    name: "Agriculture",
    description: "Cultivate crops.",
    cost: 120,
    effects: [
      { target: "incomeMultiplier", value: 1.5, operation: "multiply" },
    ],
    researchTime: 90,
    minAge: 1,
    icon: "🌱",
    prereqs: [],
  },
  metalWorking: {
    id: "metalWorking",
    name: "Metal Working",
    description: "Forge metals.",
    cost: 150,
    effects: [
      { target: "globalDefenseBoost", value: 2, operation: "add" },
      { target: "defenseMultiplier", value: 1.05, operation: "multiply" },
    ],
    researchTime: 120,
    minAge: 1,
    icon: "⚒️",
    prereqs: ["stoneTools"],
  },
  mathematics: {
    id: "mathematics",
    name: "Mathematics",
    description: "Develop math.",
    cost: 300,
    effects: [
      { target: "techRateMultiplier", value: 1.3, operation: "multiply" },
    ],
    researchTime: 150,
    minAge: 2,
    icon: "➗",
    prereqs: ["writing"],
  },
  feudalism: {
    id: "feudalism",
    name: "Feudalism",
    description: "Organize society.",
    cost: 350,
    effects: [{ target: "maxPopulation", value: 10, operation: "add" }],
    researchTime: 180,
    minAge: 2,
    icon: "👑",
    prereqs: [],
  },
  steelMaking: {
    id: "steelMaking",
    name: "Steel Making",
    description: "Stronger metal.",
    cost: 400,
    effects: [
      { target: "globalDefenseBoost", value: 3, operation: "add" },
      { target: "defenseMultiplier", value: 1.1, operation: "multiply" },
    ],
    researchTime: 210,
    minAge: 2,
    icon: "🗡️",
    prereqs: ["metalWorking"],
  },
  printing: {
    id: "printing",
    name: "Printing Press",
    description: "Spread knowledge.",
    cost: 600,
    effects: [
      { target: "techRateMultiplier", value: 1.5, operation: "multiply" },
    ],
    researchTime: 240,
    minAge: 3,
    icon: "📰",
    prereqs: ["writing"],
  },
  gunpowder: {
    id: "gunpowder",
    name: "Gunpowder",
    description: "Explosive powder.",
    cost: 700,
    effects: [{ target: "globalAttackBoost", value: 10, operation: "add" }],
    researchTime: 270,
    minAge: 3,
    icon: "💥",
    prereqs: [],
  },
  banking: {
    id: "banking",
    name: "Banking",
    description: "Financial systems.",
    cost: 800,
    effects: [
      { target: "incomeMultiplier", value: 1.25, operation: "multiply" },
    ],
    researchTime: 300,
    minAge: 3,
    icon: "💰",
    prereqs: ["mathematics"],
  },
  steamPower: {
    id: "steamPower",
    name: "Steam Power",
    description: "Harness steam.",
    cost: 1500,
    effects: [
      { target: "incomeMultiplier", value: 2.3, operation: "multiply" },
    ],
    researchTime: 360,
    minAge: 4,
    icon: "⚙️",
    prereqs: [],
  },
  massProduction: {
    id: "massProduction",
    name: "Mass Production",
    description: "Assembly lines.",
    cost: 2000,
    effects: [
      { target: "unitCostMultiplier", value: 0.95, operation: "multiply" },
      { target: "unitTrainTimeMultiplier", value: 0.85, operation: "multiply" },
    ],
    researchTime: 420,
    minAge: 4,
    icon: "🏭",
    prereqs: ["steamPower"],
  },
  medicine: {
    id: "medicine",
    name: "Medicine",
    description: "Healthcare.",
    cost: 2500,
    effects: [{ target: "maxPopulation", value: 20, operation: "add" }],
    researchTime: 480,
    minAge: 4,
    icon: "💊",
    prereqs: [],
  },
  electronics: {
    id: "electronics",
    name: "Electronics",
    description: "Electronic devices.",
    cost: 5000,
    effects: [
      { target: "techRateMultiplier", value: 2.7, operation: "multiply" },
    ],
    researchTime: 600,
    minAge: 5,
    icon: "💡",
    prereqs: [],
  },
  nuclearPower: {
    id: "nuclearPower",
    name: "Nuclear Power",
    description: "Atomic energy.",
    cost: 8000,
    effects: [
      { target: "incomeMultiplier", value: 1.5, operation: "multiply" },
      { target: "globalAttackBoost", value: 2, operation: "add" }
    ],
    researchTime: 720,
    minAge: 5,
    icon: "☢️",
    prereqs: [],
  },
  advancedMaterials: {
    id: "advancedMaterials",
    name: "Advanced Materials",
    description: "New materials.",
    cost: 10000,
    effects: [
      { target: "defenseMultiplier", value: 1.2, operation: "multiply" },
      { target: "globalDefenseBoost", value: 8, operation: "add" },
    ],
    researchTime: 840,
    minAge: 5,
    icon: "🔬",
    prereqs: ["electronics"],
  },
  artificialIntelligence: {
    id: "artificialIntelligence",
    name: "AI",
    description: "Thinking machines.",
    cost: 20000,
    effects: [
      { target: "techRateMultiplier", value: 2.0, operation: "multiply" },
      { target: "unitTrainTimeMultiplier", value: 0.75, operation: "multiply" },
    ],
    researchTime: 1000,
    minAge: 6,
    icon: "🧠",
    prereqs: ["electronics"],
  },
  quantumComputing: {
    id: "quantumComputing",
    name: "Quantum Computing",
    description: "Quantum computers.",
    cost: 30000,
    effects: [
      { target: "techRateMultiplier", value: 3.2, operation: "multiply" },
    ],
    researchTime: 1200,
    minAge: 6,
    icon: "⚛️",
    prereqs: ["artificialIntelligence"],
  },
  fusion: {
    id: "fusion",
    name: "Fusion Power",
    description: "Power of stars.",
    cost: 50000,
    effects: [
      { target: "incomeMultiplier", value: 2.0, operation: "multiply" },
    ],
    researchTime: 1500,
    minAge: 6,
    icon: "✨",
    prereqs: ["nuclearPower"],
  },
  nanotech: {
    id: "nanotech",
    name: "Nanotechnology",
    description: "Atomic scale tech.",
    cost: 40000,
    effects: [
      { target: "defenseMultiplier", value: 2.3, operation: "multiply" },
      { target: "globalAttackBoost", value: 25, operation: "add" },
    ],
    researchTime: 1300,
    minAge: 6,
    icon: "🧬",
    prereqs: ["advancedMaterials"],
  },
};
const ACHIEVEMENTS_DATA = [
  {
    id: "firstBuilding",
    name: "Foundation",
    description: "Build your first building",
    condition: (gs) => gs.stats.buildingsConstructed >= 1,
  },
  {
    id: "firstUnit",
    name: "Recruitment",
    description: "Train your first unit",
    condition: (gs) => gs.units.length >= 1 || gs.trainingQueue.length > 0,
  },
  {
    id: "firstTech",
    name: "Innovation",
    description: "Research your first technology",
    condition: (gs) => gs.stats.techsResearched >= 1,
  },
  {
    id: "firstBattle",
    name: "Baptism by Fire",
    description: "Win your first battle",
    condition: (gs) => gs.stats.battlesWon >= 1,
  },
  {
    id: "firstRaidDefense",
    name: "Shields Up!",
    description: "Successfully defend against a raid",
    condition: (gs) => gs.stats.raidsDefended >= 1,
  },
  {
    id: "ageAncient",
    name: "Ancient Times",
    description: "Advance to the Ancient Age",
    condition: (gs) => gs.age >= 1,
  },
  {
    id: "ageMedieval",
    name: "Medieval Times",
    description: "Advance to the Medieval Age",
    condition: (gs) => gs.age >= 2,
  },
  {
    id: "ageRenaissance",
    name: "Renaissance Era",
    description: "Advance to the Renaissance Age",
    condition: (gs) => gs.age >= 3,
  },
  {
    id: "ageIndustrial",
    name: "Industrial Power",
    description: "Advance to the Industrial Age",
    condition: (gs) => gs.age >= 4,
  },
  {
    id: "ageModern",
    name: "Modern Marvels",
    description: "Advance to the Modern Age",
    condition: (gs) => gs.age >= 5,
  },
  {
    id: "ageFuture",
    name: "Into The Future",
    description: "Advance to the Future Age",
    condition: (gs) => gs.age >= 6,
  },
  {
    id: "richEmpire",
    name: "Economic Powerhouse",
    description: "Reach 25,000 gold",
    condition: (gs) => gs.resources.gold >= 25000,
  },
  {
    id: "massiveArmy",
    name: "Military Might",
    description: "Have an army strength of 1000",
    condition: (gs) => calculateArmyStrength() >= 1000,
  },
  {
    id: "techGiant",
    name: "Technological Supremacy",
    description: "Research 15 technologies",
    condition: (gs) => gs.stats.techsResearched >= 15,
  },
  {
    id: "cityBuilder",
    name: "Metropolis",
    description: "Construct 20 buildings",
    condition: (gs) =>
      gs.buildings.reduce((acc, b) => acc + (b.isConstructed ? 1 : 0), 0) >= 20,
  },
  {
    id: "warMonger",
    name: "Conqueror",
    description: "Win 25 battles (outposts or raids)",
    condition: (gs) => gs.stats.battlesWon >= 25,
  },
  {
    id: "landBaron",
    name: "Land Baron",
    description: "Expand your territory 5 times",
    condition: (gs) => gs.stats.mapExpansions >= 5,
  },
];
const TUTORIAL_STEPS = [
  {
    title: "Welcome, Ruler!",
    content:
      "Your journey to build a timeless empire begins! Place buildings on the map for resources and population. Train units to form armies. Research technologies to unlock new eras and powers. Defend against raiders and conquer rival outposts!",
  },
  {
    title: "The City Map",
    content:
      "The main view shows your city. Initially, your territory is small. Select buildings from the 'City & Buildings' tab on the right. Then click on an available tile on the map to place it. Buildings take time to construct! Drag the map with your mouse to explore.",
  },
  {
    title: "Expanding Your Domain",
    content:
      "Need more space? In the 'City & Buildings' tab, under 'City Management', you can purchase more land to expand your buildable area. Each expansion costs more gold. Your 'owned' area is visible on the main map and minimap (bottom-right).",
  },
  {
    title: "World & Outposts",
    content:
      "Beyond your city, the world map holds enemy outposts. As you expand or your armies travel, you might discover them. Closer outposts may reveal their strength, while distant ones are unknown. Click discovered outposts on the map to interact.",
  },
  {
    title: "Deploying Armies",
    content:
      "To attack world map outposts, you must deploy your units. This takes time based on distance. Deployed units are unavailable for city defense or random battles until they return. Manage deployed armies in the 'Units & Battle' tab.",
  },
  {
    title: "Resources & Upkeep",
    content:
      "Gold is key. Income is generated per second, but units have an Upkeep cost, reducing your net income. Manage your Population - you can't train units if you don't have space! Tech Points unlock progress.",
  },
  {
    title: "Your Army: Units & Training",
    content:
      "Units are trained in stacks. Each unit type has stats: HP, Attack, Defense, Speed, and requires Population. Training takes time and Gold, and units are added to a queue. View your army stacks and train new ones in the 'Units & Battle' tab.",
  },
  {
    title: "Combat: Turn-Based Strategy",
    content:
      "Engage enemy outposts (world map or random encounters) or defend against raids in turn-based battles.\n\nYour Turn: Select one of your available unit stacks (that hasn't acted yet this turn). Then, either click an enemy stack to ATTACK it, or press the DEFEND button. After the action, that stack cannot act again this turn. When finished, press 'End Turn'.\n\nSpecial Powers: As you advance through Ages, you unlock powerful abilities usable in battle!",
  },
  {
    title: "Advancement: Research & Ages",
    content:
      "Use Tech Points to research technologies in the 'Research' tab. These provide powerful bonuses. Accumulate enough Tech Points to advance to the Next Age, unlocking new buildings, units, techs, stronger foes, and potentially a unique Age Power usable in battle! Buildings may upgrade automatically when you age up (if space permits)!",
  },
  {
    title: "Danger: Enemy Raids!",
    content:
      "Beware! Raiders will periodically attempt to pillage your settlement. A warning will appear on your sidebar, and you'll see raiders appear on your city map! Click the raid alert to intercept and fight them off. If ignored or if you lose, they will damage or destroy your buildings!",
  },
  {
    title: "Lost? Go Home!",
    content:
      "If you pan too far from your city center on the map, a 'Return to Base' button will appear on the top-left of the map view. Click it to recenter your view.",
  },
  {
    title: "Forge Your Destiny!",
    content:
      "The path is clear. Expand, research, conquer, and defend. May your empire stand the test of time! Good luck.",
  },
];
const DOMElements = {
    
  gameCanvas: document.getElementById("game-canvas"),
  gameCanvasContainer: document.getElementById("game-canvas-container"),
  minimapCanvas: document.getElementById("minimap-canvas"),
  minimapContainer: document.getElementById("minimap-container"),
  backToBaseButton: document.getElementById("back-to-base-button"),
  messagesContainer: document.getElementById("messages-container"),
  notification: document.getElementById("notification"),
  notificationMessage: document.getElementById("notification-message"),
  eraLabelDisplay: document.getElementById("era-label-display"),
  achievementNotificationPopup: document.getElementById(
    "achievement-notification-popup",
  ),
  achievementNamePopup: document.getElementById("achievement-name-popup"),
  resourceDisplaysContainer: document.getElementById("resource-displays"),
  armyStrengthDisplay: document.getElementById("army-strength-display"),
  tabButtons: document.querySelectorAll(".tab-button"),
  tabContents: document.querySelectorAll(".tab-content"),
  buildingsContainer: document.getElementById("buildings-container"),
  unitsContainer: document.getElementById("units-container"),
  constructionQueueDisplay: document.getElementById(
    "construction-queue-display",
  ),
  constructionQueueList: document.getElementById("construction-queue-list"),
  constructionQueueCount: document.getElementById("construction-queue-count"),
  techContainer: document.getElementById("tech-container"),
  currentUnitsDisplay: document.getElementById("current-units-display"),
  currentUnitsList: document.getElementById("current-units-list"),
  deployedArmiesSection: document.getElementById("deployed-armies-section"),
  deployedArmiesList: document.getElementById("deployed-armies-list"),
  deployedArmiesCount: document.getElementById("deployed-armies-count"),
  trainingQueueDisplay: document.getElementById("training-queue-display"),
  trainingQueueList: document.getElementById("training-queue-list"),
  trainingQueueCount: document.getElementById("training-queue-count"),
  currentResearchDisplay: document.getElementById("current-research-display"),
  researchProgressBar: document.getElementById("research-progress-bar"),
  researchedTechsList: document.getElementById("researched-techs-list"),
  advanceAgeButton: document.getElementById("advance-age-button"),
  advanceAgeCostDisplay: document.getElementById("advance-age-cost-display"),
  ageProgressBar: document.getElementById("age-progress-bar"),
  battleButton: document.getElementById("battle-button"),
  enemySelectionContainer: document.getElementById("enemy-selection-container"),
  enemySelectionList: document.getElementById("enemy-selection-list"),
  battleModalOverlay: document.getElementById("battle-modal-overlay"),
  battleModalCloseButton: document.getElementById("battle-modal-close-button"),
  battleTitleText: document.getElementById("battle-title-text"),
  battleArea: document.getElementById("battle-area"),
  playerBattlePartyContainer: document.getElementById("player-battle-party"),
  enemyBattlePartyContainer: document.getElementById("enemy-battle-party"),
  battleActionAttack: document.getElementById("battle-action-attack"),
  battleActionDefend: document.getElementById("battle-action-defend"),
  battleEndTurnButton: document.getElementById("battle-end-turn-button"),
  battleAgePowersContainer: document.getElementById(
    "battle-age-powers-container",
  ),
  battleLogContainerModal: document.getElementById(
    "battle-log-container-modal",
  ),
  battleLeaveButton: document.getElementById("battle-leave-button"),
  saveButton: document.getElementById("save-button"),
  loadButton: document.getElementById("load-button"),
  tutorialButton: document.getElementById("tutorial-button"),
  achievementsButton: document.getElementById("achievements-button"),
  tutorialOverlay: document.getElementById("tutorial-overlay"),
  tutorialTitle: document.getElementById("tutorial-title"),
  tutorialBodyContent: document.getElementById("tutorial-body-content"),
  tutorialPrevButton: document.getElementById("tutorial-prev-button"),
  tutorialNextButton: document.getElementById("tutorial-next-button"),
  tutorialCloseButton: document.getElementById("tutorial-close-button"),
  tutorialForceCloseButton: document.getElementById(
    "tutorial-force-close-button",
  ),
  upgradePanelOverlay: document.getElementById("upgrade-panel-overlay"),
  upgradesContainer: document.getElementById("upgrades-container"),
  upgradePanelCloseButton: document.getElementById(
    "upgrade-panel-close-button",
  ),
  genericOverlay: document.getElementById("generic-overlay"),
  genericOverlayContent: document.getElementById("generic-overlay-content"),
  genericOverlayCloseButton: document.getElementById(
    "generic-overlay-close-button",
  ),
  tooltipElement: document.getElementById("tooltip-element"),
  raidAlertSection: document.getElementById("raid-alert-section"),
  activeRaidsList: document.getElementById("active-raids-list"),
  projectileContainer: document.getElementById("projectile-container"),
  cancelPlacementButton: document.getElementById("cancel-placement-button"),
  expandLandNorthButton: document.getElementById("expand-land-north-button"),
  expandLandSouthButton: document.getElementById("expand-land-south-button"),
  expandLandWestButton: document.getElementById("expand-land-west-button"),
  expandLandEastButton: document.getElementById("expand-land-east-button"),
  expandCostNorth: document.getElementById("expand-cost-north"),
  expandCostSouth: document.getElementById("expand-cost-south"),
  expandCostWest: document.getElementById("expand-cost-west"),
  expandCostEast: document.getElementById("expand-cost-east"),
  worldMapOutpostInteractionModal: document.getElementById(
    "world-map-outpost-interaction-modal",
  ),
  worldMapOutpostModalCloseButton: document.getElementById(
    "world-map-outpost-modal-close-button",
  ),
  worldMapOutpostModalTitle: document.getElementById(
    "world-map-outpost-modal-title",
  ),
  worldMapOutpostModalBody: document.getElementById(
    "world-map-outpost-modal-body",
  ),
  worldMapOutpostModalActions: document.getElementById(
    "world-map-outpost-modal-actions",
  ),



  deployUnitSelectionModal: document.getElementById("deploy-unit-selection-modal"),
  deployUnitSelectionModalCloseButton: document.getElementById("deploy-unit-selection-modal-close-button"),
  deployUnitSelectionModalTitle: document.getElementById("deploy-unit-selection-modal-title"),
  deployUnitSelectionModalBody: document.getElementById("deploy-unit-selection-modal-body"),
  deployTravelTimeEstimate: document.getElementById("deploy-travel-time-estimate"),
  confirmDeploymentButton: document.getElementById("confirm-deployment-button"),
  cancelDeploymentSelectionButton: document.getElementById("cancel-deployment-selection-button"),
  resignButton: document.getElementById("resign-button"),
  editBuildingsButton: document.getElementById("edit-buildings-button"),
  editModeActionsOverlay: document.getElementById("edit-mode-actions-overlay"),
  editModeActionsContent: document.getElementById("edit-mode-actions-content"),
  selectedBuildingInfoEdit: document.getElementById("selected-building-info-edit"),
  moveBuildingButtonEdit: document.getElementById("move-building-button-edit"),
  deleteBuildingButtonEdit: document.getElementById("delete-building-button-edit"),
  cancelBuildingSelectionButtonEdit: document.getElementById("cancel-building-selection-button-edit"),




};

let ctx;
let minimapCtx;
let gameState = {};
let nextRaidCheckTime = 0;
let gameLoopIntervalId;
let achievementCheckIntervalId;
const RAID_CHECK_INTERVAL = 15000;
const RAID_BASE_DURATION_BEFORE_DESTRUCTION = 120;
const SAVE_GAME_KEY = "ageOfEmpireTycoonDefinitiveSave_V7_Map_Fix23";

const TILE_SIZE = 40;
const TILE_WIDTH_ISO = TILE_SIZE * 1.732;
const TILE_HEIGHT_ISO = TILE_SIZE;
const MAX_MAP_GRID_DIM = 50;

let camera = { x: 0, y: 0, zoom: 1 };
let mouseGridPos = { x: -1, y: -1 };
let currentPlacingBuildingId = null;
let isPanning = false;
let panStartX, panStartY;
let lastClickedWorldOutpost = null;

let currentDeploymentTargetOutpost = null;
let currentDeploymentTravelTime = 0;



const BASE_LOCATION_GRID = { x: 0, y: 0 };
const MINIMAP_PIXEL_PER_TILE = 2;
const BACK_TO_BASE_THRESHOLD = TILE_WIDTH_ISO * 10;

function getDefaultGameState() {
  return {
    resources: {
      gold: 100,
      population: 0,
      maxPopulation: 10,
      technologyPoints: 10,
    },
    modifiers: {
      baseIncome: 1.5,
      incomeMultiplier: 1,
      baseTechRate: 0.15,
      techRateMultiplier: 1,
      baseDefense: 5,
      defenseMultiplier: 1,
      globalAttackBoost: 0,
      globalDefenseBoost: 0,
      unitCostMultiplier: 1,
      unitTrainTimeMultiplier: 1,
    },
    age: 0,
    buildings: [],
    constructionQueue: [],
    units: [],
    trainingQueue: [],
    technologies: [],
    currentResearch: { id: null, progress: 0, timeToComplete: 0 },
    map: {
      ownedTilesX: [-5, 5],
      ownedTilesY: [-5, 5],
      nextExpansionCost: 100,
      discoveredTiles: {},
    },
    worldMap: {
      outposts: [],
      deployedArmies: [],
    },
    placement: {
      isPlacing: false,
      buildingId: null,
      validPlacement: false,
    },

    editMode: { // New state for edit mode
        isActive: false,
        selectedBuildingInstance: null, 
        isMovingBuilding: false,
        originalMovingBuildingData: null 
    },


    mapEntities: {
      raiders: [],
    },
    battle: {
      isActive: false,
      playerParty: [],
      enemyParty: [],
      turnOrder: [],
      currentTurn: "player",
      actedStackIdsThisTurn: [],
      selectedPlayerStackId: null,
      selectedAction: null,
      selectedTargetStackBattleId: null,
      log: [],
      rewards: null,
      battleType: null,
      agePowerCooldowns: {},
      isAwaitingTargetSelection: false,
      targetingSource: null,
      playerBuffs: {},
      enemyBuffs: {},
      currentDeployedArmyId: null,
    },
    stats: {
      timePlayed: 0,
      battlesWon: 0,
      battlesLost: 0,
      enemiesDefeated: 0,
      unitsTrained: 0,
      buildingsConstructed: 0,
      techsResearched: 0,
      raidsSpawned: 0,
      raidsDefended: 0,
      buildingsLostToRaids: 0,
      mapExpansions: 0,
    },
    activeRaids: [],
    achievements: [],
    tutorial: { step: 0, complete: false },
    gameVersion: "6.0.3",
  };
}




function handleResignGame() {
  if (confirm("Are you sure you want to resign? This will delete your current saved game and start a new one.")) {
    localStorage.removeItem(SAVE_GAME_KEY);
    showNotification("You have resigned. A new game will start.", "info", 4000);
    
    // Clear existing game intervals to prevent them from running on the old state
    if (gameLoopIntervalId) clearInterval(gameLoopIntervalId);
    if (achievementCheckIntervalId) clearInterval(achievementCheckIntervalId);

    // Reset critical UI elements or hide them temporarily
    DOMElements.raidAlertSection.style.display = 'none';
    DOMElements.activeRaidsList.innerHTML = '';
    DOMElements.messagesContainer.innerHTML = '';


    // A short delay before full re-initialization can sometimes help
    // ensure the UI is cleared and ready for the new game state.
    setTimeout(() => {
        gameState = getDefaultGameState(); // Fully reset gameState
        initGame(); // Re-initialize the entire game
        addMessage("New game started after resignation.", true);
    }, 100); // 100ms delay
  }
}







function isTileOwned(gridX, gridY) {
  return (
    gridX >= gameState.map.ownedTilesX[0] &&
    gridX <= gameState.map.ownedTilesX[1] &&
    gridY >= gameState.map.ownedTilesY[0] &&
    gridY <= gameState.map.ownedTilesY[1]
  );
}
function markTileDiscovered(gridX, gridY) {
  gameState.map.discoveredTiles[`${gridX},${gridY}`] = true;
}
function isTileDiscovered(gridX, gridY) {
  return !!gameState.map.discoveredTiles[`${gridX},${gridY}`];
}

function discoverArea(centerX, centerY, radius) {
  for (let dy = -radius; dy <= radius; dy++) {
    for (let dx = -radius; dx <= radius; dx++) {
      if (dx * dx + dy * dy <= radius * radius) {
        markTileDiscovered(centerX + dx, centerY + dy);
      }
    }
  }
}

function canPlaceBuilding(buildingDef, startGridX, startGridY, isNewConstructionPlacement = false, movingBuildingIdToIgnore = null) {
  if (!buildingDef) return { valid: false, reason: "invalid_building_def" };

  if (isNewConstructionPlacement) {
    for (const outpost of gameState.worldMap.outposts) {
      if (outpost.isDefeated || !outpost.isDiscovered) continue;
      const outpostCoreX = outpost.gridX;
      const outpostCoreY = outpost.gridY;
      const bufferZone = 2;
      const forbiddenMinX = outpostCoreX - bufferZone;
      const forbiddenMaxX = outpostCoreX + bufferZone;
      const forbiddenMinY = outpostCoreY - bufferZone;
      const forbiddenMaxY = outpostCoreY + bufferZone;

      for (let y = 0; y < buildingDef.sizeY; y++) {
        for (let x = 0; x < buildingDef.sizeX; x++) {
          const buildingTileX = startGridX + x;
          const buildingTileY = startGridY + y;
          if (
            buildingTileX >= forbiddenMinX && buildingTileX <= forbiddenMaxX &&
            buildingTileY >= forbiddenMinY && buildingTileY <= forbiddenMaxY
          ) {
            return { valid: false, reason: "outpost_proximity", outpostName: outpost.name };
          }
        }
      }
    }
  }

  for (let y = 0; y < buildingDef.sizeY; y++) {
    for (let x = 0; x < buildingDef.sizeX; x++) {
      const checkX = startGridX + x;
      const checkY = startGridY + y;
      if (!isTileOwned(checkX, checkY)) {
        return { valid: false, reason: "not_owned" };
      }
      const existingBuilding = getBuildingAtGrid(checkX, checkY);
      if (existingBuilding !== null && existingBuilding.id !== movingBuildingIdToIgnore) {
        return { valid: false, reason: "obstructed" };
      }
    }
  }
  return { valid: true, reason: null };
}

function getBuildingAtGrid(gridX, gridY) {
  for (const building of gameState.buildings) {
    if (building.isConstructed || building.isPlaceholder) {
      if (
        gridX >= building.gridX &&
        gridX < building.gridX + building.sizeX &&
        gridY >= building.gridY &&
        gridY < building.gridY + building.sizeY
      ) {
        return building;
      }
    }
  }
  return null;
}

function expandMap(direction) {
  const cost = gameState.map.nextExpansionCost;
  if (gameState.resources.gold < cost) {
    showNotification("Not enough gold to expand territory!", "error");
    return;
  }

  const expansionAmount = 2;

  let expanded = false;
  let newMinX = gameState.map.ownedTilesX[0],
    newMaxX = gameState.map.ownedTilesX[1];
  let newMinY = gameState.map.ownedTilesY[0],
    newMaxY = gameState.map.ownedTilesY[1];

  switch (direction) {
    case "N":
      if (gameState.map.ownedTilesY[0] > -MAX_MAP_GRID_DIM) {
        newMinY = Math.max(
          -MAX_MAP_GRID_DIM,
          gameState.map.ownedTilesY[0] - expansionAmount,
        );
        expanded = true;
      }
      break;
    case "S":
      if (gameState.map.ownedTilesY[1] < MAX_MAP_GRID_DIM) {
        newMaxY = Math.min(
          MAX_MAP_GRID_DIM,
          gameState.map.ownedTilesY[1] + expansionAmount,
        );
        expanded = true;
      }
      break;
    case "W":
      if (gameState.map.ownedTilesX[0] > -MAX_MAP_GRID_DIM) {
        newMinX = Math.max(
          -MAX_MAP_GRID_DIM,
          gameState.map.ownedTilesX[0] - expansionAmount,
        );
        expanded = true;
      }
      break;
    case "E":
      if (gameState.map.ownedTilesX[1] < MAX_MAP_GRID_DIM) {
        newMaxX = Math.min(
          MAX_MAP_GRID_DIM,
          gameState.map.ownedTilesX[1] + expansionAmount,
        );
        expanded = true;
      }
      break;
  }

  if (expanded) {
    gameState.resources.gold -= cost;
    gameState.map.nextExpansionCost = Math.floor(cost * 1.5);
    gameState.stats.mapExpansions++;

    gameState.map.ownedTilesX = [newMinX, newMaxX];
    gameState.map.ownedTilesY = [newMinY, newMaxY];

    for (let gx = newMinX; gx <= newMaxX; gx++) {
      for (let gy = newMinY; gy <= newMaxY; gy++) {
        markTileDiscovered(gx, gy);
      }
    }

    const visionRadiusAfterExpansion = 20; 
    if (direction === "N") {
        for (let gx = newMinX; gx <= newMaxX; gx++) {
            discoverArea(gx, newMinY, visionRadiusAfterExpansion);
        }
    } else if (direction === "S") {
        for (let gx = newMinX; gx <= newMaxX; gx++) {
            discoverArea(gx, newMaxY, visionRadiusAfterExpansion);
        }
    } else if (direction === "W") {
        for (let gy = newMinY; gy <= newMaxY; gy++) {
            discoverArea(newMinX, gy, visionRadiusAfterExpansion);
        }
    } else if (direction === "E") {
        for (let gy = newMinY; gy <= newMaxY; gy++) {
            discoverArea(newMaxX, gy, visionRadiusAfterExpansion);
        }
    }
    
    discoverArea(newMinX, newMinY, visionRadiusAfterExpansion);
    discoverArea(newMaxX, newMinY, visionRadiusAfterExpansion);
    discoverArea(newMinX, newMaxY, visionRadiusAfterExpansion);
    discoverArea(newMaxX, newMaxY, visionRadiusAfterExpansion);

    showNotification(`Territory expanded ${direction}!`, "success");
    addMessage(
      `Territory expanded ${direction}. New cost: ${formatNumber(gameState.map.nextExpansionCost)}G`,
    );
    updateExpandLandButtonCosts();
    generateWorldOutpostsIfNeeded();
    renderGameView();
    updateAllUIDisplays();
  } else {
    showNotification("Cannot expand further in that direction.", "info");
  }
}




function updateExpandLandButtonCosts() {
  const cost = formatNumber(gameState.map.nextExpansionCost);
  DOMElements.expandCostNorth.textContent = cost;
  DOMElements.expandCostSouth.textContent = cost;
  DOMElements.expandCostWest.textContent = cost;
  DOMElements.expandCostEast.textContent = cost;
  DOMElements.expandLandNorthButton.disabled =
    gameState.map.ownedTilesY[0] <= -MAX_MAP_GRID_DIM ||
    gameState.resources.gold < gameState.map.nextExpansionCost;
  DOMElements.expandLandSouthButton.disabled =
    gameState.map.ownedTilesY[1] >= MAX_MAP_GRID_DIM ||
    gameState.resources.gold < gameState.map.nextExpansionCost;
  DOMElements.expandLandWestButton.disabled =
    gameState.map.ownedTilesX[0] <= -MAX_MAP_GRID_DIM ||
    gameState.resources.gold < gameState.map.nextExpansionCost;
  DOMElements.expandLandEastButton.disabled =
    gameState.map.ownedTilesX[1] >= MAX_MAP_GRID_DIM ||
    gameState.resources.gold < gameState.map.nextExpansionCost;
}

function uniqueId(prefix = "") {
  return (
    prefix +
    Date.now().toString(36) +
    Math.random().toString(36).substring(2, 7)
  );
}
function formatNumber(num, decimals = 0) {
  if (num === undefined || num === null) return "0";
  return Number(num)
    .toFixed(decimals)
    .replace(/\B(?=(\d{3})+(?!\d))/g, ",");
}
function showNotification(message, type = "info", duration = 3000) {
  DOMElements.notificationMessage.textContent = message;
  DOMElements.notification.className = "";
  DOMElements.notification.classList.add(type, "show");
  setTimeout(() => {
    DOMElements.notification.classList.remove("show");
  }, duration);
}
function addMessage(text, isImportant = false) {
  const el = document.createElement("div");
  el.classList.add("message");
  if (isImportant) el.style.fontWeight = "bold";
  el.textContent = text;
  DOMElements.messagesContainer.appendChild(el);
  DOMElements.messagesContainer.scrollTop =
    DOMElements.messagesContainer.scrollHeight;
  while (DOMElements.messagesContainer.children.length > 20)
    DOMElements.messagesContainer.firstChild.remove();
}
function showModal(modalElement) {
  modalElement.classList.add("visible");
}
function hideModal(modalElement) {
  modalElement.classList.remove("visible");
}
let tooltipTimeout;
function displayTooltip(event) {
  const target = event.target.closest("[data-tooltip]");
  if (!target) return;
  const tooltipText = target.dataset.tooltip;
  if (!tooltipText) return;
  clearTimeout(tooltipTimeout);
  DOMElements.tooltipElement.innerHTML = tooltipText;
  DOMElements.tooltipElement.classList.add("visible");
  const updatePosition = (e) => {
    let x = e.clientX + 15;
    let y = e.clientY + 15;
    const rect = DOMElements.tooltipElement.getBoundingClientRect();
    const vpW = window.innerWidth;
    const vpH = window.innerHeight;
    if (x + rect.width > vpW) x = e.clientX - rect.width - 15;
    if (y + rect.height > vpH) y = e.clientY - rect.height - 15;
    DOMElements.tooltipElement.style.left = `${x}px`;
    DOMElements.tooltipElement.style.top = `${y}px`;
  };
  updatePosition(event);
  document.addEventListener("mousemove", updatePositionTooltipHandler);
  target.addEventListener("mouseout", hideTooltip, { once: true });
}
function updatePositionTooltipHandler(e) {
  if (DOMElements.tooltipElement.classList.contains("visible")) {
    let x = e.clientX + 15;
    let y = e.clientY + 15;
    const rect = DOMElements.tooltipElement.getBoundingClientRect();
    const vpW = window.innerWidth;
    const vpH = window.innerHeight;
    if (x + rect.width > vpW) x = e.clientX - rect.width - 15;
    if (y + rect.height > vpH) y = e.clientY - rect.height - 15;
    DOMElements.tooltipElement.style.left = `${x}px`;
    DOMElements.tooltipElement.style.top = `${y}px`;
  }
}
function hideTooltip() {
  tooltipTimeout = setTimeout(() => {
    DOMElements.tooltipElement.classList.remove("visible");
    document.removeEventListener("mousemove", updatePositionTooltipHandler);
  }, 100);
}
function getCalculatedIncome() {
  let totalIncome = gameState.modifiers.baseIncome;
  let totalUpkeep = 0;
  gameState.units.forEach((unit) => {
    const unitInfo = UNITS[unit.type];
    if (unitInfo) totalUpkeep += unitInfo.upkeep;
  });
  gameState.trainingQueue.forEach((queuedUnit) => {
    const unitInfo = UNITS[queuedUnit.unitType];
    if (unitInfo) totalUpkeep += unitInfo.upkeep * 0.25;
  });
  gameState.worldMap.deployedArmies.forEach((army) => {
    army.units.forEach((u) => {
      const unitInfo = UNITS[u.type];
      if (unitInfo) totalUpkeep += unitInfo.upkeep;
    });
  });
  totalIncome -= totalUpkeep;
  totalIncome *= gameState.modifiers.incomeMultiplier;
  return totalIncome;
}
function getCalculatedTechRate() {
  return (
    gameState.modifiers.baseTechRate * gameState.modifiers.techRateMultiplier
  );
}
function getCalculatedEmpireDefense() {
  return Math.floor(
    gameState.modifiers.baseDefense * gameState.modifiers.defenseMultiplier +
      gameState.modifiers.globalDefenseBoost,
  );
}
function getUnitEffectiveStats(unitType) {
  const unitInfo = UNITS[unitType];
  if (!unitInfo) return { attack: 0, defense: 0, hp: 0, speed: 0 };
  return {
    attack: unitInfo.baseAttack + gameState.modifiers.globalAttackBoost,
    defense: unitInfo.baseDefense + gameState.modifiers.globalDefenseBoost,
    hp: unitInfo.maxHp,
    speed: unitInfo.baseSpeed,
  };
}
function applyEffects(itemData, isRemoval = false) {
  if (!itemData.effects) return;
  itemData.effects.forEach((effect) => {
    let value = effect.value;
    if (isRemoval) {
      if (effect.operation === "add") value = -value;
      else if (effect.operation === "multiply" && value !== 0)
        value = 1 / value;
      else if (effect.operation === "multiply" && value === 0) value = 0;
    }
    switch (effect.operation) {
      case "add":
        if (gameState.resources.hasOwnProperty(effect.target))
          gameState.resources[effect.target] += value;
        else if (gameState.modifiers.hasOwnProperty(effect.target))
          gameState.modifiers[effect.target] += value;
        break;
      case "multiply":
        if (gameState.modifiers.hasOwnProperty(effect.target))
          gameState.modifiers[effect.target] *= value;
        break;
    }
  });
}

function updateResourceDisplays() {
  const calculatedIncome = getCalculatedIncome();
  const incomeClass =
    calculatedIncome >= 0
      ? "resource-value"
      : 'resource-value" style="color: var(--error-color);';
  const resourcesHtml = `<div class="resource-display"><span>💰 Gold:</span><span class="resource-value">${formatNumber(gameState.resources.gold)}</span></div><div class="resource-display"><span>📈 Income:</span><span class="${incomeClass}">${formatNumber(calculatedIncome, 1)}/s</span></div><div class="resource-display"><span>👥 Pop:</span><span class="resource-value">${gameState.resources.population}/${formatNumber(gameState.resources.maxPopulation)}</span></div><div class="resource-display"><span>🧪 Tech Pts:</span><span class="resource-value">${formatNumber(gameState.resources.technologyPoints)}</span></div><div class="resource-display"><span>🔬 Research:</span><span class="resource-value">+${formatNumber(getCalculatedTechRate(), 1)}/s</span></div><div class="resource-display"><span>🛡️ Empire Def:</span><span class="resource-value">${formatNumber(getCalculatedEmpireDefense())}</span></div>`;
  DOMElements.resourceDisplaysContainer.innerHTML = resourcesHtml;
  DOMElements.armyStrengthDisplay.textContent = formatNumber(
    calculateArmyStrength(),
  );
  DOMElements.eraLabelDisplay.textContent = AGES[gameState.age].name;
  updateRaidAlertUI();
}
function updateButtonStates() {
  document
    .querySelectorAll("#buildings-container .item-slot")
    .forEach((slot) => {
      const buildingId = slot.dataset.itemId;
      if (!buildingId) return;
      const buildingInfo = BUILDINGS[buildingId];
      const count =
        gameState.buildings.filter(
          (b) => b.type === buildingId && (b.isConstructed || b.isPlaceholder),
        ).length +
        gameState.constructionQueue.filter((b) => b.type === buildingId).length;
      const cost = calculateBuildingCost(buildingInfo, count);
      slot.classList.toggle(
        "disabled",
        gameState.resources.gold < cost ||
          gameState.constructionQueue.length >= 5,
      );
      const costEl = slot.querySelector(".item-cost");
      if (costEl) costEl.textContent = formatNumber(cost);
      slot.classList.toggle(
        "placing-active",
        gameState.placement.isPlacing &&
          gameState.placement.buildingId === buildingId,
      );
    });
  document
    .querySelectorAll("#units-container .game-button")
    .forEach((button) => {
      const unitId = button.dataset.itemId;
      if (!unitId) return;
      const unitInfo = UNITS[unitId];
      const cost = Math.floor(
        unitInfo.cost * gameState.modifiers.unitCostMultiplier,
      );
      button.disabled = !(
        gameState.resources.gold >= cost &&
        gameState.resources.population + unitInfo.population <=
          gameState.resources.maxPopulation &&
        gameState.trainingQueue.length < 5
      );
    });
  document
    .querySelectorAll("#tech-container .game-button")
    .forEach((button) => {
      const techId = button.dataset.itemId;
      if (!techId) return;
      const techInfo = TECHNOLOGIES[techId];
      button.disabled = !!(
        gameState.currentResearch.id || gameState.resources.gold < techInfo.cost
      );
    });
  if (gameState.age < AGES.length - 1) {
    const nextAgeCost = AGES[gameState.age + 1].techCost;
    const canAdvance = gameState.resources.technologyPoints >= nextAgeCost;
    DOMElements.advanceAgeButton.disabled = !canAdvance;
    DOMElements.advanceAgeButton.classList.toggle("pulse", canAdvance);
  } else {
    DOMElements.advanceAgeButton.disabled = true;
    DOMElements.advanceAgeButton.classList.remove("pulse");
  }
  DOMElements.battleButton.disabled =
    gameState.battle.isActive || countTotalPlayerUnits() === 0;
  updateExpandLandButtonCosts();
  DOMElements.cancelPlacementButton.style.display = gameState.placement
    .isPlacing
    ? "flex"
    : "none";
  DOMElements.backToBaseButton.style.display =
    Math.abs(camera.x) > BACK_TO_BASE_THRESHOLD ||
    Math.abs(camera.y - -(DOMElements.gameCanvas.height / 3)) >
      BACK_TO_BASE_THRESHOLD
      ? "block"
      : "none";
  updateDeployedArmiesUI();
}
function updateAllUIDisplays() {
  updateResourceDisplays();
  updateResearchUI();
  updateAgeUI();
  updateTrainingQueueUI();
  updateConstructionQueueUI();
  updateDeployedArmiesUI();
  loadAvailableUnits();
  updateButtonStates();
}
function updateResearchUI() {
  if (gameState.currentResearch.id) {
    const tech = TECHNOLOGIES[gameState.currentResearch.id];
    DOMElements.currentResearchDisplay.textContent = `${tech.icon} ${tech.name}`;
    const progress =
      (gameState.currentResearch.progress /
        gameState.currentResearch.timeToComplete) *
      100;
    DOMElements.researchProgressBar.style.width = `${Math.min(progress, 100)}%`;
  } else {
    DOMElements.currentResearchDisplay.textContent = "None";
    DOMElements.researchProgressBar.style.width = "0%";
  }
  DOMElements.researchedTechsList.innerHTML = gameState.technologies
    .map((techId) => {
      const tech = TECHNOLOGIES[techId];
      return `<div>${tech.icon} ${tech.name}</div>`;
    })
    .join("");
}
function updateAgeUI() {
  if (gameState.age < AGES.length - 1) {
    const nextAgeCost = AGES[gameState.age + 1].techCost;
    DOMElements.advanceAgeCostDisplay.textContent = formatNumber(nextAgeCost);
    const progress = (gameState.resources.technologyPoints / nextAgeCost) * 100;
    DOMElements.ageProgressBar.style.width = `${Math.min(progress, 100)}%`;
    DOMElements.advanceAgeButton.querySelector("span:first-child").textContent =
      `Advance to ${AGES[gameState.age + 1].name}`;
  } else {
    DOMElements.advanceAgeCostDisplay.textContent = "MAX";
    DOMElements.ageProgressBar.style.width = "100%";
    DOMElements.advanceAgeButton.querySelector("span:first-child").textContent =
      "Maximum Age Reached";
    DOMElements.advanceAgeButton.disabled = true;
  }
}

function loadAvailableBuildings() {
  DOMElements.buildingsContainer.innerHTML = "";
  const available = Object.values(BUILDINGS).filter(
    (b) => b.minAge <= gameState.age && b.maxAge >= gameState.age,
  );
  available.forEach((building) => {
    const count =
      gameState.buildings.filter(
        (b) => b.type === building.id && (b.isConstructed || b.isPlaceholder),
      ).length +
      gameState.constructionQueue.filter((b) => b.type === building.id).length;
    const cost = calculateBuildingCost(building, count);
    const effectsDesc = building.effects
      .map(
        (e) =>
          `${e.value > 0 ? "+" : ""}${e.value} ${e.target.replace(/([A-Z])/g, " $1").toLowerCase()}`,
      )
      .join(", ");
    const el = document.createElement("div");
    el.className = "item-slot";
    el.dataset.itemId = building.id;
    el.dataset.tooltip = `<strong>${building.name}</strong><br>${building.description}<br><em>Effect: ${effectsDesc}</em><br>Size: ${building.sizeX}x${building.sizeY}, Time: ${building.buildTime}s<br>Cost Multiplier: x${building.costMultiplier.toFixed(2)}`;
    el.innerHTML = `<div class="item-icon">${building.icon}</div><div class="item-details"><div class="item-name">${building.name}</div><div class="item-description">${building.description.substring(0, 30)}...</div></div><div class="item-cost">${formatNumber(cost)}</div>`;
    el.addEventListener("click", () => togglePlacementMode(building.id));
    DOMElements.buildingsContainer.appendChild(el);
  });
  updateButtonStates();
}
function calculateBuildingCost(buildingInfo, count) {
  return Math.floor(
    buildingInfo.baseCost * Math.pow(buildingInfo.costMultiplier, count),
  );
}

function togglePlacementMode(buildingId) {
  const buildingInfo = BUILDINGS[buildingId];
  const count =
    gameState.buildings.filter(
      (b) => b.type === buildingId && (b.isConstructed || b.isPlaceholder),
    ).length +
    gameState.constructionQueue.filter((b) => b.type === buildingId).length;
  const cost = calculateBuildingCost(buildingInfo, count);

  if (
    gameState.placement.isPlacing &&
    gameState.placement.buildingId === buildingId
  ) {
    cancelPlacementMode();
  } else {
    if (gameState.resources.gold < cost) {
      showNotification("Not enough gold!", "error");
      return;
    }
    if (gameState.constructionQueue.length >= 5) {
      showNotification("Construction queue full (max 5)!", "error");
      return;
    }
    gameState.placement.isPlacing = true;
    gameState.placement.buildingId = buildingId;
    DOMElements.gameCanvasContainer.style.cursor = "copy";
    showNotification(
      `Placing ${buildingInfo.name}. Click on map.`,
      "info",
      5000,
    );
    updateButtonStates();
  }
}

function cancelPlacementMode() {
  if (gameState.editMode.isMovingBuilding && gameState.editMode.originalMovingBuildingData) {
    const originalData = gameState.editMode.originalMovingBuildingData;
    // No actual building data change as it wasn't committed. Just reset state.
    showNotification("Building move cancelled.", "info");
    
    gameState.editMode.isMovingBuilding = false;
    gameState.editMode.originalMovingBuildingData = null;
    // Re-select the building that was being moved to show its options again
    gameState.editMode.selectedBuildingInstance = gameState.buildings.find(b => b.id === originalData.id) || null;

    if (gameState.editMode.selectedBuildingInstance && gameState.editMode.isActive) {
        const screenPos = gridToScreen(gameState.editMode.selectedBuildingInstance.gridX, gameState.editMode.selectedBuildingInstance.gridY);
        showEditModeActionsPopup(gameState.editMode.selectedBuildingInstance, screenPos);
        DOMElements.gameCanvasContainer.style.cursor = "cell"; // Back to edit mode select cursor
    } else if(gameState.editMode.isActive) { // If building somehow got deleted during cancel (unlikely)
        DOMElements.gameCanvasContainer.style.cursor = "cell";
        hideEditModeActionsPopup();
    } else {
        DOMElements.gameCanvasContainer.style.cursor = "grab"; // Default cursor if not in edit mode
    }
  } else {
    DOMElements.gameCanvasContainer.style.cursor = gameState.editMode.isActive ? "cell" : "grab";
  }

  gameState.placement.isPlacing = false;
  gameState.placement.buildingId = null;
  DOMElements.cancelPlacementButton.textContent = "Cancel Placement Mode";
  DOMElements.cancelPlacementButton.style.display = "none";
  
  updateAllUIDisplays(); // Includes updateButtonStates which will fix item-slot active class
  renderGameView();
}

function attemptPlaceBuilding(gridX, gridY, isShiftHeld = false) {
  if (!gameState.placement.isPlacing || !gameState.placement.buildingId) return;

  const buildingId = gameState.placement.buildingId;
  const buildingDef = BUILDINGS[buildingId];

  if (gameState.editMode.isMovingBuilding && gameState.editMode.originalMovingBuildingData) {
    const originalData = gameState.editMode.originalMovingBuildingData;
    const buildingToMove = gameState.buildings.find(b => b.id === originalData.id);
    if (!buildingToMove) {
        console.error("Error: Building to move not found!");
        cancelPlacementMode(); // Full cancel
        return;
    }

    const placementCheckResult = canPlaceBuilding(buildingDef, gridX, gridY, true, originalData.id);
    if (placementCheckResult.valid) {
        applyEffects(BUILDINGS[buildingToMove.type], true); // Remove effects from old position implicitly by removing then re-adding for new position
        buildingToMove.gridX = gridX;
        buildingToMove.gridY = gridY;
        applyEffects(buildingDef, false); // Add effects for new position

        addMessage(`${buildingDef.name} moved to [${gridX},${gridY}].`);
        showNotification(`${buildingDef.name} moved!`, "success");
        
        gameState.editMode.isMovingBuilding = false;
        gameState.editMode.originalMovingBuildingData = null;
        gameState.editMode.selectedBuildingInstance = null;
        
        DOMElements.gameCanvasContainer.style.cursor = "cell"; // Back to edit mode select cursor
        DOMElements.cancelPlacementButton.textContent = "Cancel Placement Mode";
        
        cancelPlacementMode(); // Exits general placement mode
        // If you want to stay in edit mode after move:
        // gameState.placement.isPlacing = false; 
        // gameState.placement.buildingId = null;
        // DOMElements.cancelPlacementButton.style.display = 'none';
        // if (!gameState.editMode.isActive) toggleBuildingEditMode(); // Ensure edit mode button is correct
        
        updateAllUIDisplays();
        renderGameView();

    } else {
        if (placementCheckResult.reason === "outpost_proximity") {
            showNotification(`Too close to ${placementCheckResult.outpostName}! Cannot move here.`, "error");
        } else {
            showNotification("Cannot move building here (obstructed or outside owned area).", "error");
        }
        // Do not exit move mode, allow user to try another spot or cancel.
    }
    return; 
  }

  // Standard new building placement
  const buildingCount =
    gameState.buildings.filter(
      (b) => b.type === buildingId && (b.isConstructed || b.isPlaceholder),
    ).length +
    gameState.constructionQueue.filter((b) => b.type === buildingId).length;
  const cost = calculateBuildingCost(buildingDef, buildingCount);

  if (gameState.resources.gold < cost) {
    showNotification("Not enough gold!", "error");
    if (!isShiftHeld) cancelPlacementMode(); // Cancel if not shift-placing and can't afford
    else { // If shift-placing and can't afford, exit continuous placement
        showNotification("Continuous placement stopped: Not enough gold.", "info");
        cancelPlacementMode();
    }
    return;
  }
  if (gameState.constructionQueue.length >= 5) {
    showNotification("Construction queue full!", "error");
    if (!isShiftHeld) cancelPlacementMode();
    else {
        showNotification("Continuous placement stopped: Construction queue full.", "info");
        cancelPlacementMode();
    }
    return;
  }

  const placementCheckResult = canPlaceBuilding(buildingDef, gridX, gridY, true);
  if (placementCheckResult.valid) {
    gameState.resources.gold -= cost;
    const newConstruction = {
      id: uniqueId("cons_"), type: buildingId, gridX: gridX, gridY: gridY,
      sizeX: buildingDef.sizeX, sizeY: buildingDef.sizeY,
      progress: 0, totalTime: buildingDef.buildTime, cost: cost,
    };
    gameState.constructionQueue.push(newConstruction);
    gameState.buildings.push({ ...newConstruction, isPlaceholder: true, isConstructed: false });

    showNotification(`${buildingDef.name} construction started!`, "success");
    addMessage(`Started construction: ${buildingDef.name} at [${gridX},${gridY}].`);

    if (!isShiftHeld) {
      cancelPlacementMode();
    } else {
      // For shift-click, re-check if affordable for next one
      const nextBuildingCount = buildingCount + 1;
      const nextCost = calculateBuildingCost(buildingDef, nextBuildingCount);
      loadAvailableBuildings(); // Update costs in UI for all buildings
      updateButtonStates(); // Update button states, including the one being placed
      if (gameState.resources.gold < nextCost) {
        showNotification("Continuous placement stopped: Not enough gold for the next one.", "info");
        cancelPlacementMode();
      } else if (gameState.constructionQueue.length >=5) {
        showNotification("Continuous placement stopped: Construction queue full.", "info");
        cancelPlacementMode();
      }
      // Otherwise, stay in placement mode for the same building
    }
    updateAllUIDisplays(); // Update after successful placement
    renderGameView();
  } else {
    if (placementCheckResult.reason === "outpost_proximity") {
        showNotification(`Too close to ${placementCheckResult.outpostName}! Cannot build here.`, "error");
    } else if (placementCheckResult.reason === "not_owned") {
        showNotification("Cannot place building outside owned territory.", "error");
    } else if (placementCheckResult.reason === "obstructed") {
        showNotification("Cannot place building here, tile is obstructed.", "error");
    } else {
        showNotification("Cannot place building here.", "error"); 
    }
    // If shift-placing and invalid, might want to cancel continuous placement or let user try again.
    // For now, it just shows error and user has to click again.
  }
}

function processConstructionQueue(deltaTime) {
  if (gameState.constructionQueue.length === 0) return;

  const constructingItem = gameState.constructionQueue[0];
  constructingItem.progress += deltaTime;

  const placeholderBuilding = gameState.buildings.find(
    (b) => b.id === constructingItem.id && b.isPlaceholder,
  );
  if (placeholderBuilding)
    placeholderBuilding.progress = constructingItem.progress;

  if (constructingItem.progress >= constructingItem.totalTime) {
    const buildingInfo = BUILDINGS[constructingItem.type];

    const finalBuildingIndex = gameState.buildings.findIndex(
      (b) => b.id === constructingItem.id,
    );
    if (finalBuildingIndex !== -1) {
      gameState.buildings[finalBuildingIndex] = {
        id: constructingItem.id,
        type: constructingItem.type,
        level: 1,
        constructedAt: gameState.stats.timePlayed,
        gridX: constructingItem.gridX,
        gridY: constructingItem.gridY,
        sizeX: buildingInfo.sizeX,
        sizeY: buildingInfo.sizeY,
        isConstructed: true,
        isPlaceholder: false,
        progress: constructingItem.totalTime,
        totalTime: constructingItem.totalTime,
      };
    }

    applyEffects(buildingInfo, false);
    gameState.stats.buildingsConstructed++;
    showNotification(`${buildingInfo.name} constructed!`, "success");
    addMessage(`Finished construction: ${buildingInfo.name}.`);
    gameState.constructionQueue.shift();

    loadAvailableBuildings();
    updateAllUIDisplays();
    renderGameView();
  }
  updateConstructionQueueUI();
}

function updateConstructionQueueUI() {
  DOMElements.constructionQueueCount.textContent =
    gameState.constructionQueue.length;
  if (gameState.constructionQueue.length > 0) {
    DOMElements.constructionQueueDisplay.style.display = "block";
    DOMElements.constructionQueueList.innerHTML = gameState.constructionQueue
      .map((item, index) => {
        const buildingInfo = BUILDINGS[item.type];
        const progressPercent = Math.min(
          100,
          (item.progress / item.totalTime) * 100,
        );
        return `<div class="construction-queue-item-info">
                            <span>${index + 1}. ${buildingInfo.icon} ${buildingInfo.name}</span>
                            <span>${formatNumber(item.progress, 0)}s / ${item.totalTime}s</span>
                        </div>
                        <div class="progress-container" style="height:5px; margin-bottom:5px;">
                            <div class="progress-bar-small" style="width:${progressPercent}%"></div>
                        </div>`;
      })
      .join("");
  } else {
    DOMElements.constructionQueueDisplay.style.display = "none";
    DOMElements.constructionQueueList.innerHTML = "";
  }
}

function loadAvailableUnits() {
  DOMElements.unitsContainer.innerHTML = "";
  const availableUnitTypes = Object.values(UNITS).filter(
    (u) => u.minAge <= gameState.age && u.maxAge >= gameState.age,
  );
  availableUnitTypes.forEach((unit) => {
    const cost = Math.floor(unit.cost * gameState.modifiers.unitCostMultiplier);
    const trainTime = Math.floor(
      unit.trainTime * gameState.modifiers.unitTrainTimeMultiplier,
    );
    const el = document.createElement("button");
    el.className = "game-button";
    el.dataset.itemId = unit.id;
    const effectiveStats = getUnitEffectiveStats(unit.id);
    el.dataset.tooltip = `<strong>${unit.name} (${unit.icon})</strong><br>${unit.description}<br>HP: ${effectiveStats.hp}, Atk: ${effectiveStats.attack}, Def: ${effectiveStats.defense}, Spd: ${effectiveStats.speed}<br>Pop: ${unit.population}, Upkeep: ${unit.upkeep.toFixed(1)}/s<br>Train Time: ${trainTime}s`;
    el.innerHTML = `<span>${unit.icon} ${unit.name} (Time: ${trainTime}s)</span><span>${formatNumber(cost)}</span>`;
    el.addEventListener("click", () => addUnitToTrainingQueue(unit.id));
    DOMElements.unitsContainer.appendChild(el);
  });
  const unitStacks = {};
  gameState.units.forEach((unit) => {
    if (!unitStacks[unit.type]) {
      unitStacks[unit.type] = { count: 0, unitDef: UNITS[unit.type] };
    }
    unitStacks[unit.type].count++;
  });
  DOMElements.currentUnitsList.innerHTML =
    Object.values(unitStacks)
      .map((stack) => {
        return `<div class="unit-info"><span>${stack.unitDef.icon} ${stack.unitDef.name}</span><span>x${stack.count}</span></div>`;
      })
      .join("") || "No units in army.";
  DOMElements.currentUnitsDisplay.style.display = "block";
  updateButtonStates();
}
function addUnitToTrainingQueue(unitId) {
  const unitInfo = UNITS[unitId];
  const cost = Math.floor(
    unitInfo.cost * gameState.modifiers.unitCostMultiplier,
  );
  const trainTime = Math.floor(
    unitInfo.trainTime * gameState.modifiers.unitTrainTimeMultiplier,
  );
  if (gameState.resources.gold < cost) {
    showNotification("Not enough gold!", "error");
    return;
  }
  if (
    gameState.resources.population + unitInfo.population >
    gameState.resources.maxPopulation
  ) {
    showNotification("Not enough pop!", "error");
    return;
  }
  if (gameState.trainingQueue.length >= 5) {
    showNotification("Queue full (max 5)!", "error");
    return;
  }
  gameState.resources.gold -= cost;
  gameState.trainingQueue.push({
    id: uniqueId("trn_"),
    unitType: unitId,
    progress: 0,
    totalTime: trainTime,
    cost: cost,
    population: unitInfo.population,
  });
  showNotification(`${unitInfo.name} added to queue!`, "success");
  addMessage(`Training ${unitInfo.name}.`);
  updateTrainingQueueUI();
  updateAllUIDisplays();
}
function processTrainingQueue(deltaTime) {
  if (gameState.trainingQueue.length > 0) {
    const trainingUnit = gameState.trainingQueue[0];
    trainingUnit.progress += deltaTime;
    if (trainingUnit.progress >= trainingUnit.totalTime) {
      if (
        gameState.resources.population + trainingUnit.population <=
        gameState.resources.maxPopulation
      ) {
        gameState.resources.population += trainingUnit.population;
        const unitInfo = UNITS[trainingUnit.unitType];
        gameState.units.push({
          id: uniqueId("unt_"),
          type: trainingUnit.unitType,
          originalCost: trainingUnit.cost,
          recruitedAt: gameState.stats.timePlayed,
        });
        showNotification(`${unitInfo.name} trained!`, "success");
        addMessage(`${unitInfo.name} joined army.`);
        gameState.stats.unitsTrained = (gameState.stats.unitsTrained || 0) + 1;
      } else {
        showNotification(
          `${UNITS[trainingUnit.unitType].name} trained, but no pop! Unit lost. Gold refunded.`,
          "error",
        );
        addMessage(
          `Could not field ${UNITS[trainingUnit.unitType].name}. Gold refunded.`,
        );
        gameState.resources.gold += trainingUnit.cost;
      }
      gameState.trainingQueue.shift();
      loadAvailableUnits();
      updateAllUIDisplays();
    }
    updateTrainingQueueUI();
  }
}
function updateTrainingQueueUI() {
  DOMElements.trainingQueueCount.textContent = gameState.trainingQueue.length;
  if (gameState.trainingQueue.length > 0) {
    DOMElements.trainingQueueDisplay.style.display = "block";
    DOMElements.trainingQueueList.innerHTML = gameState.trainingQueue
      .map((item, index) => {
        const unitInfo = UNITS[item.unitType];
        const progressPercent = Math.min(
          100,
          (item.progress / item.totalTime) * 100,
        );
        return `<div class="training-queue-item-info"><span>${index + 1}. ${unitInfo.icon} ${unitInfo.name}</span><span>${formatNumber(item.progress, 0)}s / ${item.totalTime}s</span></div><div class="progress-container" style="height:5px; margin-bottom:5px;"><div class="progress-bar-small" style="width:${progressPercent}%"></div></div>`;
      })
      .join("");
  } else {
    DOMElements.trainingQueueDisplay.style.display = "none";
    DOMElements.trainingQueueList.innerHTML = "";
  }
}
function countTotalPlayerUnits() {
  return gameState.units.length;
}
function calculateArmyStrength() {
  let strength = 0;
  gameState.units.forEach((unitInstance) => {
    const unitStats = getUnitEffectiveStats(unitInstance.type);
    strength += unitStats.attack * 1.5 + unitStats.defense + unitStats.hp / 4;
  });
  gameState.worldMap.deployedArmies.forEach((army) =>
    army.units.forEach((u) => {
      const unitStats = getUnitEffectiveStats(u.type);
      strength +=
        u.count *
        (unitStats.attack * 1.5 + unitStats.defense + unitStats.hp / 4);
    }),
  );
  return Math.floor(strength);
}

const ENEMY_OUTPOSTS = [
  {
    name: "Rival Tribe Camp",
    description: "Scout their camp.",
    icon: "🏕️",
    rewardBase: 200,
    minAge: 0,
    maxAge: 1,
    composition: [
      { type: "clubber", countMin: 3, countMax: 5, unitDef: UNITS.clubber },
    ],
  },
  {
    name: "Boar Den",
    description: "Dangerous wild boars.",
    icon: "🐗",
    rewardBase: 250,
    minAge: 0,
    maxAge: 2,
    composition: [
      {
        type: "wildBoar",
        countMin: 2,
        countMax: 4,
        unitDef: {
          name: "Wild Boar",
          icon: "🐗",
          maxHp: 50,
          baseAttack: 8,
          baseDefense: 3,
          baseSpeed: 4,
          isRanged: false,
        },
      },
    ],
  },
  {
    name: "Bandit Hideout",
    description: "Root out the bandits.",
    icon: "🏴‍☠️",
    rewardBase: 500,
    minAge: 1,
    maxAge: 3,
    composition: [
      { type: "spearman", countMin: 4, countMax: 6, unitDef: UNITS.spearman },
      { type: "archer", countMin: 2, countMax: 3, unitDef: UNITS.archer },
    ],
  },
  {
    name: "Fortified Outpost",
    description: "A well-defended enemy position.",
    icon: "🏰",
    rewardBase: 1000,
    minAge: 2,
    maxAge: 4,
    composition: [
      { type: "knight", countMin: 3, countMax: 5, unitDef: UNITS.knight },
      { type: "archer", countMin: 3, countMax: 5, unitDef: UNITS.archer },
    ],
  },
  {
    name: "Industrial Complex",
    description: "Heavily guarded factory.",
    icon: "🏭",
    rewardBase: 5000,
    minAge: 4,
    maxAge: 5,
    composition: [
      { type: "rifleman", countMin: 6, countMax: 10, unitDef: UNITS.rifleman },
      { type: "cannon", countMin: 1, countMax: 2, unitDef: UNITS.cannon },
    ],
  },
  {
    name: "Alien Wreckage",
    description: "Investigate the crash site.",
    icon: "👽",
    rewardBase: 10000,
    minAge: 6,
    maxAge: 7,
    composition: [
      { type: "drone", countMin: 5, countMax: 8, unitDef: UNITS.drone },
      { type: "mech", countMin: 1, countMax: 2, unitDef: UNITS.mech },
    ],
  },
];

function findEnemies() {
  if (gameState.battle.isActive) {
    showNotification("Battle active!", "error");
    return;
  }
  if (countTotalPlayerUnits() === 0) {
    showNotification("Need units!", "error");
    return;
  }
  const ageStrengthMod = AGES[gameState.age].enemyStrengthModifier || 1;
  const outposts = ENEMY_OUTPOSTS.filter(
    (e) => e.minAge <= gameState.age && e.maxAge >= gameState.age,
  ).map((e) => {
    let estimatedStrength = 0;
    e.composition.forEach((comp) => {
      const unitDef = comp.unitDefOverride ||
        comp.unitDef ||
        UNITS[comp.type] || {
          maxHp: 10,
          baseAttack: 1,
          baseDefense: 1,
          baseSpeed: 1,
        };
      const count = Math.floor((comp.countMin + comp.countMax) / 2);
      estimatedStrength +=
        count *
        (unitDef.baseAttack + unitDef.baseDefense + unitDef.maxHp / 5) *
        ageStrengthMod;
    });
    return {
      ...e,
      calculatedStrength: Math.floor(estimatedStrength),
      reward: Math.floor(e.rewardBase * ageStrengthMod),
    };
  });
  DOMElements.enemySelectionList.innerHTML = "";
  outposts.forEach((outpost) => {
    const el = document.createElement("div");
    el.className = "item-slot enemy-preview";
    el.dataset.tooltip = `<strong>${outpost.name}</strong><br>${outpost.description}<br>Est. Strength: ${formatNumber(outpost.calculatedStrength)}<br>Reward: ~${formatNumber(outpost.reward)} Gold`;
    el.innerHTML = `<div class="item-icon enemy-icon">${outpost.icon}</div><div class="item-details"><div class="item-name">${outpost.name}</div><div class="item-description">Strength: ${formatNumber(outpost.calculatedStrength)}</div></div>`;
    el.addEventListener("click", () => initiateBattle(outpost, "outpost"));
    DOMElements.enemySelectionList.appendChild(el);
  });
  DOMElements.enemySelectionContainer.style.display = "block";
}

function initiateBattle(
  encounterData,
  battleType = "outpost",
  deployedArmyId = null,
) {
  gameState.battle.isActive = true;
  gameState.battle.log = [];
  gameState.battle.battleType = battleType;
  gameState.battle.currentTurn = "player";
  gameState.battle.actedStackIdsThisTurn = [];
  gameState.battle.selectedPlayerStackId = null;
  gameState.battle.selectedAction = null;
  gameState.battle.selectedTargetStackBattleId = null;
  gameState.battle.isAwaitingTargetSelection = false;
  gameState.battle.targetingSource = null;
  gameState.battle.agePowerCooldowns = {};
  gameState.battle.currentDeployedArmyId = null; 

  addBattleLogEntry(`Battle against ${encounterData.name} begins!`);
  DOMElements.battleTitleText.textContent = `Battle: ${encounterData.name}`;

  let sourceUnits = [];

  if (deployedArmyId) {
    const deployedArmy = gameState.worldMap.deployedArmies.find(
      (da) => da.id === deployedArmyId,
    );
    if (!deployedArmy) {
      console.error("CRITICAL: Deployed army not found for battle:", deployedArmyId);
      addBattleLogEntry(`Error: Deployed army ${deployedArmyId} not found. Battle cannot start.`);
      showNotification(`Error starting battle: Deployed army ${deployedArmyId} missing.`, "error", 5000);
      gameState.battle.isActive = false;
      updateAllUIDisplays(); 
      return;
    }
    if (!deployedArmy.units || deployedArmy.units.length === 0) {
        console.warn("Deployed army for battle was empty:", deployedArmyId);
        addBattleLogEntry(`Warning: Deployed army ${deployedArmyId} has no units. Battle cannot start with this army.`);
    } else {
        sourceUnits = deployedArmy.units.flatMap((stack) => {
            if (!UNITS[stack.type] || typeof stack.count !== 'number' || stack.count <= 0) {
                console.warn(`Invalid stack in deployed army ${deployedArmyId}: type ${stack.type}, count ${stack.count}. Skipping.`);
                return []; 
            }
            return Array(stack.count)
                .fill(null)
                .map(() => ({ type: stack.type, id: uniqueId("deployed_unit_") }));
        });
    }
    gameState.battle.currentDeployedArmyId = deployedArmyId;
  } else {
    if (!gameState.units || gameState.units.length === 0) {
        console.warn("Attempting battle with home guard, but no units at base.");
    } else {
        sourceUnits = gameState.units.map(u => ({ ...u })); 
    }
  }

  if (sourceUnits.length === 0) {
    let message = "Player has no units to field from the selected source. Battle cannot commence.";
    if (gameState.battle.currentDeployedArmyId) { // Check if a deployed army ID was set, meaning it was the source
        message = `Deployed army ${gameState.battle.currentDeployedArmyId} resulted in no valid units for battle. Battle cancelled.`;
        const armyIdx = gameState.worldMap.deployedArmies.findIndex(da => da.id === gameState.battle.currentDeployedArmyId);
        if (armyIdx !== -1) {
            addBattleLogEntry(`Removing empty or invalid deployed army ${gameState.battle.currentDeployedArmyId}.`);
            gameState.worldMap.deployedArmies.splice(armyIdx, 1);
        }
    } else {
        message = "No units available at base. Battle cannot commence.";
    }
    addBattleLogEntry(message);
    showNotification(message, "error");
    gameState.battle.isActive = false;
    gameState.battle.currentDeployedArmyId = null; 
    updateAllUIDisplays();
    return;
  }

  const playerUnitGroups = {};
  sourceUnits.forEach((unit) => {
    if (!UNITS[unit.type]) {
        console.warn(`Encountered unknown unit type '${unit.type}' in sourceUnits. Skipping.`);
        return;
    }
    if (!playerUnitGroups[unit.type]) {
      playerUnitGroups[unit.type] = { unitDef: UNITS[unit.type], ids: [] };
    }
    playerUnitGroups[unit.type].ids.push(unit.id);
  });

  if (Object.keys(playerUnitGroups).length === 0) {
    let message = "Could not form any valid player unit stacks for battle. Battle cancelled.";
    if (gameState.battle.currentDeployedArmyId) { 
        message = `Units from deployed army ${gameState.battle.currentDeployedArmyId} could not form valid stacks. Battle cancelled.`;
        const armyIdx = gameState.worldMap.deployedArmies.findIndex(da => da.id === gameState.battle.currentDeployedArmyId);
        if (armyIdx !== -1) {
            addBattleLogEntry(`Removing deployed army ${gameState.battle.currentDeployedArmyId} due to invalid unit composition for battle.`);
            gameState.worldMap.deployedArmies.splice(armyIdx, 1);
        }
    }
    addBattleLogEntry(message);
    showNotification(message, "error");
    gameState.battle.isActive = false;
    gameState.battle.currentDeployedArmyId = null;
    updateAllUIDisplays();
    return;
  }

  gameState.battle.playerParty = Object.entries(playerUnitGroups).map(
    ([type, group]) => {
      const unitDef = group.unitDef;
      const effectiveStats = getUnitEffectiveStats(type);
      const count = group.ids.length;
      return {
        type: type,
        name: unitDef.name,
        count: count,
        currentTotalHp: count * effectiveStats.hp,
        maxHpPerUnit: effectiveStats.hp,
        attackPerUnit: effectiveStats.attack,
        defensePerUnit: effectiveStats.defense,
        speed: effectiveStats.speed,
        icon: unitDef.icon,
        battleId: uniqueId("playerstack_"),
        isPlayerStack: true,
        isDefending: false,
        hasActedThisTurn: false,
        originalUnitIds: group.ids,
        unitDef: unitDef,
      };
    },
  );

  const ageStrengthMod =
    encounterData.ageLevel !== undefined && AGES[encounterData.ageLevel]
      ? AGES[encounterData.ageLevel].enemyStrengthModifier
      : AGES[gameState.age].enemyStrengthModifier;
      
  gameState.battle.enemyParty = encounterData.composition.map((comp) => {
    const baseDef = comp.unitDefOverride ||
      comp.unitDef ||
      UNITS[comp.type] || {
        name: comp.type || "Unknown Foe Unit",
        icon: "❓",
        maxHp: 20,
        baseAttack: 5,
        baseDefense: 2,
        baseSpeed: 3,
        isRanged: false,
      };
    const count =
      comp.countMin && comp.countMax && typeof comp.countMin === 'number' && typeof comp.countMax === 'number'
        ? Math.floor(Math.random() * (comp.countMax - comp.countMin + 1)) + comp.countMin
        : (typeof comp.count === 'number' ? comp.count : 1);

    const enemyMaxHp = Math.floor(baseDef.maxHp * (ageStrengthMod * 0.8 + 0.2));
    const enemyAttack = Math.floor(baseDef.baseAttack * ageStrengthMod);
    const enemyDefense = Math.floor(baseDef.baseDefense * ageStrengthMod);
    const enemySpeed = baseDef.baseSpeed;
    return {
      type: comp.type,
      name: baseDef.name,
      count: count,
      currentTotalHp: count * enemyMaxHp,
      maxHpPerUnit: enemyMaxHp,
      attackPerUnit: enemyAttack,
      defensePerUnit: enemyDefense,
      speed: enemySpeed,
      icon: baseDef.icon,
      battleId: uniqueId("enemystack_"),
      isPlayerStack: false,
      isDefending: false,
      originalEncounterData: encounterData,
      unitDef: baseDef,
    };
  });

  gameState.battle.rewards = {
    gold: Math.floor(encounterData.reward || encounterData.rewardBase * ageStrengthMod || 50),
  };
  
  DOMElements.enemySelectionContainer.style.display = "none";
  DOMElements.battleButton.disabled = true;
  DOMElements.battleButton.textContent = "Battle in Progress...";
  
  showModal(DOMElements.battleModalOverlay);
  const battleBackgroundAge = encounterData.ageLevel !== undefined ? encounterData.ageLevel : gameState.age;
  DOMElements.battleArea.style.backgroundImage = AGES[battleBackgroundAge] && AGES[battleBackgroundAge].battleBg ? AGES[battleBackgroundAge].battleBg : "var(--secondary-color)";
  
  startPlayerTurn();
  renderBattleUI();
}

function renderBattleUI() {
  const createStackHTML = (stack, isPlayer) => {
    const hpPercent =
      Math.max(0, stack.currentTotalHp / (stack.count * stack.maxHpPerUnit)) *
        100 || 0;
    let classes =
      "battle-unit-stack" + (isPlayer ? " player-stack" : " enemy-stack");
    if (stack.currentTotalHp <= 0) classes += " defeated-stack";
    if (isPlayer && stack.battleId === gameState.battle.selectedPlayerStackId)
      classes += " selected-actor";
    if (isPlayer && stack.hasActedThisTurn && stack.currentTotalHp > 0)
      classes += " has-acted";
    if (
      isPlayer &&
      !stack.hasActedThisTurn &&
      stack.currentTotalHp > 0 &&
      gameState.battle.currentTurn === "player"
    )
      classes += " selectable";
    if (
      !isPlayer &&
      stack.currentTotalHp > 0 &&
      (gameState.battle.selectedPlayerStackId ||
        gameState.battle.isAwaitingTargetSelection)
    )
      classes += " targetable";
    if (
      !isPlayer &&
      stack.battleId === gameState.battle.selectedTargetStackBattleId
    )
      classes += " selected-target";

    const tooltip = `HP/Unit: ${stack.maxHpPerUnit}\nAtk/Unit: ${stack.attackPerUnit}\nDef/Unit: ${stack.defensePerUnit}\nSpeed: ${stack.speed}${stack.unitDef.aoeType ? `\nAoE: ${stack.unitDef.aoeType.replace("_all_others", "")} (${(stack.unitDef.aoeDamagePercent || 0) * 100}%)` : ""}`;
    return `<div class="${classes}" data-battle-id="${stack.battleId}" data-tooltip="${tooltip.replace(/\n/g, "<br>")}" style="order:${100 - stack.speed};"> <div class="battle-unit-icon">${stack.icon}</div> <div class="battle-unit-name">${stack.name}</div> <div class="battle-unit-count">x ${stack.count} (HP: ${formatNumber(stack.currentTotalHp)})</div> <div class="battle-unit-hp-bar"><div class="battle-unit-hp" style="width: ${hpPercent}%;"></div></div> <div class="battle-unit-stats-line">Atk: ${stack.attackPerUnit} | Def: ${stack.defensePerUnit} | Spd: ${stack.speed}</div> ${stack.isDefending ? "🛡️ Defending" : ""} </div>`;
  };
  DOMElements.playerBattlePartyContainer.innerHTML =
    gameState.battle.playerParty
      .map((stack) => createStackHTML(stack, true))
      .join("");
  DOMElements.enemyBattlePartyContainer.innerHTML = gameState.battle.enemyParty
    .map((stack) => createStackHTML(stack, false))
    .join("");
  document
    .querySelectorAll(".battle-unit-stack.player-stack.selectable")
    .forEach(
      (el) =>
        (el.onclick = () =>
          handlePlayerStackSelectionInBattle(el.dataset.battleId)),
    );
  document
    .querySelectorAll(".battle-unit-stack.enemy-stack.targetable")
    .forEach(
      (el) =>
        (el.onclick = () =>
          handleEnemyStackTargetSelectionInBattle(el.dataset.battleId)),
    );
  DOMElements.battleLogContainerModal.innerHTML = gameState.battle.log
    .map((entry) => `<div class="battle-log-entry">${entry}</div>`)
    .join("");
  DOMElements.battleLogContainerModal.scrollTop =
    DOMElements.battleLogContainerModal.scrollHeight;

  const isPlayerTurn = gameState.battle.currentTurn === "player";
  const canAct = !!gameState.battle.selectedPlayerStackId;
  DOMElements.battleActionAttack.disabled =
    !isPlayerTurn || !canAct || gameState.battle.isAwaitingTargetSelection;
  DOMElements.battleActionDefend.disabled =
    !isPlayerTurn || !canAct || gameState.battle.isAwaitingTargetSelection;
  DOMElements.battleEndTurnButton.disabled =
    !isPlayerTurn || gameState.battle.isAwaitingTargetSelection;

  DOMElements.battleLeaveButton.style.display = gameState.battle.isActive
    ? "flex"
    : "none";
  renderAgePowers();
}
function handlePlayerStackSelectionInBattle(stackId) {
  if (!gameState.battle.isActive || gameState.battle.currentTurn !== "player")
    return;
  const stack = findCombatantStackByBattleId(stackId);
  if (
    stack &&
    stack.isPlayerStack &&
    stack.currentTotalHp > 0 &&
    !stack.hasActedThisTurn
  ) {
    gameState.battle.selectedPlayerStackId = stackId;
    gameState.battle.selectedAction = null;
    gameState.battle.selectedTargetStackBattleId = null;
    addBattleLogEntry(
      `Selected ${stack.name} x${stack.count}. Choose action (Click Enemy/Defend).`,
    );
    renderBattleUI();
  }
}
function handleEnemyStackTargetSelectionInBattle(targetStackBattleId) {
  if (!gameState.battle.isActive || gameState.battle.currentTurn !== "player")
    return;
  const targetStack = findCombatantStackByBattleId(targetStackBattleId);
  if (
    !targetStack ||
    targetStack.isPlayerStack ||
    targetStack.currentTotalHp <= 0
  ) {
    showNotification("Invalid target.", "error");
    return;
  }

  if (gameState.battle.isAwaitingTargetSelection) {
    gameState.battle.selectedTargetStackBattleId = targetStackBattleId;
    gameState.battle.isAwaitingTargetSelection = false;
    if (gameState.battle.targetingSource === "agePower") {
      applyAgePowerEffect(gameState.battle.currentPendingAgePower);
    }
    gameState.battle.currentPendingAgePower = null;
    gameState.battle.targetingSource = null;
  } else if (gameState.battle.selectedPlayerStackId) {
    gameState.battle.selectedTargetStackBattleId = targetStackBattleId;
    gameState.battle.selectedAction = "attack";
    executeBattleAction();
  } else {
    showNotification("Select one of your units first!", "info");
  }
  renderBattleUI();
}
function addBattleLogEntry(message) {
  gameState.battle.log.push(message);
  if (gameState.battle.log.length > 50) gameState.battle.log.shift();
  if (DOMElements.battleModalOverlay.classList.contains("visible"))
    renderBattleUI();
}
function findCombatantStackByBattleId(battleId) {
  return (
    gameState.battle.playerParty.find((s) => s.battleId === battleId) ||
    gameState.battle.enemyParty.find((s) => s.battleId === battleId)
  );
}

function startPlayerTurn() {
  gameState.battle.currentTurn = "player";
  gameState.battle.actedStackIdsThisTurn = [];
  gameState.battle.playerParty.forEach((s) => {
    s.hasActedThisTurn = false;
    s.isDefending = false;
  });
  gameState.battle.enemyParty.forEach((s) => (s.isDefending = false));
  gameState.battle.selectedPlayerStackId = null;
  gameState.battle.selectedAction = null;
  gameState.battle.selectedTargetStackBattleId = null;

  for (const powerId in gameState.battle.agePowerCooldowns) {
    if (gameState.battle.agePowerCooldowns[powerId] > 0)
      gameState.battle.agePowerCooldowns[powerId]--;
  }

  addBattleLogEntry("--- Player Turn Start ---");
  showNotification("Your Turn! Select a unit and action.", "info", 2000);
  renderBattleUI();
}
function setupBattleActionListeners() {
  DOMElements.battleActionDefend.onclick = () => {
    if (
      !gameState.battle.selectedPlayerStackId ||
      gameState.battle.currentTurn !== "player"
    )
      return;
    gameState.battle.selectedAction = "defend";
    executeBattleAction();
  };
  DOMElements.battleEndTurnButton.onclick = () => {
    if (gameState.battle.currentTurn === "player") {
      addBattleLogEntry("--- Player Ends Turn ---");
      startAiTurn();
    }
  };
  DOMElements.battleLeaveButton.onclick = () => {
    if (gameState.battle.isActive) {
      addBattleLogEntry("Player conceded.");
      endBattle(false);
    }
  };
}
function executeBattleAction() {
  if (
    !gameState.battle.isActive ||
    !gameState.battle.selectedAction ||
    !gameState.battle.selectedPlayerStackId
  )
    return;
  const actingStack = findCombatantStackByBattleId(
    gameState.battle.selectedPlayerStackId,
  );
  if (
    !actingStack ||
    actingStack.currentTotalHp <= 0 ||
    actingStack.hasActedThisTurn
  ) {
    resetSelectionsAfterAction();
    return;
  }

  let actionTaken = false;
  if (gameState.battle.selectedAction === "attack") {
    if (!gameState.battle.selectedTargetStackBattleId) {
      showNotification(
        "Attack error: No target selected (should not happen with new flow)!",
        "error",
      );
      resetSelectionsAfterAction();
      return;
    }
    const targetStack = findCombatantStackByBattleId(
      gameState.battle.selectedTargetStackBattleId,
    );
    if (!targetStack || targetStack.currentTotalHp <= 0) {
      showNotification("Invalid target.", "error");
      gameState.battle.selectedTargetStackBattleId = null;
      renderBattleUI();
      return;
    }
    performStackAttack(actingStack, targetStack);
    actionTaken = true;
  } else if (gameState.battle.selectedAction === "defend") {
    actingStack.isDefending = true;
    actionTaken = true;
    addBattleLogEntry(
      `${actingStack.name} x${actingStack.count} is defending!`,
    );
    createEffectPopup(actingStack.battleId, "🛡️ Defending!");
  }

  if (actionTaken) {
    actingStack.hasActedThisTurn = true;
    gameState.battle.actedStackIdsThisTurn.push(actingStack.battleId);
    resetSelectionsAfterAction();
  } else {
    resetSelectionsAfterAction();
  }
  const canPlayerActFurther = gameState.battle.playerParty.some(
    (s) => s.currentTotalHp > 0 && !s.hasActedThisTurn,
  );
  if (!canPlayerActFurther && gameState.battle.currentTurn === "player") {
    addBattleLogEntry("All player units have acted.");
    DOMElements.battleEndTurnButton.click();
  } else {
    checkBattleEndCondition();
    renderBattleUI();
  }
}
function resetSelectionsAfterAction() {
  gameState.battle.selectedPlayerStackId = null;
  gameState.battle.selectedAction = null;
  gameState.battle.selectedTargetStackBattleId = null;
  renderBattleUI();
}

function startAiTurn() {
  gameState.battle.currentTurn = "ai";
  DOMElements.battleEndTurnButton.disabled = true;
  DOMElements.battleActionAttack.disabled = true;
  DOMElements.battleActionDefend.disabled = true;
  addBattleLogEntry("--- Enemy Turn Start ---");
  processAiActionsSequentially(
    [...gameState.battle.enemyParty.filter((s) => s.currentTotalHp > 0)].sort(
      (a, b) => b.speed - a.speed,
    ),
  );
}

function processAiActionsSequentially(aiStacks, index = 0) {
  if (!gameState.battle.isActive || index >= aiStacks.length) {
    if (gameState.battle.isActive) {
      addBattleLogEntry("--- Enemy Turn End ---");
      setTimeout(startPlayerTurn, 800);
    }
    return;
  }
  const aiStack = aiStacks[index];
  if (aiStack.currentTotalHp <= 0) {
    processAiActionsSequentially(aiStacks, index + 1);
    return;
  }
  aiStack.isDefending = false;
  const alivePlayerStacks = gameState.battle.playerParty.filter(
    (s) => s.currentTotalHp > 0,
  );
  if (alivePlayerStacks.length === 0) {
    processAiActionsSequentially(aiStacks, index + 1);
    return;
  }
  let action = "attack";
  if (
    aiStack.currentTotalHp < aiStack.count * aiStack.maxHpPerUnit * 0.4 &&
    Math.random() < 0.35
  )
    action = "defend";
  let delay = 1000 + Math.random() * 500;

  if (action === "attack") {
    const targetStack =
      alivePlayerStacks[Math.floor(Math.random() * alivePlayerStacks.length)];
    setTimeout(() => {
      if (
        gameState.battle.isActive &&
        aiStack.currentTotalHp > 0 &&
        targetStack.currentTotalHp > 0
      ) {
        performStackAttack(aiStack, targetStack);
        renderBattleUI();
        checkBattleEndCondition();
      }
      if (gameState.battle.isActive)
        processAiActionsSequentially(aiStacks, index + 1);
    }, delay);
  } else {
    aiStack.isDefending = true;
    addBattleLogEntry(
      `${aiStack.name} x${aiStack.count} takes a defensive stance!`,
    );
    createEffectPopup(aiStack.battleId, "🛡️ Defending!");
    renderBattleUI();
    setTimeout(() => {
      if (gameState.battle.isActive)
        processAiActionsSequentially(aiStacks, index + 1);
    }, delay / 2);
  }
}

function performStackAttack(attackerStack, mainTargetStack) {
  if (
    !attackerStack ||
    !mainTargetStack ||
    attackerStack.currentTotalHp <= 0 ||
    mainTargetStack.currentTotalHp <= 0
  )
    return;

  let totalRawAttackDamage = attackerStack.attackPerUnit * attackerStack.count * (0.8 + Math.random() * 0.4);
  totalRawAttackDamage = Math.floor(totalRawAttackDamage);

  let effectiveDefenseOfTargetUnit = mainTargetStack.defensePerUnit; // Base defense
  
  let finalDamageToTargetStack = Math.max(attackerStack.count, totalRawAttackDamage - effectiveDefenseOfTargetUnit);
  finalDamageToTargetStack = Math.max(0, finalDamageToTargetStack);

  if (mainTargetStack.isDefending) {
    const damageReductionPercentage = 0.8 + Math.random() * 0.2; // 80% to 100% reduction
    finalDamageToTargetStack = Math.floor(finalDamageToTargetStack * (1 - damageReductionPercentage));
    finalDamageToTargetStack = Math.max(0, finalDamageToTargetStack); // Ensure damage isn't negative after reduction
    addBattleLogEntry(`${mainTargetStack.name} defends, reducing damage significantly!`);
  }


  const logPrefix = `${attackerStack.name} x${attackerStack.count} attacks ${mainTargetStack.name}`;
  animateAttack(
    attackerStack.battleId,
    mainTargetStack.battleId,
    attackerStack.unitDef.icon,
    !attackerStack.unitDef.isRanged,
    () => {
      applyDamageToStack(
        mainTargetStack,
        finalDamageToTargetStack,
        logPrefix,
        attackerStack.isPlayerStack,
      );
      // Removed the old defense bonus log, as the new log is more explicit

      const attackerDef = attackerStack.unitDef;
      if (
        attackerDef.aoeType === "splash_all_others" &&
        attackerDef.aoeDamagePercent > 0 &&
        totalRawAttackDamage > 0 // Splash based on raw potential before defense
      ) {
        let rawSplashDamageBase = Math.floor(attackerStack.attackPerUnit * attackerStack.count * attackerDef.aoeDamagePercent);
        
        const enemyPartyToSplash = attackerStack.isPlayerStack
          ? gameState.battle.enemyParty
          : gameState.battle.playerParty;

        enemyPartyToSplash.forEach((otherStack) => {
          if (
            otherStack.battleId !== mainTargetStack.battleId &&
            otherStack.currentTotalHp > 0 &&
            otherStack.count > 0
          ) {
            let splashTargetEffectiveDefense = otherStack.defensePerUnit;
            let actualSplashDamage = Math.max(1, Math.floor(rawSplashDamageBase * (0.7 + Math.random() * 0.6) - splashTargetEffectiveDefense));
            actualSplashDamage = Math.max(0, actualSplashDamage);

            if (otherStack.isDefending) { // Apply defense reduction to splash damage too
                const splashDamageReductionPercentage = 0.8 + Math.random() * 0.2;
                actualSplashDamage = Math.floor(actualSplashDamage * (1 - splashDamageReductionPercentage));
                actualSplashDamage = Math.max(0, actualSplashDamage);
            }

            if(actualSplashDamage > 0) {
                 applyDamageToStack(
                    otherStack,
                    actualSplashDamage,
                    `Splash damage to ${otherStack.name}`,
                    attackerStack.isPlayerStack,
                    true,
                 );
            }
          }
        });
      }
      renderBattleUI();
      checkBattleEndCondition();
    },
  );
}

function checkBattleEndCondition() {
  if (!gameState.battle.isActive) return;
  const alivePlayerStacks = gameState.battle.playerParty.filter(
    (s) => s.currentTotalHp > 0 && s.count > 0,
  ).length;
  const aliveEnemyStacks = gameState.battle.enemyParty.filter(
    (s) => s.currentTotalHp > 0 && s.count > 0,
  ).length;
  if (alivePlayerStacks === 0) {
    endBattle(false);
  } else if (aliveEnemyStacks === 0) {
    endBattle(true);
  }
}

function endBattle(isVictory) {
  if (!gameState.battle.isActive) return;
  const battleType = gameState.battle.battleType;
  const currentDeployedArmyId = gameState.battle.currentDeployedArmyId;
  const enemyEncounterData =
    gameState.battle.enemyParty.length > 0 &&
    gameState.battle.enemyParty[0].originalEncounterData
      ? gameState.battle.enemyParty[0].originalEncounterData
      : { name: "Unknown Foe" };

  gameState.battle.isActive = false;

  if (isVictory) {
    const rewardGold = Math.floor(gameState.battle.rewards.gold);
    gameState.resources.gold += rewardGold;
    gameState.stats.battlesWon++;
    gameState.stats.enemiesDefeated++;
    addBattleLogEntry(
      `VICTORY vs ${enemyEncounterData.name}! Gained ${formatNumber(rewardGold)} gold!`,
    );
    showNotification(
      `Victory! +${formatNumber(rewardGold)} gold`,
      "success",
      4000,
    );

    if (battleType === "raid") {
      gameState.stats.raidsDefended = (gameState.stats.raidsDefended || 0) + 1;
      const raidId = enemyEncounterData.id;
      gameState.activeRaids = gameState.activeRaids.filter(
        (r) => r.id !== raidId,
      );
      gameState.mapEntities.raiders = gameState.mapEntities.raiders.filter(
        (rVisual) => rVisual.raidId !== raidId,
      );
      updateRaidAlertUI();
    } else if (battleType === "world_outpost" && enemyEncounterData.id) {
      const outpost = gameState.worldMap.outposts.find(
        (o) => o.id === enemyEncounterData.id,
      );
      if (outpost) outpost.isDefeated = true;
    }
  } else {
    gameState.stats.battlesLost++;
    addBattleLogEntry(
      `DEFEAT vs ${enemyEncounterData.name}! Your forces were routed.`,
    );
    showNotification("Defeat! Your army was crushed.", "error", 4000);
    if (battleType === "raid") {
      const raid = gameState.activeRaids.find(
        (r) => r.id === enemyEncounterData.id,
      );
      if (raid) {
        raid.destructionStartTime = gameState.stats.timePlayed;
        addMessage(
          `RAID ONGOING: ${raid.name} will begin destroying buildings!`,
          true,
        );
      }
    }
  }

  if (currentDeployedArmyId) {
    const deployedArmyIndex = gameState.worldMap.deployedArmies.findIndex(
      (da) => da.id === currentDeployedArmyId,
    );
    if (deployedArmyIndex !== -1) {
      const army = gameState.worldMap.deployedArmies[deployedArmyIndex];
      if (isVictory) {
        const survivingPlayerUnitsFromBattle = {};
        gameState.battle.playerParty.forEach(battleStack => {
            if (battleStack.count > 0 && UNITS[battleStack.type]) {
                survivingPlayerUnitsFromBattle[battleStack.type] = (survivingPlayerUnitsFromBattle[battleStack.type] || 0) + battleStack.count;
            }
        });
        
        army.units = Object.entries(survivingPlayerUnitsFromBattle).map(([type, count]) => ({
            type: type,
            count: count,
            icon: UNITS[type].icon
        }));

        if (army.units.length > 0 && battleType === "world_outpost") {
            army.status = "returning";
            army.totalTravelTime = army.originalTravelTimeToTarget || army.totalTravelTime; 
            army.travelProgress = 0;
            addBattleLogEntry(`Deployed army (ID: ...${army.id.slice(-4)}) is returning to base with survivors.`);
        } else if (army.units.length === 0) {
            addBattleLogEntry(`Deployed army (ID: ...${army.id.slice(-4)}) was wiped out!`);
            gameState.worldMap.deployedArmies.splice(deployedArmyIndex, 1);
        } else { 
            // Victory, but not a world outpost, or some other edge case. For now, just disband if not returning.
            if (army.status !== "returning") {
                addBattleLogEntry(`Deployed army (ID: ...${army.id.slice(-4)}) victorious but not returning automatically. Disbanded.`);
                gameState.worldMap.deployedArmies.splice(deployedArmyIndex, 1);
                // Potentially add units back to home base here if desired for non-outpost victories
            }
        }
      } else { // Defeat for deployed army
        addBattleLogEntry(`Deployed army (ID: ...${army.id.slice(-4)}) was wiped out!`);
        gameState.worldMap.deployedArmies.splice(deployedArmyIndex, 1);
      }
    }
    gameState.battle.currentDeployedArmyId = null;
  } else { // Home guard battle
    const newGameStateUnits = [];
    let totalUnitsLostCount = 0;
    gameState.battle.playerParty.forEach(battleStack => {
        if (battleStack.count > 0 && UNITS[battleStack.type]) {
            // These are survivors. Find corresponding original IDs and preserve them.
            // This simple mapping takes the first 'count' IDs from originalUnitIds.
            // A more complex system might track individual unit HP across a battle.
            for (let k=0; k < battleStack.count; k++) {
                const originalUnitIdToKeep = battleStack.originalUnitIds[k];
                const originalUnitInstance = gameState.units.find(u => u.id === originalUnitIdToKeep);
                if (originalUnitInstance) newGameStateUnits.push(originalUnitInstance);
                // If originalUnitInstance not found, it's an issue or a unit from a temporary source.
                // For simplicity, we assume originalUnitIds are from gameState.units here.
            }
        }
    });

    // Calculate units lost and adjust population
    const initialHomeUnitCount = gameState.units.length;
    const survivingHomeUnitCount = newGameStateUnits.length;
    totalUnitsLostCount = initialHomeUnitCount - survivingHomeUnitCount;

    // Reconstruct population based on survivors
    let newPopulation = 0;
    newGameStateUnits.forEach(survivingUnit => {
        newPopulation += UNITS[survivingUnit.type].population;
    });
    gameState.resources.population = newPopulation;
    gameState.units = newGameStateUnits;

    if (totalUnitsLostCount > 0) {
        addBattleLogEntry(`You lost ${totalUnitsLostCount} individual warriors from home guard.`);
    }
  }

  gameState.resources.population = Math.max(0, gameState.resources.population);
  gameState.battle = getDefaultGameState().battle; // Reset battle state fully
  hideModal(DOMElements.battleModalOverlay);
  DOMElements.battleButton.disabled = countTotalPlayerUnits() === 0 && gameState.worldMap.deployedArmies.length === 0;
  DOMElements.battleButton.textContent = "Find Random Enemy Outpost";
  loadAvailableUnits(); // Refresh unit list, especially important for home guard counts
  updateAllUIDisplays();
  renderGameView();
}






function applyDamageToStack(
  targetStack,
  damageAmount,
  logMessagePrefix = "",
  attackerIsPlayer,
  isSplash = false,
) {
  const actualDamageDealt = Math.min(targetStack.currentTotalHp, damageAmount);
  const oldTargetCount = targetStack.count;
  
  targetStack.currentTotalHp -= actualDamageDealt;

  if (targetStack.currentTotalHp <= 0) {
    targetStack.currentTotalHp = 0;
    targetStack.count = 0;
  } else {
    targetStack.count = Math.ceil(targetStack.currentTotalHp / targetStack.maxHpPerUnit);
  }
  targetStack.count = Math.max(0, targetStack.count); // Ensure count is not negative

  if (!isSplash) {
    addBattleLogEntry(
      `${logMessagePrefix} for ${actualDamageDealt} damage! (${targetStack.name} HP: ${targetStack.currentTotalHp}, Count: ${targetStack.count})`,
    );
  } else {
    addBattleLogEntry(
      ` -> ${targetStack.name} takes ${actualDamageDealt} splash damage. (HP: ${targetStack.currentTotalHp}, Count: ${targetStack.count})`,
    );
  }

  const targetElement = DOMElements.battleModalOverlay.querySelector(
    `.battle-unit-stack[data-battle-id="${targetStack.battleId}"]`,
  );
  if (targetElement && actualDamageDealt > 0) {
    const damagePopup = document.createElement("div");
    damagePopup.className = "damage-popup";
    damagePopup.textContent = `-${actualDamageDealt}`;
    const battleAreaRect = DOMElements.battleArea.getBoundingClientRect();
    const targetRect = targetElement.getBoundingClientRect();
    damagePopup.style.left = `${targetRect.left - battleAreaRect.left + targetRect.width / 2 - 15}px`;
    damagePopup.style.top = `${targetRect.top - battleAreaRect.top + targetRect.height / 3 - 20}px`;
    DOMElements.battleArea.appendChild(damagePopup);
    setTimeout(() => damagePopup.remove(), 1250);
  }

  if (targetStack.count === 0 && oldTargetCount > 0) {
    if (!isSplash)
      addBattleLogEntry(`${targetStack.name} stack has been wiped out!`);
  } else if (!isSplash && oldTargetCount > targetStack.count) {
    addBattleLogEntry(
      `${targetStack.name} lost ${oldTargetCount - targetStack.count} units.`,
    );
  }
  renderBattleUI();
}



function createEffectPopup(targetStackBattleId, effectText, type = "effect") {
  const targetElement = DOMElements.battleModalOverlay.querySelector(
    `.battle-unit-stack[data-battle-id="${targetStackBattleId}"]`,
  );
  if (targetElement) {
    const popup = document.createElement("div");
    popup.className = type === "heal" ? "heal-popup" : "effect-popup";
    popup.textContent = effectText;
    const battleAreaRect = DOMElements.battleArea.getBoundingClientRect();
    const targetRect = targetElement.getBoundingClientRect();
    popup.style.left = `${targetRect.left - battleAreaRect.left + targetRect.width / 2 - effectText.length * 4}px`;
    popup.style.top = `${targetRect.top - battleAreaRect.top - 20}px`;
    DOMElements.battleArea.appendChild(popup);
    setTimeout(() => popup.remove(), 1450);
  }
}
function animateAttack(
  attackerId,
  targetId,
  icon,
  isMelee,
  onCompleteCallback,
) {
  const attackerElement = DOMElements.battleModalOverlay.querySelector(
    `.battle-unit-stack[data-battle-id="${attackerId}"]`,
  );
  const targetElement = DOMElements.battleModalOverlay.querySelector(
    `.battle-unit-stack[data-battle-id="${targetId}"]`,
  );
  if (!attackerElement || !targetElement) {
    if (onCompleteCallback) onCompleteCallback();
    return;
  }

  const animationDuration = isMelee ? 700 : 400;
  const isPlayerAttacking = attackerElement.classList.contains("player-stack");

  if (isMelee) {
    attackerElement.classList.add(
      isPlayerAttacking ? "anim-melee-attack" : "anim-melee-attack-enemy",
    );
    setTimeout(() => {
      attackerElement.classList.remove(
        isPlayerAttacking ? "anim-melee-attack" : "anim-melee-attack-enemy",
      );
      if (onCompleteCallback) onCompleteCallback();
    }, animationDuration);
  } else {
    const projectile = document.createElement("div");
    projectile.className = "projectile";
    projectile.textContent = icon;

    const projectileContainerRect =
      DOMElements.projectileContainer.getBoundingClientRect();
    const attackerRect = attackerElement.getBoundingClientRect();
    const targetRect = targetElement.getBoundingClientRect();

    const startX =
      attackerRect.left + attackerRect.width / 2 - projectileContainerRect.left;
    const startY =
      attackerRect.top + attackerRect.height / 3 - projectileContainerRect.top;
    const endX =
      targetRect.left + targetRect.width / 2 - projectileContainerRect.left;
    const endY =
      targetRect.top + targetRect.height / 2 - projectileContainerRect.top;

    projectile.style.position = "absolute";
    projectile.style.left = `${startX - 10}px`;
    projectile.style.top = `${startY - 10}px`;
    DOMElements.projectileContainer.appendChild(projectile);

    requestAnimationFrame(() => {
      projectile.style.transform = `translate(${endX - startX}px, ${endY - startY}px)`;
    });

    setTimeout(() => {
      projectile.classList.add("hit");
      setTimeout(() => {
        projectile.remove();
      }, 100);
      if (onCompleteCallback) onCompleteCallback();
    }, animationDuration);
  }
}

function renderAgePowers() {
  DOMElements.battleAgePowersContainer.innerHTML = "";
  const currentAgePower = AGES[gameState.age].specialPower;
  if (currentAgePower) {
    const cooldown =
      gameState.battle.agePowerCooldowns[currentAgePower.id] || 0;
    const canAfford = checkAgePowerCost(currentAgePower);
    const canUse =
      cooldown <= 0 &&
      canAfford &&
      gameState.battle.currentTurn === "player" &&
      !gameState.battle.isAwaitingTargetSelection;
    const el = document.createElement("button");
    el.className = "game-button age-power-button";
    el.disabled = !canUse;
    el.dataset.powerId = currentAgePower.id;
    el.dataset.tooltip = `<strong>${currentAgePower.name} (${currentAgePower.icon})</strong><br>${currentAgePower.description}<br>Cost: ${currentAgePower.cost} ${currentAgePower.costType}<br>${cooldown > 0 ? `Cooldown: ${cooldown} turns` : canAfford ? "Ready!" : "Cannot afford"}`;
    el.innerHTML = `<span>${currentAgePower.icon} ${currentAgePower.name} ${cooldown > 0 ? `(${cooldown})` : ""}</span><span>${currentAgePower.cost} ${currentAgePower.costType.slice(0, 1).toUpperCase()}</span>`;
    el.onclick = () => attemptUseAgePower(currentAgePower.id);
    DOMElements.battleAgePowersContainer.appendChild(el);
  } else {
    DOMElements.battleAgePowersContainer.innerHTML =
      "<span style='align-self: center; opacity: 0.7;'>No Age Power available.</span>";
  }
}
function checkAgePowerCost(powerDef) {
  if (powerDef.costType === "gold")
    return gameState.resources.gold >= powerDef.cost;
  if (powerDef.costType === "tech")
    return gameState.resources.technologyPoints >= powerDef.cost;
  return true;
}
function attemptUseAgePower(powerId) {
  const powerDef = AGES[gameState.age].specialPower;
  if (
    !powerDef ||
    powerDef.id !== powerId ||
    (gameState.battle.agePowerCooldowns[powerId] || 0) > 0 ||
    !checkAgePowerCost(powerDef) ||
    gameState.battle.currentTurn !== "player"
  )
    return;

  if (
    powerDef.targetType === "enemy_stack_select" ||
    powerDef.targetType === "player_stack_select" ||
    powerDef.targetType === "directDamageSplash"
  ) {
    gameState.battle.isAwaitingTargetSelection = true;
    gameState.battle.targetingSource = "agePower";
    gameState.battle.currentPendingAgePower = powerDef;
    gameState.battle.selectedAction = null;
    gameState.battle.selectedPlayerStackId = null;
    showNotification(`Select target for ${powerDef.name}.`, "info", 3000);
    addBattleLogEntry(`Activated ${powerDef.name}. Select target.`);
    renderBattleUI();
  } else {
    applyAgePowerEffect(powerDef);
  }
}

function applyAgePowerEffect(powerDef) {
  if (!checkAgePowerCost(powerDef)) {
    showNotification(`Error: Cannot afford ${powerDef.name}!`, "error");
    return;
  }
  if (powerDef.costType === "gold") gameState.resources.gold -= powerDef.cost;
  else if (powerDef.costType === "tech")
    gameState.resources.technologyPoints -= powerDef.cost;

  addBattleLogEntry(`Player uses Age Power: ${powerDef.name}!`);
  createEffectPopup(
    gameState.battle.playerParty.length > 0
      ? gameState.battle.playerParty[0].battleId
      : "none",
    `${powerDef.icon} ${powerDef.name}!`,
    "info",
  );

  let targetStack;
  switch (powerDef.effect) {
    case "directDamage":
    case "directDamageSplash":
      targetStack = findCombatantStackByBattleId(
        gameState.battle.selectedTargetStackBattleId,
      );
      if (targetStack) {
        applyDamageToStack(
          targetStack,
          powerDef.damageBase,
          `${powerDef.name} hits ${targetStack.name}`,
          true,
        );
        if (
          powerDef.effect === "directDamageSplash" &&
          powerDef.aoeDamagePercent > 0
        ) {
          const splashDamage = Math.max(
            1,
            Math.floor(powerDef.damageBase * powerDef.aoeDamagePercent),
          );
          gameState.battle.enemyParty.forEach((otherTarget) => {
            if (
              otherTarget.battleId !== targetStack.battleId &&
              otherTarget.currentTotalHp > 0
            ) {
              applyDamageToStack(
                otherTarget,
                splashDamage,
                `Splash from ${powerDef.name} hits ${otherTarget.name}`,
                true,
                true,
              );
            }
          });
        }
      } else {
        addBattleLogEntry("Invalid or no target selected for age power!");
      }
      break;
    case "aoeDamage":
      const targets =
        powerDef.targetType === "all_enemies"
          ? gameState.battle.enemyParty
          : gameState.battle.playerParty;
      targets.forEach((tStack) => {
        if (tStack.currentTotalHp > 0) {
          applyDamageToStack(
            tStack,
            powerDef.damageBase,
            `${powerDef.name} strikes ${tStack.name}`,
            true,
            true,
          );
        }
      });
      break;
    case "buff_attack_once":
      targetStack = findCombatantStackByBattleId(
        gameState.battle.selectedTargetStackBattleId,
      );
      if (targetStack && targetStack.isPlayerStack) {
        targetStack.temporaryAttackMultiplier =
          (targetStack.temporaryAttackMultiplier || 1) * powerDef.buffAmount;
        addBattleLogEntry(`${targetStack.name} gets an attack boost!`);
        createEffectPopup(targetStack.battleId, `⚔️+ Atk Up!`);
      } else {
        addBattleLogEntry(`Invalid target for Rally Troops.`);
      }
      break;
    case "buff_defense_all":
      gameState.battle.playerParty.forEach((pStack) => {
        if (pStack.currentTotalHp > 0) {
          pStack.isDefending = true;
          createEffectPopup(pStack.battleId, `🛡️++ Def Up!`);
        }
      });
      addBattleLogEntry(`All player units bolster their defenses!`);
      break;
    default:
      addBattleLogEntry(
        `Age power effect '${powerDef.effect}' not fully implemented.`,
      );
  }

  gameState.battle.agePowerCooldowns[powerDef.id] = powerDef.cooldownTurns;
  gameState.battle.selectedTargetStackBattleId = null;
  renderBattleUI();
  updateResourceDisplays();
  checkBattleEndCondition();
}

function loadAvailableTechnologies() {
  DOMElements.techContainer.innerHTML = "";
  const available = Object.values(TECHNOLOGIES).filter(
    (tech) =>
      tech.minAge <= gameState.age &&
      !gameState.technologies.includes(tech.id) &&
      tech.prereqs.every((prereq) => gameState.technologies.includes(prereq)),
  );
  available.forEach((tech) => {
    const effectsDesc = tech.effects
      .map((e) => {
        let valStr =
          e.operation === "multiply"
            ? `x${e.value.toFixed(1)}`
            : e.value > 0
              ? `+${e.value}`
              : `${e.value}`;
        return `${valStr} ${e.target.replace(/([A-Z])/g, " $1").toLowerCase()}`;
      })
      .join(", ");
    const el = document.createElement("button");
    el.className = "game-button";
    el.dataset.itemId = tech.id;
    el.dataset.tooltip = `<strong>${tech.name} (${tech.icon})</strong><br>${tech.description}<br><em>Effect: ${effectsDesc}</em><br>Time: ${tech.researchTime}s`;
    el.innerHTML = `<span>${tech.icon} ${tech.name}</span><span>${formatNumber(tech.cost)}</span>`;
    el.addEventListener("click", () => startResearch(tech.id));
    DOMElements.techContainer.appendChild(el);
  });
  updateButtonStates();
}
function startResearch(techId) {
  if (gameState.currentResearch.id) {
    showNotification("Researching!", "error");
    return;
  }
  const techInfo = TECHNOLOGIES[techId];
  if (gameState.resources.gold < techInfo.cost) {
    showNotification("No gold!", "error");
    return;
  }
  gameState.resources.gold -= techInfo.cost;
  gameState.currentResearch = {
    id: techId,
    progress: 0,
    timeToComplete: techInfo.researchTime,
  };
  showNotification(`Researching ${techInfo.name}...`, "info");
  addMessage(`Started research: ${techInfo.name}.`);
  updateAllUIDisplays();
}
function completeResearch() {
  const techId = gameState.currentResearch.id;
  const techInfo = TECHNOLOGIES[techId];
  gameState.technologies.push(techId);
  applyEffects(techInfo);
  gameState.stats.techsResearched++;
  gameState.currentResearch = { id: null, progress: 0, timeToComplete: 0 };
  showNotification(`${techInfo.name} researched!`, "success");
  addMessage(`Completed research: ${techInfo.name}.`);
  loadAvailableTechnologies();
  loadAvailableBuildings();
  loadAvailableUnits();
  updateAllUIDisplays();
}
function advanceAge() {
  if (gameState.age >= AGES.length - 1) return;
  const nextAgeReq = AGES[gameState.age + 1];
  if (gameState.resources.technologyPoints >= nextAgeReq.techCost) {
    gameState.resources.technologyPoints -= nextAgeReq.techCost;
    gameState.age++;
    showNotification(
      `Advanced to ${AGES[gameState.age].name}!`,
      "success",
      5000,
    );
    addMessage(`Empire advanced to the ${AGES[gameState.age].name}!`);

    const buildingsToProcess = [...gameState.buildings];
    buildingsToProcess.forEach((buildingInstance) => {
      if (!buildingInstance.isConstructed) return;

      const currentBuildingDef = BUILDINGS[buildingInstance.type];
      if (currentBuildingDef.upgradesTo) {
        const upgradeToDefId = currentBuildingDef.upgradesTo;
        const upgradeToDef = BUILDINGS[upgradeToDefId];

        if (upgradeToDef && upgradeToDef.minAge <= gameState.age) {
          let canUpgradeFit = true;
          if (
            upgradeToDef.sizeX > currentBuildingDef.sizeX ||
            upgradeToDef.sizeY > currentBuildingDef.sizeY
          ) {
            canUpgradeFit = checkUpgradeFit(buildingInstance, upgradeToDef);
          }

          if (canUpgradeFit) {
            const originalBuilding = gameState.buildings.find(
              (b) => b.id === buildingInstance.id,
            );
            if (originalBuilding && originalBuilding.type !== upgradeToDefId) {
              addMessage(
                `INFO: Your ${currentBuildingDef.name} automatically upgraded to ${upgradeToDef.name}!`,
              );
              applyEffects(currentBuildingDef, true);
              originalBuilding.type = upgradeToDefId;
              originalBuilding.level = (originalBuilding.level || 1) + 1;
              originalBuilding.sizeX = upgradeToDef.sizeX;
              originalBuilding.sizeY = upgradeToDef.sizeY;
              applyEffects(upgradeToDef, false);
            }
          } else {
            addMessage(
              `INFO: Your ${currentBuildingDef.name} at [${buildingInstance.gridX},${buildingInstance.gridY}] could not upgrade to ${upgradeToDef.name} due to lack of space.`,
              "error",
            );
          }
        }
      }
    });
    generateWorldOutpostsIfNeeded();
    loadAvailableBuildings();
    loadAvailableUnits();
    loadAvailableTechnologies();
    updateAllUIDisplays();
    renderGameView();
  } else {
    showNotification("Not enough Tech Points!", "error");
  }
}
function checkUpgradeFit(buildingInstance, newBuildingDef) {
  for (let y = 0; y < newBuildingDef.sizeY; y++) {
    for (let x = 0; x < newBuildingDef.sizeX; x++) {
      const checkX = buildingInstance.gridX + x;
      const checkY = buildingInstance.gridY + y;
      if (x >= buildingInstance.sizeX || y >= buildingInstance.sizeY) {
        const occupyingBuilding = getBuildingAtGrid(checkX, checkY);
        if (occupyingBuilding && occupyingBuilding.id !== buildingInstance.id) {
          return false;
        }
      }
    }
  }
  return true;
}

function checkAchievements() {
  ACHIEVEMENTS_DATA.forEach((ach) => {
    if (!gameState.achievements.includes(ach.id) && ach.condition(gameState))
      unlockAchievement(ach);
  });
}
function unlockAchievement(achievement) {
  gameState.achievements.push(achievement.id);
  DOMElements.achievementNamePopup.textContent = achievement.name;
  DOMElements.achievementNotificationPopup.classList.add("show");
  addMessage(`🏆 Achievement: ${achievement.name}`, true);
  setTimeout(
    () => DOMElements.achievementNotificationPopup.classList.remove("show"),
    4000,
  );
}
function showAchievementsScreen() {
  let contentHtml = `<h2>Achievements</h2><div id="achievements-list">`;
  ACHIEVEMENTS_DATA.forEach((ach) => {
    const isUnlocked = gameState.achievements.includes(ach.id);
    contentHtml += `<div class="item-slot ${isUnlocked ? "" : "disabled"}" style="cursor:default;"><div class="item-icon">${isUnlocked ? "🏆" : "⚪"}</div><div class="item-details"><div class="item-name">${ach.name}</div><div class="item-description">${ach.description}</div></div><div class="item-cost" style="color:${isUnlocked ? "var(--success-color)" : "var(--text-color)"};">${isUnlocked ? "Unlocked" : "Locked"}</div></div>`;
  });
  contentHtml += `</div>`;
  DOMElements.genericOverlayContent.innerHTML = contentHtml;
  DOMElements.genericOverlayCloseButton.onclick = () =>
    hideModal(DOMElements.genericOverlay);
  showModal(DOMElements.genericOverlay);
}
function showTutorial(startAtZero = false) {
  if (startAtZero) gameState.tutorial.step = 0;
  displayTutorialStep();
  showModal(DOMElements.tutorialOverlay);
}
function displayTutorialStep() {
  const stepData = TUTORIAL_STEPS[gameState.tutorial.step];
  DOMElements.tutorialTitle.textContent = stepData.title;
  DOMElements.tutorialBodyContent.innerHTML = `<p>${stepData.content.replace(/\n/g, "</p><p>")}</p>`;
  DOMElements.tutorialPrevButton.disabled = gameState.tutorial.step === 0;
  DOMElements.tutorialNextButton.style.display =
    gameState.tutorial.step === TUTORIAL_STEPS.length - 1 ? "none" : "flex";
  DOMElements.tutorialCloseButton.style.display =
    gameState.tutorial.step === TUTORIAL_STEPS.length - 1 ? "flex" : "none";
}
function nextTutorialStep() {
  if (gameState.tutorial.step < TUTORIAL_STEPS.length - 1) {
    gameState.tutorial.step++;
    displayTutorialStep();
  }
}
function previousTutorialStep() {
  if (gameState.tutorial.step > 0) {
    gameState.tutorial.step--;
    displayTutorialStep();
  }
}
function closeTutorial() {
  gameState.tutorial.complete = true;
  hideModal(DOMElements.tutorialOverlay);
  saveGame(true);
}

function checkForNewRaid(currentTime) {
  if (gameState.battle.isActive || gameState.activeRaids.length > 2) return;
  const ageData = AGES[gameState.age];
  const timePlayedModifier = Math.min(
    2.5,
    1 + gameState.stats.timePlayed / 1200,
  );
  const raidChance = ageData.raidChanceBase * timePlayedModifier;
  if (Math.random() < raidChance) {
    spawnRaid(currentTime);
  }
}
function spawnRaid(currentTime) {
  gameState.stats.raidsSpawned++;
  const ageData = AGES[gameState.age];
  const strengthPool =
    (50 + gameState.stats.timePlayed / 20 + gameState.stats.battlesWon * 2) *
    ageData.raidStrengthMod;
  const availableEnemyTypesForAge = Object.values(UNITS).filter(
    (u) =>
      u.minAge <= gameState.age && u.maxAge >= Math.max(0, gameState.age - 1),
  );
  if (availableEnemyTypesForAge.length === 0)
    availableEnemyTypesForAge.push(UNITS.clubber);

  const composition = [];
  let currentStrengthForComp = 0;
  let tries = 0;
  while (
    currentStrengthForComp < strengthPool &&
    tries < 10 &&
    composition.length < 5
  ) {
    const randomUnitDef =
      availableEnemyTypesForAge[
        Math.floor(Math.random() * availableEnemyTypesForAge.length)
      ];
    const unitStr =
      randomUnitDef.baseAttack +
      randomUnitDef.baseDefense +
      randomUnitDef.maxHp / 5;
    const maxCountPossible = Math.floor(
      (strengthPool - currentStrengthForComp) / Math.max(1, unitStr),
    );
    if (maxCountPossible <= 0) {
      tries++;
      continue;
    }
    const count = Math.max(
      1,
      Math.min(10, Math.floor(Math.random() * maxCountPossible) + 1),
    );
    composition.push({
      type: randomUnitDef.id,
      count: count,
      unitDef: randomUnitDef,
    });
    currentStrengthForComp += count * unitStr;
    tries++;
  }
  if (composition.length === 0) {
    const fallbackUnit = UNITS.clubber;
    composition.push({
      type: fallbackUnit.id,
      count: Math.max(
        1,
        Math.floor(strengthPool / (fallbackUnit.baseAttack * 2)),
      ),
      unitDef: fallbackUnit,
    });
    currentStrengthForComp = fallbackUnit.baseAttack * 2 * composition[0].count;
  }

  const raidId = uniqueId("raid_");
  const raidName = `${AGES[gameState.age].name.split(" ")[0]} Marauders`;
  const raidIcon = ["🐺", "⚔️", "🏴‍☠️", "👺", "💀", "👽"][
    Math.min(gameState.age, 5)
  ];

  gameState.activeRaids.push({
    id: raidId,
    name: raidName,
    icon: raidIcon,
    composition: composition,
    arrivalTime: currentTime + RAID_BASE_DURATION_BEFORE_DESTRUCTION,
    destructionStartTime: null,
    timeToDestroyBuildingInterval: Math.max(15, 50 - gameState.age * 4),
    currentTargetBuildingId: null,
    strengthScore: Math.floor(currentStrengthForComp),
  });

  const startEdge = Math.floor(Math.random() * 4);
  let startMapX, startMapY;
  switch (startEdge) {
    case 0:
      startMapX = gameState.map.ownedTilesX[0] - 3;
      startMapY =
        Math.floor(
          Math.random() *
            (gameState.map.ownedTilesY[1] - gameState.map.ownedTilesY[0] + 1),
        ) + gameState.map.ownedTilesY[0];
      break;
    case 1:
      startMapX = gameState.map.ownedTilesX[1] + 3;
      startMapY =
        Math.floor(
          Math.random() *
            (gameState.map.ownedTilesY[1] - gameState.map.ownedTilesY[0] + 1),
        ) + gameState.map.ownedTilesY[0];
      break;
    case 2:
      startMapX =
        Math.floor(
          Math.random() *
            (gameState.map.ownedTilesX[1] - gameState.map.ownedTilesX[0] + 1),
        ) + gameState.map.ownedTilesX[0];
      startMapY = gameState.map.ownedTilesY[0] - 3;
      break;
    default:
      startMapX =
        Math.floor(
          Math.random() *
            (gameState.map.ownedTilesX[1] - gameState.map.ownedTilesX[0] + 1),
        ) + gameState.map.ownedTilesX[0];
      startMapY = gameState.map.ownedTilesY[1] + 3;
      break;
  }

  gameState.mapEntities.raiders.push({
    id: uniqueId("raider_vis_"),
    raidId: raidId,
    icon: raidIcon,
    gridX: startMapX,
    gridY: startMapY,
    targetGridX: null,
    targetGridY: null,
    speed: 0.05 + Math.random() * 0.05,
    state: "approaching",
    targetBuildingId: null,
  });

  addMessage(
    `WARNING: ${raidName} ${raidIcon} are approaching! Intercept them!`,
    true,
  );
  showNotification(`${raidName} detected!`, "error", 5000);
  updateRaidAlertUI();
  renderGameView();
}

function processActiveRaids(currentTime) {
  for (let i = gameState.activeRaids.length - 1; i >= 0; i--) {
    const raid = gameState.activeRaids[i];
    const raiderVisuals = gameState.mapEntities.raiders.filter(
      (rv) => rv.raidId === raid.id,
    );

    if (raid.destructionStartTime && currentTime >= raid.destructionStartTime) {
      let targetBuildingToDamage = null;
      let engagedRaider = raiderVisuals.find(
        (rv) => rv.state === "engaging_building" && rv.targetBuildingId,
      );

      if (engagedRaider) {
        targetBuildingToDamage = gameState.buildings.find(
          (bldg) =>
            bldg.id === engagedRaider.targetBuildingId && bldg.isConstructed,
        );
      }

      if (!targetBuildingToDamage && raiderVisuals.length > 0) {
        const anyRaider = raiderVisuals[0];
        let closestDist = Infinity;
        const constructedBuildings = gameState.buildings.filter(
          (b) => b.isConstructed,
        );
        for (const b of constructedBuildings) {
          const dist = Math.sqrt(
            Math.pow(anyRaider.gridX - b.gridX, 2) +
              Math.pow(anyRaider.gridY - b.gridY, 2),
          );
          if (dist < closestDist) {
            closestDist = dist;
            targetBuildingToDamage = b;
          }
        }
      }

      if (targetBuildingToDamage) {
        const buildingDef = BUILDINGS[targetBuildingToDamage.type];
        applyEffects(buildingDef, true);
        const buildingIndex = gameState.buildings.findIndex(
          (b) => b.id === targetBuildingToDamage.id,
        );
        if (buildingIndex !== -1) gameState.buildings.splice(buildingIndex, 1);

        gameState.stats.buildingsLostToRaids++;
        addMessage(
          `RAID DAMAGE! Your ${buildingDef.name} has been destroyed by ${raid.name}!`,
          true,
        );
        showNotification(`${buildingDef.name} destroyed by raiders!`, "error");
        loadAvailableBuildings();
        renderGameView();
        raid.destructionStartTime =
          currentTime + raid.timeToDestroyBuildingInterval;

        raiderVisuals.forEach((rv) => {
          if (rv.targetBuildingId === targetBuildingToDamage.id) {
            rv.state = "pillaging_area";
            rv.targetBuildingId = null;
            rv.targetGridX = null;
          }
        });
      }

      if (gameState.buildings.filter((b) => b.isConstructed).length === 0) {
        addMessage(
          `${raid.name} have pillaged all they can and departed.`,
          true,
        );
        gameState.activeRaids.splice(i, 1);
        raiderVisuals.forEach((rv) => (rv.state = "leaving"));
      }
    } else if (!raid.destructionStartTime && currentTime >= raid.arrivalTime) {
      raid.destructionStartTime =
        currentTime + raid.timeToDestroyBuildingInterval;
      addMessage(
        `ALERT! ${raid.name} ${raid.icon} have reached your settlement and will begin pillaging!`,
        true,
      );
      raiderVisuals.forEach((rv) => {
        rv.state = "pillaging_area";
        rv.targetGridX = null;
      });
    }

    raiderVisuals.forEach((raiderVisual) => {
      if (
        raiderVisual.state === "approaching" ||
        raiderVisual.state === "pillaging_area"
      ) {
        if (
          raiderVisual.targetGridX === null ||
          (Math.abs(raiderVisual.gridX - raiderVisual.targetGridX) < 0.5 &&
            Math.abs(raiderVisual.gridY - raiderVisual.targetGridY) < 0.5)
        ) {
          raiderVisual.targetGridX =
            Math.floor(
              Math.random() *
                (gameState.map.ownedTilesX[1] -
                  gameState.map.ownedTilesX[0] +
                  1),
            ) + gameState.map.ownedTilesX[0];
          raiderVisual.targetGridY =
            Math.floor(
              Math.random() *
                (gameState.map.ownedTilesY[1] -
                  gameState.map.ownedTilesY[0] +
                  1),
            ) + gameState.map.ownedTilesY[0];
        }
        const dx = raiderVisual.targetGridX - raiderVisual.gridX;
        const dy = raiderVisual.targetGridY - raiderVisual.gridY;
        const dist = Math.sqrt(dx * dx + dy * dy);

        let intendedNextGridX = raiderVisual.gridX;
        let intendedNextGridY = raiderVisual.gridY;

        if (dist > raiderVisual.speed) {
          intendedNextGridX += (dx / dist) * raiderVisual.speed;
          intendedNextGridY += (dy / dist) * raiderVisual.speed;
        } else {
          intendedNextGridX = raiderVisual.targetGridX;
          intendedNextGridY = raiderVisual.targetGridY;
        }

        const buildingAtIntendedNext = getBuildingAtGrid(
          Math.round(intendedNextGridX),
          Math.round(intendedNextGridY),
        );

        if (
          buildingAtIntendedNext &&
          buildingAtIntendedNext.isConstructed &&
          (Math.round(intendedNextGridX) !== Math.round(raiderVisual.gridX) ||
            Math.round(intendedNextGridY) !== Math.round(raiderVisual.gridY))
        ) {
          if (
            raiderVisual.state !== "engaging_building" ||
            raiderVisual.targetBuildingId !== buildingAtIntendedNext.id
          ) {
            raiderVisual.state = "engaging_building";
            raiderVisual.targetBuildingId = buildingAtIntendedNext.id;
          }
        } else {
          raiderVisual.gridX = intendedNextGridX;
          raiderVisual.gridY = intendedNextGridY;
          if (
            raiderVisual.state === "engaging_building" &&
            (!buildingAtIntendedNext ||
              buildingAtIntendedNext.id !== raiderVisual.targetBuildingId)
          ) {
            raiderVisual.state = "pillaging_area";
            raiderVisual.targetBuildingId = null;
            raiderVisual.targetGridX = null;
          }
        }
      } else if (raiderVisual.state === "leaving") {
        raiderVisual.gridX +=
          (raiderVisual.gridX > 0 ? 1 : -1) * raiderVisual.speed * 2;
        raiderVisual.gridY +=
          (raiderVisual.gridY > 0 ? 1 : -1) * raiderVisual.speed * 2;
        if (
          Math.abs(raiderVisual.gridX) > MAX_MAP_GRID_DIM + 5 ||
          Math.abs(raiderVisual.gridY) > MAX_MAP_GRID_DIM + 5
        ) {
          gameState.mapEntities.raiders = gameState.mapEntities.raiders.filter(
            (rv) => rv.id !== raiderVisual.id,
          );
        }
      }
    });
  }
  updateRaidAlertUI();
}
function updateRaidAlertUI() {
  if (gameState.activeRaids.length > 0) {
    DOMElements.raidAlertSection.style.display = "block";
    DOMElements.activeRaidsList.innerHTML = gameState.activeRaids
      .map((raid) => {
        let statusText = "Approaching...";
        if (
          raid.destructionStartTime &&
          gameState.stats.timePlayed >= raid.destructionStartTime
        )
          statusText = "PILLAGING!";
        else if (gameState.stats.timePlayed >= raid.arrivalTime)
          statusText = "ARRIVED!";
        return `<div class="item-slot" style="border-left: 3px solid var(--error-color);"><div class="item-icon enemy-icon">${raid.icon}</div><div class="item-details"><div class="item-name">${raid.name} (Str: ${formatNumber(raid.strengthScore)})</div><div class="item-description">${statusText}</div></div><button class="game-button raid-alert-button" style="padding: 5px 10px; flex-grow:0; min-width: 100px;" onclick="interceptRaid('${raid.id}')">Intercept!</button></div>`;
      })
      .join("");
  } else {
    DOMElements.raidAlertSection.style.display = "none";
  }
}
function interceptRaid(raidId) {
  const raid = gameState.activeRaids.find((r) => r.id === raidId);
  if (raid && !gameState.battle.isActive) {
    if (countTotalPlayerUnits() === 0) {
      showNotification("You have no units to intercept the raid!", "error");
      return;
    }
    const encounterDataForBattle = {
      id: raid.id,
      name: raid.name,
      description: "Hostile raiders attacking your settlement!",
      icon: raid.icon,
      composition: raid.composition,
      reward: Math.floor(raid.strengthScore * 0.5 + 50),
    };
    initiateBattle(encounterDataForBattle, "raid");
  } else if (gameState.battle.isActive) {
    showNotification(
      "Cannot intercept raid while another battle is in progress.",
      "info",
    );
  }
}

function saveGame(isAutoSave = false) {
  try {
    const stateToSave = JSON.parse(JSON.stringify(gameState));
    if (stateToSave.battle.isActive)
      stateToSave.battle = getDefaultGameState().battle;
    localStorage.setItem(SAVE_GAME_KEY, JSON.stringify(stateToSave));
    if (!isAutoSave) {
      showNotification("Game Saved!", "success");
      addMessage("Game progress saved.");
    }
  } catch (e) {
    console.error("Error saving game:", e);
    showNotification("Error saving. Storage full?", "error");
  }
}
function loadGame() {
  const savedData = localStorage.getItem(SAVE_GAME_KEY);
  if (savedData) {
    try {
      const loadedState = JSON.parse(savedData);
      if (
        loadedState.gameVersion?.split(".")[0] !==
          gameState.gameVersion?.split(".")[0] &&
        !confirm(
          "Saved game version mismatch likely. Load anyway? May cause issues.",
        )
      )
        return;
      const defaultState = getDefaultGameState();
      gameState = deepMerge(defaultState, loadedState);
      if (!gameState.battle.isActive) gameState.battle = defaultState.battle;
      if (!gameState.battle.agePowerCooldowns)
        gameState.battle.agePowerCooldowns = {};
      if (!gameState.map) gameState.map = defaultState.map;
      if (!gameState.constructionQueue) gameState.constructionQueue = [];
      if (!gameState.mapEntities || !gameState.mapEntities.raiders)
        gameState.mapEntities = { raiders: [] };
      else {
        gameState.mapEntities.raiders = gameState.mapEntities.raiders || [];
      }
      if (!gameState.worldMap || !gameState.worldMap.outposts)
        gameState.worldMap = { outposts: [], deployedArmies: [] };
      else {
        gameState.worldMap.deployedArmies =
          gameState.worldMap.deployedArmies || [];
      }
      if (!gameState.map.ownedTilesX || !gameState.map.ownedTilesY) {
        gameState.map.ownedTilesX = [-5, 5];
        gameState.map.ownedTilesY = [-5, 5];
      }
      if (!gameState.stats.mapExpansions) gameState.stats.mapExpansions = 0;
      if (gameState.map.nextExpansionCost === undefined)
        gameState.map.nextExpansionCost =
          100 + gameState.stats.mapExpansions * 75;
      if (!gameState.map.discoveredTiles) gameState.map.discoveredTiles = {};
      nextRaidCheckTime =
        gameState.stats.timePlayed + RAID_CHECK_INTERVAL / 1000;
      showNotification("Game Loaded!", "success");
      addMessage("Game progress loaded.");
      loadAvailableBuildings();
      loadAvailableUnits();
      loadAvailableTechnologies();
      updateAllUIDisplays();
      renderGameView();
      if (!gameState.tutorial.complete) showTutorial();
    } catch (e) {
      console.error("Error loading game:", e);
      showNotification("Error loading. Corrupted data?", "error");
      localStorage.removeItem(SAVE_GAME_KEY);
      gameState = getDefaultGameState();
      initGame();
    }
  } else {
    showNotification("No saved game found.", "info");
  }
}
function deepMerge(target, source) {
  for (const key in source) {
    if (source.hasOwnProperty(key)) {
      if (
        source[key] instanceof Object &&
        key in target &&
        target[key] instanceof Object &&
        !(source[key] instanceof Element) &&
        !Array.isArray(source[key]) &&
        key !== "mapEntities" &&
        key !== "activeRaids" &&
        key !== "worldMap"
      ) {
        deepMerge(target[key], source[key]);
      } else if (Array.isArray(source[key])) {
        target[key] = source[key].map((item) =>
          typeof item === "object" && item !== null
            ? deepMerge(Array.isArray(item) ? [] : {}, item)
            : item,
        );
      } else {
        target[key] = source[key];
      }
    }
  }
  return target;
}

function gridToScreen(gridX, gridY) {
  const isoX = ((gridX - gridY) * TILE_WIDTH_ISO) / 2;
  const isoY = ((gridX + gridY) * TILE_HEIGHT_ISO) / 2;
  return {
    x: DOMElements.gameCanvas.width / 2 + isoX - camera.x,
    y: DOMElements.gameCanvas.height / 2 + isoY - camera.y,
  };
}

function screenToGrid(screenX, screenY) {
  const adjScreenX = screenX - DOMElements.gameCanvas.width / 2 + camera.x;
  const adjScreenY = screenY - DOMElements.gameCanvas.height / 2 + camera.y;

  const gridX = Math.round(
    (adjScreenX / (TILE_WIDTH_ISO / 2) + adjScreenY / (TILE_HEIGHT_ISO / 2)) /
      2,
  );
  const gridY = Math.round(
    (adjScreenY / (TILE_HEIGHT_ISO / 2) - adjScreenX / (TILE_WIDTH_ISO / 2)) /
      2,
  );
  return { x: gridX, y: gridY };
}

function resizeCanvas() {
  const c = DOMElements.gameCanvas.parentElement;
  DOMElements.gameCanvas.width = c.clientWidth;
  DOMElements.gameCanvas.height = c.clientHeight;
  DOMElements.minimapCanvas.width = DOMElements.minimapContainer.clientWidth;
  DOMElements.minimapCanvas.height = DOMElements.minimapContainer.clientHeight;
  renderGameView();
}

function renderGameView() {
  if (!ctx) return;
  ctx.clearRect(
    0,
    0,
    DOMElements.gameCanvas.width,
    DOMElements.gameCanvas.height,
  );
  drawMainCanvasBackground(gameState.age);
  drawMapGrid();
  drawBuildingsOnMap();
  drawWorldOutposts();
  drawPlacementPreview();
  drawMapEntities();
  drawDeployedArmiesOnMap();
  drawMinimap();
}

function drawMainCanvasBackground(age) {
  const width = DOMElements.gameCanvas.width;
  const height = DOMElements.gameCanvas.height;
  let skyColor1, skyColor2, horizonDrawer;

  const ageStyles = [
    { sky1: "#6DD5FA", sky2: "#2980B9", horizon: drawForestHorizon },
    { sky1: "#f5cba7", sky2: "#f9e79f", horizon: drawAncientHorizon },
    { sky1: "#85929e", sky2: "#aeb6bf", horizon: drawMedievalHorizon },
    { sky1: "#fad7a0", sky2: "#fdebd0", horizon: drawRenaissanceHorizon },
    { sky1: "#4a4e69", sky2: "#7d8ba9", horizon: drawIndustrialHorizon },
    { sky1: "#9db4c0", sky2: "#c5d8e0", horizon: drawModernHorizon },
    { sky1: "#141e30", sky2: "#243b55", horizon: drawFutureHorizon },
  ];

  const currentStyle = ageStyles[Math.min(age, ageStyles.length - 1)];
  skyColor1 = currentStyle.sky1;
  skyColor2 = currentStyle.sky2;
  horizonDrawer = currentStyle.horizon;

  const skyGradient = ctx.createLinearGradient(0, 0, 0, height * 0.65);
  skyGradient.addColorStop(0, skyColor1);
  skyGradient.addColorStop(1, skyColor2);
  ctx.fillStyle = skyGradient;
  ctx.fillRect(0, 0, width, height);

  if (horizonDrawer) {
    horizonDrawer(height * 0.6, width);
  }

  if (age >= 4) {
    ctx.save();
    for (let i = 0; i < (age > 5 ? 150 : 70); i++) {
      const x = Math.random() * width;
      const y = Math.random() * height * 0.55;
      const size = Math.random() * (age > 5 ? 2 : 1.5) + 0.5;
      ctx.fillStyle =
        age > 5
          ? `hsla(${Math.random() * 60 + 200}, 100%, ${Math.random() * 30 + 70}%, ${Math.random() * 0.8 + 0.3})`
          : `rgba(255, 255, 240, ${Math.random() * 0.6 + 0.2})`;
      ctx.beginPath();
      ctx.arc(x, y, size, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.restore();
  }
  ctx.fillStyle =
    age === 0 || age === 1 || (age >= 5 && age % 2 !== 0)
      ? "rgba(255, 245, 200, 0.95)"
      : "rgba(235, 235, 255, 0.85)";
  ctx.beginPath();
  ctx.arc(
    width *
      (0.15 +
        (((gameState.stats.timePlayed / 60) % (width * 0.7)) / (width * 0.7)) *
          0.7),
    height * 0.15,
    Math.min(width, height) * 0.035,
    0,
    Math.PI * 2,
  );
  ctx.fill();
}

function drawForestHorizon(horizonY, canvasWidth) {
  const treeColors = ["#1E4D2B", "#2A6F48", "#3B8C58", "#2E573C"];
  ctx.fillStyle = "#4A3B31";
  ctx.fillRect(
    0,
    horizonY,
    canvasWidth,
    DOMElements.gameCanvas.height - horizonY,
  );

  function drawTree(x, y, height, width, color) {
    ctx.fillStyle = color;
    ctx.fillRect(x - width / 2, y - height * 0.3, width, height * 0.3);
    ctx.beginPath();
    ctx.ellipse(
      x,
      y - height * 0.3,
      width * 1.2,
      height * 0.7,
      0,
      0,
      Math.PI * 2,
    );
    ctx.fill();
  }
  for (let layer = 0; layer < 3; layer++) {
    const numTrees = 20 - layer * 5;
    const treeMaxHeight = 80 - layer * 20;
    const treeMaxWidth = 15 - layer * 3;
    const yOffset = layer * 15;
    for (let i = 0; i < numTrees; i++) {
      const x = Math.random() * canvasWidth;
      const h = Math.random() * (treeMaxHeight * 0.5) + treeMaxHeight * 0.5;
      const w = Math.random() * (treeMaxWidth * 0.5) + treeMaxWidth * 0.5;
      drawTree(
        x,
        horizonY + yOffset - h / 2,
        h,
        w,
        treeColors[layer % treeColors.length],
      );
    }
  }
}
function drawAncientHorizon(horizonY, canvasWidth) {
  drawDesertDunes(horizonY, "#D2B48C", canvasWidth);
  drawPyramidsSimple(horizonY, "#B8860B", canvasWidth);
}
function drawMedievalHorizon(horizonY, canvasWidth) {
  drawMountains(horizonY, "#4A3B50", canvasWidth, 0.2, 0.08);
  drawSimpleCastleSilhouettes(horizonY, "#3E3248", canvasWidth);
}
function drawRenaissanceHorizon(horizonY, canvasWidth) {
  drawRollingHills(horizonY, "#8FBC8F", canvasWidth);
  drawSimpleTownSilhouettes(horizonY, "#556B2F", canvasWidth);
}
function drawIndustrialHorizon(horizonY, canvasWidth) {
  drawFlatCityScape(horizonY, "#3E4A52", canvasWidth);
  drawSmokeStacks(horizonY, "#2C373D", canvasWidth);
}
function drawModernHorizon(horizonY, canvasWidth) {
  drawModernSkyline(horizonY, "#52606E", canvasWidth);
}
function drawFutureHorizon(horizonY, canvasWidth) {
  drawFuturisticDomes(horizonY, "#3A7CA5", canvasWidth);
  drawFloatingStructures(horizonY, "#5E90AE", canvasWidth);
}

function drawMountains(
  horizonY,
  color,
  canvasWidth,
  maxHeightFactor,
  minHeightFactor,
) {
  ctx.fillStyle = color;
  ctx.beginPath();
  ctx.moveTo(0, horizonY);
  let x = 0;
  while (x < canvasWidth) {
    const h =
      Math.random() * (DOMElements.gameCanvas.height * maxHeightFactor) +
      DOMElements.gameCanvas.height * minHeightFactor;
    const peakX = x + Math.random() * (canvasWidth * 0.15) + canvasWidth * 0.05;
    ctx.lineTo(peakX, horizonY - h);
    x = peakX + Math.random() * (canvasWidth * 0.05);
    ctx.lineTo(Math.min(canvasWidth, x), horizonY);
  }
  ctx.lineTo(canvasWidth, DOMElements.gameCanvas.height);
  ctx.lineTo(0, DOMElements.gameCanvas.height);
  ctx.closePath();
  ctx.fill();
}
function drawDesertDunes(horizonY, color, canvasWidth) {
  ctx.fillStyle = color;
  ctx.beginPath();
  ctx.moveTo(0, horizonY);
  for (let x = 0; x < canvasWidth; x += 50) {
    ctx.quadraticCurveTo(
      x + 25,
      horizonY - (Math.random() * 30 + 10),
      x + 50,
      horizonY,
    );
  }
  ctx.lineTo(canvasWidth, DOMElements.gameCanvas.height);
  ctx.lineTo(0, DOMElements.gameCanvas.height);
  ctx.closePath();
  ctx.fill();
}
function drawPyramidsSimple(horizonY, color, canvasWidth) {
  ctx.fillStyle = color;
  ctx.beginPath();
  ctx.moveTo(canvasWidth * 0.3, horizonY);
  ctx.lineTo(canvasWidth * 0.4, horizonY - 80);
  ctx.lineTo(canvasWidth * 0.5, horizonY);
  ctx.closePath();
  ctx.fill();
  ctx.beginPath();
  ctx.moveTo(canvasWidth * 0.6, horizonY);
  ctx.lineTo(canvasWidth * 0.65, horizonY - 50);
  ctx.lineTo(canvasWidth * 0.7, horizonY);
  ctx.closePath();
  ctx.fill();
}
function drawSimpleCastleSilhouettes(horizonY, color, canvasWidth) {
  ctx.fillStyle = color;
  ctx.fillRect(canvasWidth * 0.2, horizonY - 60, 40, 60);
  ctx.fillRect(canvasWidth * 0.2 + 10, horizonY - 80, 20, 20);
  ctx.fillRect(canvasWidth * 0.7, horizonY - 80, 60, 80);
  ctx.fillRect(canvasWidth * 0.7 + 5, horizonY - 100, 15, 20);
  ctx.fillRect(canvasWidth * 0.7 + 40, horizonY - 100, 15, 20);
}
function drawRollingHills(horizonY, color, canvasWidth) {
  ctx.fillStyle = color;
  ctx.beginPath();
  ctx.moveTo(0, horizonY);
  for (let x = 0; x < canvasWidth; x += 100) {
    ctx.quadraticCurveTo(
      x + 50,
      horizonY - (Math.random() * 40 + 20),
      x + 100,
      horizonY - Math.random() * 10,
    );
  }
  ctx.lineTo(canvasWidth, DOMElements.gameCanvas.height);
  ctx.lineTo(0, DOMElements.gameCanvas.height);
  ctx.closePath();
  ctx.fill();
}
function drawSimpleTownSilhouettes(horizonY, color, canvasWidth) {
  ctx.fillStyle = color;
  for (let i = 0; i < 10; i++) {
    let x = Math.random() * canvasWidth * 0.8 + canvasWidth * 0.1;
    let h = Math.random() * 30 + 20;
    let w = Math.random() * 20 + 15;
    ctx.fillRect(x, horizonY - h, w, h);
    if (Math.random() > 0.5) {
      ctx.beginPath();
      ctx.moveTo(x, horizonY - h);
      ctx.lineTo(x + w / 2, horizonY - h - 10);
      ctx.lineTo(x + w, horizonY - h);
      ctx.closePath();
      ctx.fill();
    }
  }
}
function drawFlatCityScape(horizonY, color, canvasWidth) {
  ctx.fillStyle = color;
  ctx.fillRect(0, horizonY - 20, canvasWidth, 20);
}
function drawSmokeStacks(horizonY, color, canvasWidth) {
  ctx.fillStyle = color;
  for (let i = 0; i < 5; i++) {
    const x = Math.random() * canvasWidth;
    const h = Math.random() * 40 + 30;
    ctx.fillRect(x, horizonY - h, 10, h);
    ctx.beginPath();
    ctx.ellipse(x + 5, horizonY - h - 10, 8, 3, 0, 0, Math.PI * 2);
    ctx.fillStyle = lightenColor(color, 20);
    ctx.fill();
  }
}
function drawModernSkyline(horizonY, color, canvasWidth) {
  ctx.fillStyle = color;
  for (let i = 0; i < 15; i++) {
    const x = Math.random() * canvasWidth;
    const h = Math.random() * 80 + 40;
    const w = Math.random() * 30 + 10;
    ctx.fillRect(x, horizonY - h, w, h);
  }
}
function drawFuturisticDomes(horizonY, color, canvasWidth) {
  ctx.fillStyle = color;
  for (let i = 0; i < 3; i++) {
    const x = canvasWidth * (0.2 + i * 0.3) + (Math.random() - 0.5) * 50;
    const r = Math.random() * 50 + 30;
    ctx.beginPath();
    ctx.arc(x, horizonY, r, Math.PI, 0);
    ctx.fill();
  }
}
function drawFloatingStructures(horizonY, color, canvasWidth) {
  ctx.fillStyle = color;
  for (let i = 0; i < 4; i++) {
    const x = Math.random() * canvasWidth;
    const yOff = Math.random() * 30 + 20;
    const w = Math.random() * 40 + 20;
    const h = Math.random() * 20 + 10;
    ctx.fillRect(x, horizonY - h - yOff, w, h);
  }
}

function drawMapGrid() {
  const gridLineColor = getComputedStyle(document.documentElement)
    .getPropertyValue("--map-grid-line-color")
    .trim();
  const mapTileColor = getComputedStyle(document.documentElement)
    .getPropertyValue("--map-tile-color")
    .trim();
  const mapTileBorder = getComputedStyle(document.documentElement)
    .getPropertyValue("--map-tile-border")
    .trim();

  const viewBounds = {
    minGridX: screenToGrid(0, 0).x - 5,
    maxGridX:
      screenToGrid(DOMElements.gameCanvas.width, DOMElements.gameCanvas.height)
        .x + 5,
    minGridY: screenToGrid(DOMElements.gameCanvas.width, 0).y - 5,
    maxGridY: screenToGrid(0, DOMElements.gameCanvas.height).y + 5,
  };

  const sortedTiles = [];
  const minX = Math.max(gameState.map.ownedTilesX[0], viewBounds.minGridX - 10); // expand render slightly for undiscovered edges
  const maxX = Math.min(gameState.map.ownedTilesX[1], viewBounds.maxGridX + 10);
  const minY = Math.max(gameState.map.ownedTilesY[0], viewBounds.minGridY - 10);
  const maxY = Math.min(gameState.map.ownedTilesY[1], viewBounds.maxGridY + 10);

  for (let gy = minY; gy <= maxY; gy++) {
    for (let gx = minX; gx <= maxX; gx++) {
      if (
        !isTileOwned(gx, gy) &&
        !isTileDiscovered(gx, gy) &&
        !gameState.placement.isPlacing
      )
        continue; // only draw owned or discovered (unless placing)
      sortedTiles.push({ gx, gy });
    }
  }
  sortedTiles.sort((a, b) => a.gx + a.gy - (b.gx + b.gy) || a.gy - b.gy);

  sortedTiles.forEach((tile) => {
    const tileTopVertex = gridToScreen(tile.gx, tile.gy);
    ctx.beginPath();
    ctx.moveTo(tileTopVertex.x, tileTopVertex.y);
    ctx.lineTo(
      tileTopVertex.x + TILE_WIDTH_ISO / 2,
      tileTopVertex.y + TILE_HEIGHT_ISO / 2,
    );
    ctx.lineTo(tileTopVertex.x, tileTopVertex.y + TILE_HEIGHT_ISO);
    ctx.lineTo(
      tileTopVertex.x - TILE_WIDTH_ISO / 2,
      tileTopVertex.y + TILE_HEIGHT_ISO / 2,
    );
    ctx.closePath();

    if (isTileOwned(tile.gx, tile.gy)) {
      ctx.fillStyle = mapTileColor;
      ctx.fill();
      ctx.strokeStyle = mapTileBorder;
    } else if (isTileDiscovered(tile.gx, tile.gy)) {
      ctx.fillStyle = lightenColor(mapTileColor, -30); // Darker for discovered but not owned
      ctx.fill();
      ctx.strokeStyle = darkenColor(mapTileBorder, 20);
    } else {
      return; // Should not happen with the loop condition
    }
    ctx.lineWidth = 1;
    ctx.stroke();

    if (gameState.placement.isPlacing && isTileOwned(tile.gx, tile.gy)) {
      ctx.strokeStyle = gridLineColor;
      ctx.lineWidth = 0.5;
      ctx.stroke();
    }
  });
}

function drawBuildingsOnMap() {
  const buildingsToDraw = [...gameState.buildings].sort(
    (a, b) => a.gridX + a.gridY - (b.gridX + b.gridY) || a.gridY - b.gridY,
  );

  buildingsToDraw.forEach((building) => {
    const buildingDef = BUILDINGS[building.type];
    if (!buildingDef) return;
    
    let isCurrentlyMovingThisBuilding = gameState.editMode.isMovingBuilding && gameState.editMode.originalMovingBuildingData && gameState.editMode.originalMovingBuildingData.id === building.id;

    if (!isTileDiscovered(building.gridX, building.gridY) &&
        !isTileDiscovered(building.gridX + building.sizeX - 1, building.gridY + building.sizeY - 1) &&
        !isCurrentlyMovingThisBuilding // Always draw if it's the one being moved
       ) return;


    const buildingAnchorTopVertex = gridToScreen(building.gridX, building.gridY);
    const buildingVisualHeight =
      TILE_HEIGHT_ISO * 0.5 +
      (Math.max(buildingDef.sizeX, buildingDef.sizeY) - 1) * TILE_HEIGHT_ISO * 0.2 +
      (buildingDef.sizeX + buildingDef.sizeY - 2) * TILE_HEIGHT_ISO * 0.1;

    const topSurfaceOriginX = buildingAnchorTopVertex.x;
    const topSurfaceOriginY = buildingAnchorTopVertex.y - buildingVisualHeight;

    ctx.fillStyle = buildingDef.color || "#555";
    
    if (isCurrentlyMovingThisBuilding) {
        ctx.globalAlpha = 0.3; // Semi-transparent for the original position while moving
    } else {
        ctx.globalAlpha = building.isConstructed ? 1 : 0.4 + (building.progress / building.totalTime) * 0.3;
    }


    ctx.beginPath();
    ctx.moveTo(topSurfaceOriginX, topSurfaceOriginY);
    ctx.lineTo(
      topSurfaceOriginX + (TILE_WIDTH_ISO / 2) * buildingDef.sizeX,
      topSurfaceOriginY + (TILE_HEIGHT_ISO / 2) * buildingDef.sizeX,
    );
    ctx.lineTo(
      topSurfaceOriginX +
        (TILE_WIDTH_ISO / 2) * (buildingDef.sizeX - buildingDef.sizeY),
      topSurfaceOriginY +
        (TILE_HEIGHT_ISO / 2) * (buildingDef.sizeX + buildingDef.sizeY),
    );
    ctx.lineTo(
      topSurfaceOriginX - (TILE_WIDTH_ISO / 2) * buildingDef.sizeY,
      topSurfaceOriginY + (TILE_HEIGHT_ISO / 2) * buildingDef.sizeY,
    );
    ctx.closePath();
    ctx.fill();
    ctx.strokeStyle = darkenColor(buildingDef.color, 20);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(topSurfaceOriginX, topSurfaceOriginY);
    ctx.lineTo(
      topSurfaceOriginX + (TILE_WIDTH_ISO / 2) * buildingDef.sizeX,
      topSurfaceOriginY + (TILE_HEIGHT_ISO / 2) * buildingDef.sizeX,
    );
    ctx.lineTo(
      topSurfaceOriginX + (TILE_WIDTH_ISO / 2) * buildingDef.sizeX,
      topSurfaceOriginY +
        (TILE_HEIGHT_ISO / 2) * buildingDef.sizeX +
        buildingVisualHeight,
    );
    ctx.lineTo(topSurfaceOriginX, topSurfaceOriginY + buildingVisualHeight);
    ctx.closePath();
    ctx.fillStyle = darkenColor(buildingDef.color, 10);
    ctx.fill();
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(
      topSurfaceOriginX - (TILE_WIDTH_ISO / 2) * buildingDef.sizeY,
      topSurfaceOriginY + (TILE_HEIGHT_ISO / 2) * buildingDef.sizeY,
    );
    ctx.lineTo(
      topSurfaceOriginX +
        (TILE_WIDTH_ISO / 2) * (buildingDef.sizeX - buildingDef.sizeY),
      topSurfaceOriginY +
        (TILE_HEIGHT_ISO / 2) * (buildingDef.sizeX + buildingDef.sizeY),
    );
    ctx.lineTo(
      topSurfaceOriginX +
        (TILE_WIDTH_ISO / 2) * (buildingDef.sizeX - buildingDef.sizeY),
      topSurfaceOriginY +
        (TILE_HEIGHT_ISO / 2) * (buildingDef.sizeX + buildingDef.sizeY) +
        buildingVisualHeight,
    );
    ctx.lineTo(
      topSurfaceOriginX - (TILE_WIDTH_ISO / 2) * buildingDef.sizeY,
      topSurfaceOriginY +
        (TILE_HEIGHT_ISO / 2) * buildingDef.sizeY +
        buildingVisualHeight,
    );
    ctx.closePath();
    ctx.fillStyle = lightenColor(buildingDef.color, 10);
    ctx.fill();
    ctx.stroke();
    
    if (gameState.editMode.isActive && gameState.editMode.selectedBuildingInstance && building.id === gameState.editMode.selectedBuildingInstance.id && !isCurrentlyMovingThisBuilding) {
        ctx.strokeStyle = "lime";
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(topSurfaceOriginX, topSurfaceOriginY);
        ctx.lineTo(topSurfaceOriginX + (TILE_WIDTH_ISO / 2) * buildingDef.sizeX, topSurfaceOriginY + (TILE_HEIGHT_ISO / 2) * buildingDef.sizeX);
        ctx.lineTo(topSurfaceOriginX + (TILE_WIDTH_ISO / 2) * (buildingDef.sizeX - buildingDef.sizeY), topSurfaceOriginY + (TILE_HEIGHT_ISO / 2) * (buildingDef.sizeX + buildingDef.sizeY));
        ctx.lineTo(topSurfaceOriginX - (TILE_WIDTH_ISO / 2) * buildingDef.sizeY, topSurfaceOriginY + (TILE_HEIGHT_ISO / 2) * buildingDef.sizeY);
        ctx.closePath();
        ctx.stroke();
        ctx.lineWidth = 1; 
    }


    ctx.globalAlpha = 1;
    const iconSize =
      TILE_HEIGHT_ISO *
      0.4 *
      Math.min(buildingDef.sizeX, buildingDef.sizeY, 1.8);
    ctx.font = `${iconSize}px Sans-serif`;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillStyle = "white";
    const topFaceCenterX =
      topSurfaceOriginX +
      (TILE_WIDTH_ISO / 4) * (buildingDef.sizeX - buildingDef.sizeY);
    const topFaceCenterY =
      topSurfaceOriginY +
      (TILE_HEIGHT_ISO / 4) * (buildingDef.sizeX + buildingDef.sizeY);
    ctx.fillText(buildingDef.icon, topFaceCenterX, topFaceCenterY);

    if (
      !building.isConstructed ||
      (building.isPlaceholder && building.progress < building.totalTime)
    ) {
      const progress = building.progress / building.totalTime;
      const barWidth =
        TILE_WIDTH_ISO * 0.4 * Math.max(buildingDef.sizeX, buildingDef.sizeY);
      const barHeight = 6;
      const barX = topFaceCenterX - barWidth / 2;
      const barY = topFaceCenterY + iconSize * 0.6;

      ctx.fillStyle = "#333";
      ctx.fillRect(barX, barY, barWidth, barHeight);
      ctx.fillStyle = getComputedStyle(document.documentElement)
        .getPropertyValue("--accent-color")
        .trim();
      ctx.fillRect(barX, barY, barWidth * progress, barHeight);
      ctx.strokeStyle = "#111";
      ctx.strokeRect(barX, barY, barWidth, barHeight);
    }
  });
}
function darkenColor(hex, percent) {
  hex = hex.replace(/^\s*#|\s*$/g, "");
  if (hex.length == 3) {
    hex = hex.replace(/(.)/g, "$1$1");
  }
  var r = parseInt(hex.substr(0, 2), 16),
    g = parseInt(hex.substr(2, 2), 16),
    b = parseInt(hex.substr(4, 2), 16);

  r = Math.max(0, Math.min(255, r - Math.floor((255 * percent) / 100)));
  g = Math.max(0, Math.min(255, g - Math.floor((255 * percent) / 100)));
  b = Math.max(0, Math.min(255, b - Math.floor((255 * percent) / 100)));

  return (
    "#" +
    r.toString(16).padStart(2, "0") +
    g.toString(16).padStart(2, "0") +
    b.toString(16).padStart(2, "0")
  );
}
function lightenColor(hex, percent) {
  return darkenColor(hex, -percent);
}

function drawPlacementPreview() {
  if (
    !gameState.placement.isPlacing ||
    !gameState.placement.buildingId ||
    mouseGridPos.x === -1
  )
    return;

  const buildingDef = BUILDINGS[gameState.placement.buildingId];
  if (!buildingDef) return;

  const finalPlaceX = mouseGridPos.x;
  const finalPlaceY = mouseGridPos.y;

  const placementCheckResult = canPlaceBuilding(buildingDef, finalPlaceX, finalPlaceY, true);
  const isValid = placementCheckResult.valid;
  gameState.placement.validPlacement = isValid;

  ctx.globalAlpha = 0.5;
  for (let y = 0; y < buildingDef.sizeY; y++) {
    for (let x = 0; x < buildingDef.sizeX; x++) {
      const currentTileX = finalPlaceX + x;
      const currentTileY = finalPlaceY + y;
      const tileTopVertex = gridToScreen(currentTileX, currentTileY);

      ctx.beginPath();
      ctx.moveTo(tileTopVertex.x, tileTopVertex.y);
      ctx.lineTo(
        tileTopVertex.x + TILE_WIDTH_ISO / 2,
        tileTopVertex.y + TILE_HEIGHT_ISO / 2,
      );
      ctx.lineTo(tileTopVertex.x, tileTopVertex.y + TILE_HEIGHT_ISO);
      ctx.lineTo(
        tileTopVertex.x - TILE_WIDTH_ISO / 2,
        tileTopVertex.y + TILE_HEIGHT_ISO / 2,
      );
      ctx.closePath();
      ctx.fillStyle = isValid
        ? getComputedStyle(document.documentElement)
            .getPropertyValue("--building-placeholder-valid")
            .trim()
        : getComputedStyle(document.documentElement)
            .getPropertyValue("--building-placeholder-invalid")
            .trim();
      ctx.fill();
    }
  }
  ctx.globalAlpha = 1;
}

function drawMapEntities() {
  const entitiesToDraw = [...gameState.mapEntities.raiders].sort(
    (a, b) => a.gridX + a.gridY - (b.gridX + b.gridY) || a.gridY - b.gy,
  );

  entitiesToDraw.forEach((raider) => {
    if (!isTileDiscovered(Math.round(raider.gridX), Math.round(raider.gridY)))
      return;

    const screenPos = gridToScreen(raider.gridX, raider.gridY);
    ctx.font = `${TILE_HEIGHT_ISO * 0.6}px Arial`;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";

    const raidInfo = gameState.activeRaids.find((r) => r.id === raider.raidId);
    if (raidInfo) {
      ctx.fillStyle = getComputedStyle(document.documentElement)
        .getPropertyValue("--error-color")
        .trim();
      ctx.globalAlpha = 0.7;
      ctx.beginPath();
      ctx.ellipse(
        screenPos.x,
        screenPos.y + TILE_HEIGHT_ISO * 0.4,
        TILE_WIDTH_ISO * 0.2,
        TILE_HEIGHT_ISO * 0.15,
        0,
        0,
        Math.PI * 2,
      );
      ctx.fill();
      ctx.globalAlpha = 1;

      ctx.fillStyle = "white";
      ctx.fillText(raider.icon, screenPos.x, screenPos.y);

      if (raider.state === "engaging_building" && raider.targetBuildingId) {
        ctx.strokeStyle = "rgba(231, 76, 60, 0.7)";
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(screenPos.x, screenPos.y);
        const targetBuilding = gameState.buildings.find(
          (b) => b.id === raider.targetBuildingId,
        );
        if (targetBuilding) {
          const buildingDef = BUILDINGS[targetBuilding.type];
          const targetAnchorTopVertex = gridToScreen(
            targetBuilding.gridX,
            targetBuilding.gridY,
          );
          const targetVisualHeight =
            TILE_HEIGHT_ISO * 0.5 +
            (Math.max(buildingDef.sizeX, buildingDef.sizeY) - 1) *
              TILE_HEIGHT_ISO *
              0.2 +
            (buildingDef.sizeX + buildingDef.sizeY - 2) * TILE_HEIGHT_ISO * 0.1;
          const targetTopFaceOriginY =
            targetAnchorTopVertex.y - targetVisualHeight;
          const targetTopFaceCenterX =
            targetAnchorTopVertex.x +
            (TILE_WIDTH_ISO / 4) * (buildingDef.sizeX - buildingDef.sizeY);
          const targetTopFaceCenterY =
            targetTopFaceOriginY +
            (TILE_HEIGHT_ISO / 4) * (buildingDef.sizeX + buildingDef.sizeY);

          ctx.lineTo(targetTopFaceCenterX, targetTopFaceCenterY);
          ctx.stroke();

          ctx.fillStyle = "rgba(255,0,0,0.2)";
          ctx.beginPath();
          ctx.arc(
            screenPos.x,
            screenPos.y,
            15 + Math.sin(gameState.stats.timePlayed * 5) * 3,
            0,
            Math.PI * 2,
          );
          ctx.fill();
        }
      }
    }
  });
}

function handleCanvasMouseMove(event) {
  const rect = DOMElements.gameCanvas.getBoundingClientRect();
  const mouseX = event.clientX - rect.left;
  const mouseY = event.clientY - rect.top;

  if (isPanning) {
    camera.x -= mouseX - panStartX;
    camera.y -= mouseY - panStartY;
    panStartX = mouseX;
    panStartY = mouseY;
    renderGameView();
    return;
  }

  if (gameState.placement.isPlacing) {
    mouseGridPos = screenToGrid(mouseX, mouseY);
    renderGameView();
  }
}

function handleCanvasClick(event) {
  const rect = DOMElements.gameCanvas.getBoundingClientRect();
  const clickX = event.clientX - rect.left;
  const clickY = event.clientY - rect.top;
  const clickedGridPos = screenToGrid(clickX, clickY);

  if (gameState.editMode.isActive && !gameState.editMode.isMovingBuilding && !gameState.placement.isPlacing) {
    const clickedBuilding = getBuildingAtGrid(clickedGridPos.x, clickedGridPos.y);
    if (clickedBuilding && clickedBuilding.isConstructed) {
        const screenPos = gridToScreen(clickedBuilding.gridX, clickedBuilding.gridY);
        showEditModeActionsPopup(clickedBuilding, screenPos);
    } else {
        hideEditModeActionsPopup();
    }
    renderGameView();
  } else if (gameState.placement.isPlacing && gameState.placement.buildingId) {
    attemptPlaceBuilding(clickedGridPos.x, clickedGridPos.y, event.shiftKey);
  } else {
    const clickedOutpost = gameState.worldMap.outposts.find(
      (outpost) =>
        !outpost.isDefeated &&
        outpost.isDiscovered &&
        clickedGridPos.x >= outpost.gridX &&
        clickedGridPos.x < outpost.gridX + 1 &&
        clickedGridPos.y >= outpost.gridY &&
        clickedGridPos.y < outpost.gridY + 1,
    );
    if (clickedOutpost) {
      openWorldMapOutpostInteractionModal(clickedOutpost);
      return;
    }
    hideEditModeActionsPopup(); // Hide if clicking empty space when not in edit mode selection phase
  }
}






function toggleBuildingEditMode() {
    if (gameState.activeRaids.length > 0 && !gameState.editMode.isActive) {
        showNotification("Cannot enter edit mode during a raid!", "error");
        return;
    }

    gameState.editMode.isActive = !gameState.editMode.isActive;

    if (gameState.editMode.isActive) {
        DOMElements.editBuildingsButton.textContent = "Exit Edit Mode";
        DOMElements.editBuildingsButton.style.backgroundColor = "var(--accent-color)";
        DOMElements.gameCanvasContainer.style.cursor = "cell"; // Or 'context-menu'
        showNotification("Building Edit Mode ACTIVE. Click a building to select.", "info");
        cancelPlacementMode(); // Exit any active placement mode
        hideEditModeActionsPopup();
    } else {
        DOMElements.editBuildingsButton.textContent = "Edit Buildings";
        DOMElements.editBuildingsButton.style.backgroundColor = "var(--button-color)";
        DOMElements.gameCanvasContainer.style.cursor = "grab";
        gameState.editMode.selectedBuildingInstance = null;
        gameState.editMode.isMovingBuilding = false;
        gameState.editMode.originalMovingBuildingData = null;
        hideEditModeActionsPopup();
        cancelPlacementMode(); // Ensure placement mode (for moving) is also cancelled
    }
    renderGameView();
}

function showEditModeActionsPopup(building, screenPos) {
    gameState.editMode.selectedBuildingInstance = building;
    const buildingDef = BUILDINGS[building.type];
    DOMElements.selectedBuildingInfoEdit.textContent = `${buildingDef.icon} ${buildingDef.name}`;
    
    const popup = DOMElements.editModeActionsContent;
    popup.style.display = "flex";
    
    const canvasRect = DOMElements.gameCanvas.getBoundingClientRect();
    let popupX = screenPos.x - canvasRect.left + TILE_WIDTH_ISO /2;
    let popupY = screenPos.y - canvasRect.top - TILE_HEIGHT_ISO /2 ;

    popupX = Math.max(0, Math.min(popupX, canvasRect.width - popup.offsetWidth));
    popupY = Math.max(0, Math.min(popupY, canvasRect.height - popup.offsetHeight));

    popup.style.left = `${popupX}px`;
    popup.style.top = `${popupY}px`;

    DOMElements.editModeActionsOverlay.classList.add("visible");
}

function hideEditModeActionsPopup() {
    DOMElements.editModeActionsContent.style.display = "none";
    DOMElements.editModeActionsOverlay.classList.remove("visible");
    gameState.editMode.selectedBuildingInstance = null; 
}

function startMoveSelectedBuilding() {
    if (!gameState.editMode.isActive || !gameState.editMode.selectedBuildingInstance) return;

    const buildingToMove = gameState.editMode.selectedBuildingInstance;
    const buildingDef = BUILDINGS[buildingToMove.type];

    gameState.editMode.isMovingBuilding = true;
    gameState.editMode.originalMovingBuildingData = { ...buildingToMove }; // Store a copy

    gameState.placement.isPlacing = true;
    gameState.placement.buildingId = buildingToMove.type; 
    
    hideEditModeActionsPopup();
    DOMElements.gameCanvasContainer.style.cursor = "copy";
    DOMElements.cancelPlacementButton.textContent = "Cancel Move";
    DOMElements.cancelPlacementButton.style.display = "flex";
    showNotification(`Moving ${buildingDef.name}. Click new location or Cancel.`, "info");
    renderGameView(); 
}

function deleteSelectedBuilding() {
    if (!gameState.editMode.isActive || !gameState.editMode.selectedBuildingInstance) return;

    const buildingToDelete = gameState.editMode.selectedBuildingInstance;
    const buildingDef = BUILDINGS[buildingToDelete.type];

    if (confirm(`Are you sure you want to delete ${buildingDef.name}? You'll get 50% of its base cost back.`)) {
        const refundAmount = Math.floor(buildingDef.baseCost * 0.5); 
        gameState.resources.gold += refundAmount;
        applyEffects(buildingDef, true); 

        gameState.buildings = gameState.buildings.filter(b => b.id !== buildingToDelete.id);
        
        addMessage(`${buildingDef.name} deleted. +${formatNumber(refundAmount)}G refunded.`, "info");
        showNotification("Building deleted.", "success");

        hideEditModeActionsPopup();
        gameState.editMode.selectedBuildingInstance = null;
        updateAllUIDisplays();
        renderGameView();
    }
}

















function mainGameLoop() {
  const deltaTime = 1;
  const currentTime = gameState.stats.timePlayed;
  gameState.stats.timePlayed += deltaTime;
  gameState.resources.gold += getCalculatedIncome() * deltaTime;
  gameState.resources.technologyPoints += getCalculatedTechRate() * deltaTime;
  if (gameState.currentResearch.id) {
    gameState.currentResearch.progress += deltaTime;
    if (
      gameState.currentResearch.progress >=
      gameState.currentResearch.timeToComplete
    )
      completeResearch();
  }
  processTrainingQueue(deltaTime);
  processConstructionQueue(deltaTime);
  if (currentTime >= nextRaidCheckTime) {
    checkForNewRaid(currentTime);
    nextRaidCheckTime = currentTime + RAID_CHECK_INTERVAL / 1000;
  }
  processActiveRaids(currentTime);
  processDeployedArmies(deltaTime);
  if (!gameState.battle.isActive) {
    updateAllUIDisplays();
    renderGameView();
  } else {
    updateResourceDisplays();
    updateRaidAlertUI();
    renderBattleUI();
  }
  if (gameState.stats.timePlayed > 0 && gameState.stats.timePlayed % 90 === 0) {
    saveGame(true);
    addMessage("Game autosaved.", false);
  }
}















function initEventListeners() {
  window.addEventListener("resize", resizeCanvas);
  DOMElements.gameCanvas.addEventListener("mousemove", handleCanvasMouseMove);
  DOMElements.gameCanvas.addEventListener("click", handleCanvasClick);
  DOMElements.gameCanvas.addEventListener("mousedown", (e) => {
    if (e.button === 0 && !gameState.placement.isPlacing && !gameState.editMode.isActive) { // Modified to not pan if in edit mode
      isPanning = true;
      DOMElements.gameCanvasContainer.classList.add("grabbing");
      panStartX =
        e.clientX - DOMElements.gameCanvas.getBoundingClientRect().left;
      panStartY =
        e.clientY - DOMElements.gameCanvas.getBoundingClientRect().top;
    }
  });
  window.addEventListener("mouseup", (e) => {
    if (e.button === 0) {
      isPanning = false;
      DOMElements.gameCanvasContainer.classList.remove("grabbing");
    }
  });
  DOMElements.gameCanvas.addEventListener("mouseleave", () => {
    isPanning = false;
    DOMElements.gameCanvasContainer.classList.remove("grabbing");
     if (gameState.editMode.isMovingBuilding) { // If moving building and mouse leaves, cancel move for safety
        // This part of cancelPlacementMode needs to be specific for move cancellation
        const originalData = gameState.editMode.originalMovingBuildingData;
        showNotification("Building move cancelled (mouse left canvas).", "info");
        gameState.editMode.isMovingBuilding = false;
        gameState.editMode.originalMovingBuildingData = null;
        gameState.editMode.selectedBuildingInstance = gameState.buildings.find(b => b.id === originalData?.id) || null;

        if (gameState.editMode.selectedBuildingInstance && gameState.editMode.isActive) {
            const screenPos = gridToScreen(gameState.editMode.selectedBuildingInstance.gridX, gameState.editMode.selectedBuildingInstance.gridY);
            showEditModeActionsPopup(gameState.editMode.selectedBuildingInstance, screenPos);
            DOMElements.gameCanvasContainer.style.cursor = "cell";
        } else if(gameState.editMode.isActive) {
            DOMElements.gameCanvasContainer.style.cursor = "cell";
            hideEditModeActionsPopup();
        } else {
            DOMElements.gameCanvasContainer.style.cursor = "grab";
        }
        gameState.placement.isPlacing = false;
        gameState.placement.buildingId = null;
        DOMElements.cancelPlacementButton.textContent = "Cancel Placement Mode";
        DOMElements.cancelPlacementButton.style.display = "none";
        updateAllUIDisplays();
        renderGameView();
    }
  });
  DOMElements.backToBaseButton.addEventListener("click", () => {
    camera.x = 0;
    camera.y = -(DOMElements.gameCanvas.height / 3);
    renderGameView();
    DOMElements.backToBaseButton.style.display = "none";
  });

  DOMElements.cancelPlacementButton.addEventListener(
    "click",
    cancelPlacementMode, 
  );
  DOMElements.expandLandNorthButton.addEventListener("click", () =>
    expandMap("N"),
  );
  DOMElements.expandLandSouthButton.addEventListener("click", () =>
    expandMap("S"),
  );
  DOMElements.expandLandWestButton.addEventListener("click", () =>
    expandMap("W"),
  );
  DOMElements.expandLandEastButton.addEventListener("click", () =>
    expandMap("E"),
  );
  DOMElements.saveButton.addEventListener("click", () => saveGame(false));
  DOMElements.loadButton.addEventListener("click", loadGame);
  DOMElements.tutorialButton.addEventListener("click", () =>
    showTutorial(true),
  );
  DOMElements.tutorialForceCloseButton.addEventListener("click", closeTutorial);
  DOMElements.tutorialPrevButton.addEventListener(
    "click",
    previousTutorialStep,
  );
  DOMElements.tutorialNextButton.addEventListener("click", nextTutorialStep);
  DOMElements.tutorialCloseButton.addEventListener("click", closeTutorial);
  DOMElements.achievementsButton.addEventListener(
    "click",
    showAchievementsScreen,
  );
  DOMElements.advanceAgeButton.addEventListener("click", advanceAge);
  DOMElements.battleButton.addEventListener("click", findEnemies);
  DOMElements.upgradePanelCloseButton.addEventListener("click", () =>
    hideModal(DOMElements.upgradePanelOverlay),
  );
  DOMElements.genericOverlayCloseButton.addEventListener("click", () =>
    hideModal(DOMElements.genericOverlay),
  );
  DOMElements.worldMapOutpostModalCloseButton.addEventListener("click", () =>
    hideModal(DOMElements.worldMapOutpostInteractionModal),
  );
  DOMElements.battleModalCloseButton.addEventListener("click", () => {
    if (gameState.battle.isActive) {
      addBattleLogEntry("Battle manually closed - Conceded.");
      endBattle(false);
    }
    hideModal(DOMElements.battleModalOverlay);
  });
  DOMElements.tabButtons.forEach((tab) => {
    tab.addEventListener("click", () => {
      DOMElements.tabButtons.forEach((t) => t.classList.remove("active"));
      DOMElements.tabContents.forEach((c) => c.classList.remove("active"));
      tab.classList.add("active");
      document
        .getElementById(`${tab.dataset.tab}-tab-content`)
        .classList.add("active");
    });
  });
  document.body.addEventListener("mouseover", displayTooltip);
  setupBattleActionListeners();

  DOMElements.deployUnitSelectionModalCloseButton.addEventListener('click', () => {
      hideModal(DOMElements.deployUnitSelectionModal);
      currentDeploymentTargetOutpost = null; 
  });
  DOMElements.cancelDeploymentSelectionButton.addEventListener('click', () => {
      hideModal(DOMElements.deployUnitSelectionModal);
      currentDeploymentTargetOutpost = null; 
  });
  DOMElements.confirmDeploymentButton.addEventListener('click', handleConfirmDeployment);
  DOMElements.resignButton.addEventListener('click', handleResignGame); 
  
  DOMElements.editBuildingsButton.addEventListener('click', toggleBuildingEditMode);
  DOMElements.moveBuildingButtonEdit.addEventListener('click', startMoveSelectedBuilding);
  DOMElements.deleteBuildingButtonEdit.addEventListener('click', deleteSelectedBuilding);
  DOMElements.cancelBuildingSelectionButtonEdit.addEventListener('click', () => {
      hideEditModeActionsPopup();
      gameState.editMode.selectedBuildingInstance = null;
      renderGameView();
  });

  document.addEventListener('keydown', (e) => {
    if (e.key === "Escape") {
        if (DOMElements.deployUnitSelectionModal.classList.contains("visible")) {
            hideModal(DOMElements.deployUnitSelectionModal);
            currentDeploymentTargetOutpost = null;
        } else if (DOMElements.editModeActionsOverlay.classList.contains("visible")) {
            hideEditModeActionsPopup();
            gameState.editMode.selectedBuildingInstance = null;
            renderGameView();
        } else if (gameState.placement.isPlacing || (gameState.editMode.isActive && gameState.editMode.isMovingBuilding)) {
            cancelPlacementMode();
        } else if (gameState.editMode.isActive) {
            toggleBuildingEditMode();
        } else if (DOMElements.genericOverlay.classList.contains("visible")) {
            hideModal(DOMElements.genericOverlay);
        } else if (DOMElements.tutorialOverlay.classList.contains("visible")) {
             // Decide if Esc should close tutorial or if explicit button is better
        } else if (DOMElements.battleModalOverlay.classList.contains("visible")){
            // Potentially offer concede on Esc in battle or just ignore
        }
    }
  });
}




function initGame() {
  // Clear any existing intervals from a previous game instance (e.g., after resignation)
  if (gameLoopIntervalId) clearInterval(gameLoopIntervalId);
  if (achievementCheckIntervalId) clearInterval(achievementCheckIntervalId);

  gameState = getDefaultGameState(); // This might be redundant if called after handleResignGame, but safe
  ctx = DOMElements.gameCanvas.getContext("2d");
  minimapCtx = DOMElements.minimapCanvas.getContext("2d");
  initEventListeners(); // Make sure this doesn't re-add listeners if called multiple times without cleanup
  resizeCanvas();
  camera.x = 0;
  camera.y = -(DOMElements.gameCanvas.height / 3);
  discoverArea(BASE_LOCATION_GRID.x, BASE_LOCATION_GRID.y, 20); // Increased discovery for initial outposts
  generateWorldOutpostsIfNeeded();
  loadAvailableBuildings();
  loadAvailableUnits();
  loadAvailableTechnologies();
  updateAllUIDisplays();
  renderGameView();
  nextRaidCheckTime = gameState.stats.timePlayed + RAID_CHECK_INTERVAL / 1000;
  if (!localStorage.getItem(SAVE_GAME_KEY) && !gameState.tutorial.complete) { // Check tutorial complete flag
    showTutorial();
  } else if (localStorage.getItem(SAVE_GAME_KEY)) {
    loadGame(); // loadGame also calls initGame if save is corrupted, potentially creating loop if not careful
  }
  gameLoopIntervalId = setInterval(mainGameLoop, 1000);
  achievementCheckIntervalId = setInterval(checkAchievements, 5000);
  
  // Ensure this message only appears once per true game start, not after resignation's re-init
  if (gameState.stats.timePlayed < 2) { // Check if it's truly a new game or early after resignation
      addMessage(
        `Welcome to Age of Empire Tycoon ${gameState.gameVersion}! Forge your destiny.`,
        true,
      );
  }
}
document.addEventListener("DOMContentLoaded", initGame);

function drawWorldOutposts() {
  gameState.worldMap.outposts.forEach((outpost) => {
    if (!outpost.isDiscovered || outpost.isDefeated) return;

    const screenPos = gridToScreen(outpost.gridX, outpost.gridY);
    ctx.font = `${TILE_HEIGHT_ISO * 0.7}px Arial`;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";

    ctx.fillStyle = "rgba(100, 20, 20, 0.7)";
    ctx.beginPath();
    ctx.ellipse(
      screenPos.x,
      screenPos.y + TILE_HEIGHT_ISO * 0.4,
      TILE_WIDTH_ISO * 0.3,
      TILE_HEIGHT_ISO * 0.2,
      0,
      0,
      Math.PI * 2,
    );
    ctx.fill();

    ctx.fillStyle = outpost.isDefeated ? "#555" : "#e74c3c";
    ctx.fillText(outpost.icon || "📍", screenPos.x, screenPos.y);

    if (outpost.name && isTileDiscovered(outpost.gridX, outpost.gridY)) {
      const distanceToPlayerBase = Math.sqrt(
        Math.pow(outpost.gridX - BASE_LOCATION_GRID.x, 2) +
          Math.pow(outpost.gridY - BASE_LOCATION_GRID.y, 2),
      );
      ctx.font = "10px Arial";
      ctx.fillStyle = "white";
      if (distanceToPlayerBase < 15) {
        // Show strength if close
        ctx.fillText(
          `${outpost.name} (Str: ${formatNumber(outpost.strength)})`,
          screenPos.x,
          screenPos.y - TILE_HEIGHT_ISO * 0.7,
        );
      } else {
        ctx.fillText(
          `${outpost.name} (Unknown Strength)`,
          screenPos.x,
          screenPos.y - TILE_HEIGHT_ISO * 0.7,
        );
      }
    }
  });
}

function drawMinimap() {
  if (!minimapCtx) return;
  const mapWidth = DOMElements.minimapCanvas.width;
  const mapHeight = DOMElements.minimapCanvas.height;

  minimapCtx.clearRect(0, 0, mapWidth, mapHeight);
  minimapCtx.fillStyle = "rgba(10,20,30,0.8)";
  minimapCtx.fillRect(0, 0, mapWidth, mapHeight);

  const mapCenterX = mapWidth / 2;
  const mapCenterY = mapHeight / 2;

  const mainViewCenterGrid = screenToGrid(DOMElements.gameCanvas.width / 2, DOMElements.gameCanvas.height / 2);
  const minimapViewRefX = mainViewCenterGrid.x;
  const minimapViewRefY = mainViewCenterGrid.y;

  Object.keys(gameState.map.discoveredTiles).forEach((key) => {
    const [gx, gy] = key.split(",").map(Number);
    const tileMiniX = mapCenterX + (gx - minimapViewRefX) * MINIMAP_PIXEL_PER_TILE;
    const tileMiniY = mapCenterY + (gy - minimapViewRefY) * MINIMAP_PIXEL_PER_TILE;

    if (
      tileMiniX < -MINIMAP_PIXEL_PER_TILE ||
      tileMiniX > mapWidth + MINIMAP_PIXEL_PER_TILE || 
      tileMiniY < -MINIMAP_PIXEL_PER_TILE ||
      tileMiniY > mapHeight + MINIMAP_PIXEL_PER_TILE
    )
      return;

    if (isTileOwned(gx, gy)) {
      minimapCtx.fillStyle = "rgba(46, 204, 113, 0.6)"; 
    } else {
      minimapCtx.fillStyle = "rgba(52, 73, 94, 0.4)"; 
    }
    minimapCtx.fillRect(
      tileMiniX,
      tileMiniY,
      MINIMAP_PIXEL_PER_TILE,
      MINIMAP_PIXEL_PER_TILE,
    );
  });

  gameState.buildings.forEach((building) => {
    if (building.isConstructed && isTileDiscovered(building.gridX, building.gridY)) {
        // For multi-tile buildings, we can represent them by their top-left corner
        // or try to draw a small block representing their size.
        // For simplicity, let's represent the main anchor point.
        const buildingMiniX = mapCenterX + (building.gridX - minimapViewRefX) * MINIMAP_PIXEL_PER_TILE;
        const buildingMiniY = mapCenterY + (building.gridY - minimapViewRefY) * MINIMAP_PIXEL_PER_TILE;

        if (
            buildingMiniX >= -MINIMAP_PIXEL_PER_TILE && buildingMiniX <= mapWidth &&
            buildingMiniY >= -MINIMAP_PIXEL_PER_TILE && buildingMiniY <= mapHeight
        ) {
            minimapCtx.fillStyle = "lime"; // Bright green for player buildings
            minimapCtx.fillRect(
                buildingMiniX, 
                buildingMiniY, 
                MINIMAP_PIXEL_PER_TILE * Math.max(1, building.sizeX / 2), // Approximate size
                MINIMAP_PIXEL_PER_TILE * Math.max(1, building.sizeY / 2)  // Approximate size
            );
        }
    }
  });

  gameState.worldMap.outposts.forEach((outpost) => {
    if (outpost.isDiscovered && !outpost.isDefeated) {
      const outpostMiniX = mapCenterX + (outpost.gridX - minimapViewRefX) * MINIMAP_PIXEL_PER_TILE;
      const outpostMiniY = mapCenterY + (outpost.gridY - minimapViewRefY) * MINIMAP_PIXEL_PER_TILE;
      if (
        outpostMiniX < -MINIMAP_PIXEL_PER_TILE * 2 ||
        outpostMiniX > mapWidth + MINIMAP_PIXEL_PER_TILE * 2 ||
        outpostMiniY < -MINIMAP_PIXEL_PER_TILE * 2 ||
        outpostMiniY > mapHeight + MINIMAP_PIXEL_PER_TILE * 2
      )
        return;
      minimapCtx.fillStyle = "red";
      minimapCtx.fillRect(
        outpostMiniX - 1,
        outpostMiniY - 1,
        MINIMAP_PIXEL_PER_TILE + 2,
        MINIMAP_PIXEL_PER_TILE + 2,
      );
    }
  });
  
  gameState.mapEntities.raiders.forEach((raider) => {
    if(isTileDiscovered(Math.round(raider.gridX), Math.round(raider.gridY))){
        const raiderMiniX = mapCenterX + (Math.round(raider.gridX) - minimapViewRefX) * MINIMAP_PIXEL_PER_TILE;
        const raiderMiniY = mapCenterY + (Math.round(raider.gridY) - minimapViewRefY) * MINIMAP_PIXEL_PER_TILE;
        if (
            raiderMiniX >= -MINIMAP_PIXEL_PER_TILE && raiderMiniX <= mapWidth &&
            raiderMiniY >= -MINIMAP_PIXEL_PER_TILE && raiderMiniY <= mapHeight
        ) {
            minimapCtx.fillStyle = "orange";
            minimapCtx.fillRect(raiderMiniX, raiderMiniY, MINIMAP_PIXEL_PER_TILE, MINIMAP_PIXEL_PER_TILE);
        }
    }
  });

  gameState.worldMap.deployedArmies.forEach((army) => {
      if (army.gridX !== undefined && army.gridY !== undefined && isTileDiscovered(Math.round(army.gridX), Math.round(army.gridY))) {
          const armyMiniX = mapCenterX + (Math.round(army.gridX) - minimapViewRefX) * MINIMAP_PIXEL_PER_TILE;
          const armyMiniY = mapCenterY + (Math.round(army.gridY) - minimapViewRefY) * MINIMAP_PIXEL_PER_TILE;
           if (
            armyMiniX >= -MINIMAP_PIXEL_PER_TILE && armyMiniX <= mapWidth &&
            armyMiniY >= -MINIMAP_PIXEL_PER_TILE && armyMiniY <= mapHeight
        ) {
            minimapCtx.fillStyle = "blue"; 
            minimapCtx.fillRect(armyMiniX, armyMiniY, MINIMAP_PIXEL_PER_TILE +1, MINIMAP_PIXEL_PER_TILE+1);
        }
      }
  });

  const viewRectWidthOnMinimap = (DOMElements.gameCanvas.width / TILE_WIDTH_ISO) * MINIMAP_PIXEL_PER_TILE;
  const viewRectHeightOnMinimap = (DOMElements.gameCanvas.height / TILE_HEIGHT_ISO) * MINIMAP_PIXEL_PER_TILE;
  
  minimapCtx.strokeStyle = "yellow";
  minimapCtx.lineWidth = 1;
  minimapCtx.strokeRect(
    mapCenterX - viewRectWidthOnMinimap / 2,
    mapCenterY - viewRectHeightOnMinimap / 2,
    viewRectWidthOnMinimap,
    viewRectHeightOnMinimap,
  );

  const baseMiniX = mapCenterX + (BASE_LOCATION_GRID.x - minimapViewRefX) * MINIMAP_PIXEL_PER_TILE;
  const baseMiniY = mapCenterY + (BASE_LOCATION_GRID.y - minimapViewRefY) * MINIMAP_PIXEL_PER_TILE;
  minimapCtx.fillStyle = "cyan";
  minimapCtx.beginPath();
  minimapCtx.arc(
    baseMiniX + MINIMAP_PIXEL_PER_TILE / 2,
    baseMiniY + MINIMAP_PIXEL_PER_TILE / 2,
    3,
    0,
    Math.PI * 2,
  );
  minimapCtx.fill();
}





function generateWorldOutpostsIfNeeded() {
  const isInitialGeneration = gameState.worldMap.outposts.length === 0 && gameState.stats.timePlayed < 5; // Check if it's very early game
  let desiredOutpostCount = 5 + gameState.age * 3 + Math.floor(gameState.stats.mapExpansions / 2);
  let outpostSpawnRadiusMinDefault = 10 + gameState.age * 3;
  let outpostSpawnRadiusMaxDefault = MAX_MAP_GRID_DIM - 5;

  let numToGenerate = desiredOutpostCount - gameState.worldMap.outposts.length;

  if (isInitialGeneration) {
    // Ensure at least 2-3 initial outposts, some very close
    numToGenerate = Math.max(numToGenerate, 1 + Math.floor(Math.random() * 2)); // Generate 1 or 2 for the start
  }

  if (numToGenerate <= 0) return;

  for (let i = 0; i < numToGenerate; i++) {
    let attempts = 0;
    let newOutpostX, newOutpostY;
    let validPosition = false;

    let currentRadiusMin = outpostSpawnRadiusMinDefault;
    let currentRadiusMax = outpostSpawnRadiusMaxDefault;
    let forceDiscoverThisOutpost = false;
    let currentOutpostAge = Math.min(
        AGES.length - 1,
        Math.floor(gameState.age + (Math.random() * (currentRadiusMax - currentRadiusMin) + currentRadiusMin) / 25),
      );

    if (isInitialGeneration && gameState.worldMap.outposts.length < 2) { // Logic for the first 1 or 2 initial outposts
        currentRadiusMin = 6; // Make them closer for initial set
        currentRadiusMax = 9; // Ensure they are within initial discovery range
        forceDiscoverThisOutpost = true;
        currentOutpostAge = 0; // Initial outposts are Prehistoric
    }


    while (!validPosition && attempts < 50) {
      const angle = Math.random() * 2 * Math.PI;
      const radius =
        Math.random() * (currentRadiusMax - currentRadiusMin) +
        currentRadiusMin;
      newOutpostX = Math.round(BASE_LOCATION_GRID.x + Math.cos(angle) * radius);
      newOutpostY = Math.round(BASE_LOCATION_GRID.y + Math.sin(angle) * radius);

      newOutpostX = Math.max(-MAX_MAP_GRID_DIM, Math.min(MAX_MAP_GRID_DIM, newOutpostX));
      newOutpostY = Math.max(-MAX_MAP_GRID_DIM, Math.min(MAX_MAP_GRID_DIM, newOutpostY));

      let tooCloseToExisting = gameState.worldMap.outposts.some(
        (op) =>
          Math.sqrt(
            Math.pow(op.gridX - newOutpostX, 2) +
              Math.pow(op.gridY - newOutpostY, 2),
          ) < (isInitialGeneration && gameState.worldMap.outposts.length < 1 ? 4 : 8),
      );
      
      let tooCloseToPlayerBaseInitially = false;
      if (isInitialGeneration && gameState.worldMap.outposts.length < 1) {
          const distToBase = Math.sqrt(Math.pow(newOutpostX - BASE_LOCATION_GRID.x, 2) + Math.pow(newOutpostY - BASE_LOCATION_GRID.y, 2));
          if (distToBase < 5) tooCloseToPlayerBaseInitially = true; 
      }


      if (!tooCloseToExisting && !isTileOwned(newOutpostX, newOutpostY) && !tooCloseToPlayerBaseInitially) {
        validPosition = true;
      }
      attempts++;
    }

    if (validPosition) {
      const distance = Math.sqrt(
        Math.pow(newOutpostX - BASE_LOCATION_GRID.x, 2) +
          Math.pow(newOutpostY - BASE_LOCATION_GRID.y, 2),
      );
      
      const templateCandidates = ENEMY_OUTPOSTS.filter(e => e.minAge <= currentOutpostAge && e.maxAge >= currentOutpostAge);
      const template = templateCandidates.length > 0 ? templateCandidates[Math.floor(Math.random() * templateCandidates.length)] : ENEMY_OUTPOSTS[0];


      const outpostStrengthMod = 1 + distance / 40; 
      const baseStrength =
        template.composition.reduce((sum, comp) => {
          const unitDef = comp.unitDef || UNITS[comp.type];
          return (
            sum +
            ((comp.countMin + comp.countMax) / 2) *
              (unitDef.baseAttack + unitDef.baseDefense + unitDef.maxHp / 5)
          );
        }, 0) * (AGES[currentOutpostAge]?.enemyStrengthModifier || 1);

      const newOutpostIsActuallyDiscovered = forceDiscoverThisOutpost || !!gameState.map.discoveredTiles[`${newOutpostX},${newOutpostY}`];

      gameState.worldMap.outposts.push({
        id: uniqueId("outpost_"),
        name: `${AGES[currentOutpostAge].name.split(" ")[0]} Outpost (${template.name.split(" ")[0]})`,
        icon: template.icon,
        gridX: newOutpostX,
        gridY: newOutpostY,
        ageLevel: currentOutpostAge,
        composition: template.composition,
        rewardBase: Math.floor(template.rewardBase * (1 + currentOutpostAge * 0.15)),
        strength: Math.floor(baseStrength * outpostStrengthMod),
        isDefeated: false,
        isDiscovered: newOutpostIsActuallyDiscovered,
        isScouted: false,
      });
      
      if (newOutpostIsActuallyDiscovered) {
         if (!isTileDiscovered(newOutpostX, newOutpostY)) { // If tile itself wasn't discovered by global discoverArea
            markTileDiscovered(newOutpostX, newOutpostY); // This also handles the message
         } else { // Tile was already discovered, but we are adding a new outpost to it
            addMessage(`Discovered: ${AGES[currentOutpostAge].name.split(" ")[0]} Outpost at [${newOutpostX},${newOutpostY}]`, 'info');
         }
      }
    }
  }
  // This final loop ensures tile discovery consistency if an outpost was somehow marked discovered but its tile wasn't
  gameState.worldMap.outposts.forEach(outpost => {
      if (outpost.isDiscovered && !isTileDiscovered(outpost.gridX, outpost.gridY)) {
          markTileDiscovered(outpost.gridX, outpost.gridY); 
      }
  });
}

function openWorldMapOutpostInteractionModal(outpost) {
  lastClickedWorldOutpost = outpost; // Used for recall and other interactions
  DOMElements.worldMapOutpostModalTitle.textContent = outpost.name;

  const distance = Math.sqrt(
    Math.pow(outpost.gridX - BASE_LOCATION_GRID.x, 2) +
      Math.pow(outpost.gridY - BASE_LOCATION_GRID.y, 2),
  );
  const travelTimeEstimate = Math.floor(distance * 1.5) || 1; // Ensure at least 1s travel time
  let bodyHTML = `<p>Location: [${outpost.gridX}, ${outpost.gridY}]</p>`;
  bodyHTML += `<p>Distance: ${formatNumber(distance, 1)} units</p>`;

  const arrivedArmy = gameState.worldMap.deployedArmies.find(
    (army) => army.targetOutpostId === outpost.id && army.status === "arrived"
  );

  if (distance < 15 || outpost.isScouted || arrivedArmy) {
    bodyHTML += `<p>Strength: ${formatNumber(outpost.strength)}</p>`;
    bodyHTML += `<p>Dominant Age: ${AGES[outpost.ageLevel].name}</p>`;
    if (outpost.composition && outpost.composition.length > 0 && outpost.composition[0].unitDef) {
        bodyHTML += `Composition (estimate): ${outpost.composition.map((c) => `${c.unitDef.icon} x${c.countMin}-${c.countMax}`).join(", ")}`;
    } else {
        bodyHTML += `Composition: Unknown or N/A`;
    }
    outpost.isScouted = true;
  } else {
    bodyHTML += `<p>Strength: Unknown (Too far to scout)</p>`;
    bodyHTML += `<p>Dominant Age: Likely ${AGES[outpost.ageLevel].name}</p>`;
  }

  DOMElements.worldMapOutpostModalBody.innerHTML = bodyHTML;
  DOMElements.worldMapOutpostModalActions.innerHTML = "";

  if (arrivedArmy) {
    const attackButton = document.createElement("button");
    attackButton.className = "game-button error";
    attackButton.textContent = `Attack with Arrived Army (${arrivedArmy.units.map(u => `${u.icon}x${u.count}`).join(', ')})`;
    attackButton.onclick = () => {
      const encounterDataForBattle = {
        id: outpost.id,
        name: outpost.name,
        description: `Attacking world outpost: ${outpost.name}`,
        icon: outpost.icon,
        composition: outpost.composition,
        reward: outpost.rewardBase,
        ageLevel: outpost.ageLevel
      };
      initiateBattle(encounterDataForBattle, "world_outpost", arrivedArmy.id);
      hideModal(DOMElements.worldMapOutpostInteractionModal);
    };
    DOMElements.worldMapOutpostModalActions.appendChild(attackButton);

    const recallArrivedButton = document.createElement("button");
    recallArrivedButton.className = "game-button";
    recallArrivedButton.textContent = `Recall Arrived Army`;
    recallArrivedButton.onclick = () => {
        recallDeployedArmy(arrivedArmy.id);
        hideModal(DOMElements.worldMapOutpostInteractionModal);
    };
    DOMElements.worldMapOutpostModalActions.appendChild(recallArrivedButton);

  } else if (gameState.units.length > 0) { // Home base units exist
    const deployButton = document.createElement("button");
    deployButton.className = "game-button success";
    deployButton.textContent = `Deploy New Army from Base...`;
    deployButton.onclick = () => {
      openDeployUnitSelectionModal(outpost, travelTimeEstimate);
      hideModal(DOMElements.worldMapOutpostInteractionModal);
    };
    DOMElements.worldMapOutpostModalActions.appendChild(deployButton);
  } else {
    DOMElements.worldMapOutpostModalActions.innerHTML = "<p>No units available at base or arrived at outpost.</p>";
  }

  const closeButton = document.createElement("button");
  closeButton.className = "game-button";
  closeButton.textContent = "Close";
  closeButton.onclick = () => hideModal(DOMElements.worldMapOutpostInteractionModal);
  DOMElements.worldMapOutpostModalActions.appendChild(closeButton);

  showModal(DOMElements.worldMapOutpostInteractionModal);
}


function openDeployUnitSelectionModal(outpost, travelTime) {
    currentDeploymentTargetOutpost = outpost;
    currentDeploymentTravelTime = travelTime;

    DOMElements.deployUnitSelectionModalTitle.textContent = `Deploy to ${outpost.name}`;
    DOMElements.deployTravelTimeEstimate.textContent = travelTime;
    DOMElements.deployUnitSelectionModalBody.innerHTML = "";

    const homeUnitStacks = {};
    gameState.units.forEach(unit => {
        if (!homeUnitStacks[unit.type]) {
            homeUnitStacks[unit.type] = { unitDef: UNITS[unit.type], count: 0, originalIds: [] };
        }
        homeUnitStacks[unit.type].count++;
        // We don't strictly need originalIds here for selection, but good for complex scenarios
        homeUnitStacks[unit.type].originalIds.push(unit.id);
    });

    if (Object.keys(homeUnitStacks).length === 0) {
        DOMElements.deployUnitSelectionModalBody.innerHTML = "<p>No units available at base to deploy.</p>";
        DOMElements.confirmDeploymentButton.disabled = true;
    } else {
        DOMElements.confirmDeploymentButton.disabled = false;
        Object.values(homeUnitStacks).forEach(stack => {
            const div = document.createElement("div");
            div.className = "item-slot"; // Use existing styling for consistency
            div.style.cursor = "default";
            div.style.marginBottom = "8px";

            const iconDiv = document.createElement("div");
            iconDiv.className = "item-icon";
            iconDiv.textContent = stack.unitDef.icon;

            const detailsDiv = document.createElement("div");
            detailsDiv.className = "item-details";
            detailsDiv.innerHTML = `<div class="item-name">${stack.unitDef.name} (Avail: ${stack.count})</div>`;

            const input = document.createElement("input");
            input.type = "number";
            input.min = "0";
            input.max = stack.count.toString();
            input.value = "0";
            input.dataset.unitType = stack.unitDef.id;
            input.style.width = "70px";
            input.style.padding = "8px";
            input.style.textAlign = "right";
            input.style.marginLeft = "10px";
            input.style.backgroundColor = "var(--background-color)";
            input.style.color = "var(--text-color)";
            input.style.border = "1px solid var(--border-color)";
            input.style.borderRadius = "4px";

            div.appendChild(iconDiv);
            div.appendChild(detailsDiv);
            div.appendChild(input);
            DOMElements.deployUnitSelectionModalBody.appendChild(div);
        });
    }
    showModal(DOMElements.deployUnitSelectionModal);
}



function handleConfirmDeployment() {
    if (!currentDeploymentTargetOutpost) return;

    const selectedUnitStacksForDeployment = []; // To store { type, count, icon }
    const inputs = DOMElements.deployUnitSelectionModalBody.querySelectorAll('input[type="number"]');
    let totalUnitsToSend = 0;

    inputs.forEach(input => {
        const unitType = input.dataset.unitType;
        const count = parseInt(input.value, 10);
        if (count > 0 && UNITS[unitType]) {
            selectedUnitStacksForDeployment.push({ type: unitType, count: count, icon: UNITS[unitType].icon });
            totalUnitsToSend += count;
        }
    });

    if (totalUnitsToSend === 0) {
        showNotification("No units selected for deployment.", "info");
        return;
    }

    // Remove units from home base
    const remainingHomeUnits = [];
    const tempHomeUnitCounts = {}; // To track how many of each type we've taken

    // First, count how many of each type are available in gameState.units
    const availableHomeCounts = {};
    gameState.units.forEach(u => {
        availableHomeCounts[u.type] = (availableHomeCounts[u.type] || 0) + 1;
    });

    // Decrement counts for selected units
    for (const selection of selectedUnitStacksForDeployment) {
        if (availableHomeCounts[selection.type] && availableHomeCounts[selection.type] >= selection.count) {
            availableHomeCounts[selection.type] -= selection.count;
            gameState.resources.population -= UNITS[selection.type].population * selection.count;
        } else {
            // This should not happen if input max is set correctly, but as a safeguard:
            showNotification(`Error: Not enough ${UNITS[selection.type].name} available. Deployment cancelled.`, "error");
            // Restore population if any was deducted in this loop
            selectedUnitStacksForDeployment.slice(0, selectedUnitStacksForDeployment.indexOf(selection)).forEach(s => {
                 gameState.resources.population += UNITS[s.type].population * s.count;
            });
            return;
        }
    }

    // Reconstruct gameState.units based on remaining counts
    Object.entries(availableHomeCounts).forEach(([type, count]) => {
        for (let i = 0; i < count; i++) {
            // Find an original unit ID to keep, or just push new ones if IDs aren't critical for home base
            // For simplicity here, we'll just repopulate based on counts.
            // A more robust system might track specific unit IDs.
            remainingHomeUnits.push({
                id: uniqueId("unt_"), // Or try to preserve old IDs if needed elsewhere
                type: type,
                originalCost: UNITS[type].cost,
                recruitedAt: gameState.stats.timePlayed // Or find original recruitedAt
            });
        }
    });
    gameState.units = remainingHomeUnits;


    const newDeployedArmy = {
        id: uniqueId("army_"),
        targetOutpostId: currentDeploymentTargetOutpost.id,
        targetGridX: currentDeploymentTargetOutpost.gridX,
        targetGridY: currentDeploymentTargetOutpost.gridY,
        units: selectedUnitStacksForDeployment, // Format: [{type, count, icon}, ...]
        travelProgress: 0,
        totalTravelTime: currentDeploymentTravelTime,
        status: "marching",
        originalTravelTimeToTarget: currentDeploymentTravelTime
    };
    gameState.worldMap.deployedArmies.push(newDeployedArmy);

    addMessage(`Army deployed to ${currentDeploymentTargetOutpost.name}. Arrival in ${currentDeploymentTravelTime}s.`);
    showNotification(`Army marching to ${currentDeploymentTargetOutpost.name}!`, "info");

    hideModal(DOMElements.deployUnitSelectionModal);
    updateAllUIDisplays();
    currentDeploymentTargetOutpost = null; // Clear context
    currentDeploymentTravelTime = 0;
}





function deployArmyToOutpost(outpost, travelTime) {
  if (gameState.units.length === 0) {
    showNotification("No units to deploy!", "error");
    return;
  }
  const armyUnits = gameState.units.map((u) => ({ type: u.type, id: u.id }));
  const unitStacksForDeployment = {};
  armyUnits.forEach((unit) => {
    if (!unitStacksForDeployment[unit.type])
      unitStacksForDeployment[unit.type] = {
        type: unit.type,
        count: 0,
        icon: UNITS[unit.type].icon,
      };
    unitStacksForDeployment[unit.type].count++;
  });

  gameState.worldMap.deployedArmies.push({
    id: uniqueId("army_"),
    targetOutpostId: outpost.id,
    targetGridX: outpost.gridX,
    targetGridY: outpost.gridY,
    units: Object.values(unitStacksForDeployment),
    travelProgress: 0,
    totalTravelTime: travelTime,
    status: "marching",
  });

  gameState.units = [];
  gameState.resources.population = 0;

  addMessage(`Army deployed to ${outpost.name}. Arrival in ${travelTime}s.`);
  showNotification(`Army marching to ${outpost.name}!`, "info");
  hideModal(DOMElements.worldMapOutpostInteractionModal);
  updateAllUIDisplays();
}

function processDeployedArmies(deltaTime) {
  for (let i = gameState.worldMap.deployedArmies.length - 1; i >= 0; i--) {
    const army = gameState.worldMap.deployedArmies[i];

    if (army.status === "marching" || army.status === "returning") {
        const targetOutpost = gameState.worldMap.outposts.find(o => o.id === army.targetOutpostId);
        let startX = BASE_LOCATION_GRID.x, startY = BASE_LOCATION_GRID.y;
        let endX = army.targetGridX, endY = army.targetGridY; // Default to army's target X, Y

        if (army.status === "returning") {
            startX = army.gridX !== undefined ? army.gridX : army.targetGridX; // Start from current/last known position
            startY = army.gridY !== undefined ? army.gridY : army.targetGridY;
            endX = BASE_LOCATION_GRID.x;
            endY = BASE_LOCATION_GRID.y;
        }
        
        let currentTotalTravelTime = army.totalTravelTime || 1; // Avoid division by zero
        const progressRatio = Math.min(1, army.travelProgress / currentTotalTravelTime);

        army.gridX = startX + (endX - startX) * progressRatio;
        army.gridY = startY + (endY - startY) * progressRatio;
        
        if (army.gridX !== undefined && army.gridY !== undefined) {
             discoverArea(Math.round(army.gridX), Math.round(army.gridY), 2);
        }
    }

    if (army.status === "marching") {
      army.travelProgress += deltaTime;
      if (army.travelProgress >= army.totalTravelTime) {
        army.status = "arrived";
        army.travelProgress = army.totalTravelTime;
        army.gridX = army.targetGridX; 
        army.gridY = army.targetGridY;
        const outpost = gameState.worldMap.outposts.find(o => o.id === army.targetOutpostId);
        addMessage(`Army has arrived at ${outpost ? outpost.name : "destination"}!`, true);
        showNotification(`Army arrived at ${outpost ? outpost.name : "Unknown Outpost"}!`, "success");

        if (outpost && !outpost.isDefeated) {
          // Check if the modal is already open for this outpost to avoid re-opening issues
          const outpostModalVisible = DOMElements.worldMapOutpostInteractionModal.classList.contains("visible");
          if (!outpostModalVisible || (lastClickedWorldOutpost && lastClickedWorldOutpost.id !== outpost.id)) {
             openWorldMapOutpostInteractionModal(outpost);
          }
        } else { 
          addMessage(`Target ${outpost ? outpost.name : "outpost"} is gone or defeated. Army returning.`, "info");
          army.status = "returning";
          army.totalTravelTime = army.originalTravelTimeToTarget || army.totalTravelTime;
          army.travelProgress = 0; 
        }
      }
    } else if (army.status === "returning") {
      army.travelProgress += deltaTime;
      if (army.travelProgress >= army.totalTravelTime) {
        addMessage(`Army (ID: ...${army.id.slice(-4)}) has returned to base.`, true);
        showNotification(`Army returned!`, "success");
        
        army.units.forEach((stack) => {
          if (!UNITS[stack.type]) {
            console.warn("Unknown unit type in returning army stack:", stack.type);
            return;
          }
          for (let j = 0; j < stack.count; j++) {
            if (gameState.resources.population + UNITS[stack.type].population <= gameState.resources.maxPopulation) {
              gameState.units.push({
                id: uniqueId("ret_unt_"),
                type: stack.type,
                originalCost: UNITS[stack.type].cost, 
                recruitedAt: gameState.stats.timePlayed 
              });
              gameState.resources.population += UNITS[stack.type].population;
            } else {
              addMessage(`Could not field returning ${UNITS[stack.type].name} - no population space. Unit lost.`, "error");
            }
          }
        });
        gameState.worldMap.deployedArmies.splice(i, 1);
      }
    }
  }
  updateDeployedArmiesUI();
  if (gameState.stats.timePlayed % 2 === 0) renderGameView(); // Update map less frequently if not in battle
}

function updateDeployedArmiesUI() {
  DOMElements.deployedArmiesCount.textContent =
    gameState.worldMap.deployedArmies.length;
  if (gameState.worldMap.deployedArmies.length > 0) {
    DOMElements.deployedArmiesSection.style.display = "block";
    DOMElements.deployedArmiesList.innerHTML = gameState.worldMap.deployedArmies
      .map((army, index) => {
        const targetOutpost = gameState.worldMap.outposts.find(
          (o) => o.id === army.targetOutpostId,
        );
        const targetName = targetOutpost
          ? targetOutpost.name
          : "Unknown Location";
        let statusText = "";
        let progressPercent = 0;
        if (army.status === "marching") {
          progressPercent = Math.min(
            100,
            (army.travelProgress / army.totalTravelTime) * 100,
          );
          statusText = `Marching to ${targetName} (${formatNumber(army.travelProgress, 0)}s / ${army.totalTravelTime}s)`;
        } else if (army.status === "arrived") {
          progressPercent = 100;
          statusText = `Arrived at ${targetName}. Awaiting orders.`;
        } else if (army.status === "returning") {
          progressPercent = Math.min(
            100,
            (army.travelProgress / army.totalTravelTime) * 100,
          );
          statusText = `Returning from ${targetName} (${formatNumber(army.travelProgress, 0)}s / ${army.totalTravelTime}s)`;
        }

        const unitsSummary = army.units
          .map((u) => `${u.icon}x${u.count}`)
          .join(", ");

        let recallButtonHTML = "";
        if (army.status === "marching" || army.status === "arrived") {
          recallButtonHTML = `<button class="game-button building-cancel-button" onclick="recallDeployedArmy('${army.id}')" title="Recall Army">↪️</button>`;
        }

        return `<div class="deployed-army-info">
                            <div style="flex-grow:1;">
                                <span>${index + 1}. Army to ${targetName}</span><br>
                                <small>${statusText} (${unitsSummary})</small>
                            </div>
                            ${recallButtonHTML}
                        </div>
                        ${army.status !== "arrived" ? `<div class="progress-container" style="height:5px; margin-bottom:5px;"><div class="progress-bar-small" style="width:${progressPercent}%"></div></div>` : ""}`;
      })
      .join("");
  } else {
    DOMElements.deployedArmiesSection.style.display = "none";
  }
}
function recallDeployedArmy(armyId) {
  const army = gameState.worldMap.deployedArmies.find((a) => a.id === armyId);
  if (army && (army.status === "marching" || army.status === "arrived")) {
    army.status = "returning";
    if (army.status === "marching") { // Recalled while en route
        army.totalTravelTime = army.travelProgress; // Time to return is how far it got
    } else { // Recalled after arrival
        army.totalTravelTime = army.originalTravelTimeToTarget || army.totalTravelTime;
    }
    army.travelProgress = 0; 
    addMessage(`Army (ID: ...${army.id.slice(-4)}) recalled. Returning to base.`, "info");
    
    const outpostModalVisible = DOMElements.worldMapOutpostInteractionModal.classList.contains("visible");
    if (outpostModalVisible && lastClickedWorldOutpost && lastClickedWorldOutpost.id === army.targetOutpostId) {
        hideModal(DOMElements.worldMapOutpostInteractionModal);
    }
    updateDeployedArmiesUI(); // Update UI immediately
  }
}

function drawDeployedArmiesOnMap() {
  gameState.worldMap.deployedArmies.forEach((army) => {
    if (army.status === "marching" || army.status === "returning") {
      const targetOutpost = gameState.worldMap.outposts.find(
        (o) => o.id === army.targetOutpostId,
      );
      let currentGridX, currentGridY;

      let startX = BASE_LOCATION_GRID.x,
        startY = BASE_LOCATION_GRID.y;
      let endX = targetOutpost ? targetOutpost.gridX : BASE_LOCATION_GRID.x; // if no target, return to base
      let endY = targetOutpost ? targetOutpost.gridY : BASE_LOCATION_GRID.y;

      if (army.status === "returning") {
        // Swap start and end for returning
        [startX, endX] = [endX, startX];
        [startY, endY] = [endY, startY];
      }

      const progressRatio = army.travelProgress / army.totalTravelTime;
      currentGridX = startX + (endX - startX) * progressRatio;
      currentGridY = startY + (endY - startY) * progressRatio;
      army.gridX = currentGridX;
      army.gridY = currentGridY;

      if (!isTileDiscovered(Math.round(currentGridX), Math.round(currentGridY)))
        return;

      const screenPos = gridToScreen(currentGridX, currentGridY);
      ctx.font = `${TILE_HEIGHT_ISO * 0.6}px Arial`;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";

      ctx.fillStyle = "rgba(50, 150, 255, 0.7)";
      ctx.beginPath();
      ctx.ellipse(
        screenPos.x,
        screenPos.y + TILE_HEIGHT_ISO * 0.4,
        TILE_WIDTH_ISO * 0.2,
        TILE_HEIGHT_ISO * 0.15,
        0,
        0,
        Math.PI * 2,
      );
      ctx.fill();

      ctx.fillStyle = "white";
      ctx.fillText("⚔️", screenPos.x, screenPos.y);
    }
  });
}



    </script>
</body>
</html>
